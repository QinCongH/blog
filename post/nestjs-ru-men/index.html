<html>

<head>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>nestJs入门 | 禾耳</title>
<link rel="shortcut icon" href="https://qin_hu.gitee.io/blog//favicon.ico?v=1714022378479">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://qin_hu.gitee.io/blog//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="nestJs入门 | 禾耳 - Atom Feed" href="https://qin_hu.gitee.io/blog//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  <meta name="description" content="1.NestJS环境搭建和项目创建
1-1.简介

NestJS提供了一个开箱即用的应用程序架构，允许开发人员和团队创建高度可测试，可扩展，松散耦合且易于维护的应用程序。


官方网址：https://nestjs.com 中文文档：htt..." />
  <meta name="keywords" content="nodeJs" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
  <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"> -->
  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script> -->

  <!-- and it's easy to individually load additional languages -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/night-owl.min.css">


</head>

<body>
  <div class="main">
    <div class="main-content">
      <div class="site-header">
  <a href="https://qin_hu.gitee.io/blog/">
    <img class="avatar" src="https://qin_hu.gitee.io/blog//images/avatar.png?v=1714022378479" alt="">
  </a>

  <h1 class="site-title">
    禾耳
  </h1>
  <p class="site-description">
    逆风的方向，更适合飞翔。
  </p>
  <form style=" position: absolute;
  top: 50px;
  right: 150px;
  border: unset;
  outline: unset;display: flex;" id="gridea-search-form" action="https://qin_hu.gitee.io/blog//search/">
    <input placeholder="请输入.." style="color: #222 !important;margin-right: 10px;
   " name="q" />
    <svg onclick="window.location.reload()" style="
    cursor: pointer;    filter: invert(1);" title="刷新页面" class="shuaxin-icon" t="1705541456452" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"
      p-id="4229" width="20" height="20">
      <path
        d="M55.935033 264.48948c0 0 85.897017-132.548409 221.81443-203.673173 135.916406-71.121743 303.368504-50.646859 413.187968 18.319527 109.819465 68.970415 146.791894 127.160016 146.791894 127.160016l94.59499-53.879895c0 0 19.576483-9.697092 19.576483 12.932142l0 338.379961c0 0 0 30.17399-22.837719 19.395191-19.210878-9.062571-226.959086-127.198289-292.424528-164.466828-35.950145-16.035251-4.365101-29.062068-4.365101-29.062068l91.284402-52.173738c0 0-52.068992-65.209619-128.278989-99.744682-81.576231-42.501826-157.948384-47.541735-251.497925-12.224097-61.002644 23.025054-132.823368 81.988166-184.553949 169.082716L55.935033 264.48948 55.935033 264.48948 55.935033 264.48948zM904.056909 711.697844c0 0-85.897017 132.550423-221.816444 203.671159-135.917413 71.12275-303.366489 50.651895-413.186961-18.315498-109.825508-68.972429-146.790886-127.165052-146.790886-127.165052L27.662591 823.768348c0 0-19.572454 9.703135-19.572454-12.932142L8.090137 472.459267c0 0 0-30.170968 22.831676-19.397205 19.211885 9.067607 226.965129 127.198289 292.430571 164.470856 35.950145 16.035251 4.366109 29.058039 4.366109 29.058039l-91.285409 52.175753c0 0 52.071006 65.206598 128.279996 99.744682 81.57321 42.498804 157.942341 47.540728 251.496918 12.222082 60.998616-23.026061 132.820346-81.983131 184.546898-169.082716L904.056909 711.697844 904.056909 711.697844 904.056909 711.697844zM904.056909 711.697844"
        fill="#2c2c2c" p-id="4230"></path>
    </svg>
  </form>
  <button style="    border: unset;
  background: #f0f8ff00;cursor: pointer;" class="theme-button" onclick="changeTheme()">
    🌙
  </button>
  <div class="menu-container">
    
    
    <a href="https://qin_hu.gitee.io/blog/" class="menu">
      首页
    </a>
    
    
    
    <a href="https://qin_hu.gitee.io/blog/archives" class="menu">
      归档
    </a>
    
    
    
    <a href="https://qin_hu.gitee.io/blog/tags" class="menu">
      标签
    </a>
    
    
    
    <a href="https://qin_hu.gitee.io/blog/friend" class="menu">
      友链
    </a>
    
    
    
    <a href="https://qin_hu.gitee.io/blog/about" class="menu">
      关于
    </a>
    
    
  </div>
  <div class="social-container">
    
    
    <a href="https://github.com/QinCongH" target="_blank">
      <i class="ri-github-line"></i>
    </a>
    
    
    
    
    
    
    
    
    
    
  </div>
</div>
<script>
  window.addEventListener('load', () => {
    const themeType = localStorage.getItem('theme')
    const bodyDom = document.querySelector('body')
    const themeButtonDom = document.querySelector('.theme-button')
    // console.log(1111111111111111, themeType)
    if (themeType === 'light') {
      bodyDom.removeAttribute('thmem-dark')
      themeButtonDom.textContent = '🌙'
      localStorage.setItem('theme', 'light')
    } else {
      bodyDom.setAttribute('thmem-dark', '')
      themeButtonDom.textContent = '🌞'
      localStorage.setItem('theme', 'dark')
    }
  })

  function changeTheme() {
    const bodyDom = document.querySelector('body')
    const themeButtonDom = document.querySelector('.theme-button')
    const attr = bodyDom.hasAttribute('thmem-dark')
    if (attr) {
      bodyDom.removeAttribute('thmem-dark')
      themeButtonDom.textContent = '🌙'
      localStorage.setItem('theme', 'light')
    } else {
      bodyDom.setAttribute('thmem-dark', '')
      themeButtonDom.textContent = '🌞'
      localStorage.setItem('theme', 'dark')
    }
  }
</script>
      <div class="post-detail">
        <article class="post">
          <h2 class="post-title">
            nestJs入门
          </h2>
          <div class="post-info">
            <span>
              2024-01-09
            </span>
            <span>
              17 min read
            </span>
            
            <a href="https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/" class="post-tag">
              # nodeJs
            </a>
            
          </div>
          
          <div class="post-content-wrapper">
            <div class="post-content" v-pre>
              <h1 id="1nestjs环境搭建和项目创建">1.NestJS环境搭建和项目创建</h1>
<h2 id="1-1简介">1-1.简介</h2>
<blockquote>
<p>NestJS提供了一个开箱即用的应用程序架构，允许开发人员和团队创建高度可测试，可扩展，松散耦合且易于维护的应用程序。</p>
</blockquote>
<blockquote>
<p>官方网址：https://nestjs.com 中文文档：https://www.nestjs.com.cn/</p>
</blockquote>
<h2 id="1-2项目创建">1-2.项目创建</h2>
<h3 id="1-2-1-准备">1-2-1. 准备</h3>
<ul>
<li>安装Node</li>
</ul>
<h3 id="1-2-2-创建项目">1-2-2. 创建项目</h3>
<ul>
<li>全局安装nestjs脚手架</li>
</ul>
<p><code>npm i -g @nestjs/cli</code></p>
<ul>
<li>脚手架生成并启动项目</li>
</ul>
<pre><code>nest new nestjs-demo
cd nest-demo
npm run start
</code></pre>
<h3 id="1-2-3启动项目">1-2-3.启动项目</h3>
<p>打开<code>package.json </code>文件可以看的下面的代码</p>
<pre><code>&quot;start&quot;: &quot;nest start&quot;,                              // 最常用的开始模式
&quot;start:dev&quot;: &quot;nest start --watch&quot;,                  // 开发模式的启动 有监视功能
&quot;start:debug&quot;: &quot;nest start --debug --watch&quot;,        // 调试Bug时的启动 调试程序时使用
</code></pre>
<p>一般常用<code>npm run start:dev</code>启动项目。</p>
<h1 id="2项目目录简介和编写helloworld">2.项目目录简介和编写helloworld</h1>
<h2 id="2-1-目录介绍">2-1. 目录介绍</h2>
<p>脚手架生成的目录结构</p>
<pre><code>+-- dist[目录]                      // 编译后的目录，用于预览项目
+-- node_modules[目录]              // 项目使用的包目录，开发使用和上线使用的都在里边
+-- src[目录]                       // 源文件/代码，程序员主要编写的目录
|  +-- app.controller.spec.ts      // 对于基本控制器的单元测试样例
|  +-- app.controller.ts           // 控制器文件，可以简单理解为路由文件
|  +-- app.module.ts               // 模块文件，在NestJS世界里主要操作的就是模块
|  +-- app.service.ts              // 服务文件，提供的服务文件，业务逻辑编写在这里
|  +-- app.main.ts                 // 项目的入口文件，里边包括项目的主模块和监听端口号
+-- test[目录]                      // 测试文件目录，对项目测试时使用的目录，比如单元测试...
|  +-- app.e2e-spec.ts             // e2e测试，端对端测试文件，测试流程和功能使用
|  +-- jest-e2e.json               // jest测试文件，jset是一款简介的JavaScript测试框架
+-- .eslintrc.js                   // ESlint的配置文件
+-- .gitignore                     // git的配置文件，用于控制哪些文件不受Git管理
+-- .prettierrc                    // prettier配置文件，用于美化/格式化代码的
+-- nest-cli.json                  // 整个项目的配置文件，这个需要根据项目进行不同的配置
+-- package-lock.json              // 防止由于包不同，导致项目无法启动的配置文件，固定包版本
+-- package.json                   // 项目依赖包管理文件和Script文件，比如如何启动项目的命令
+-- README.md                      // 对项目的描述文件，markdown语法
+-- tsconfig.build.json            // TypeScript语法构建时的配置文件
+-- tsconfig.json                  // TypeScript的配置文件，控制TypeScript编译器的一些行为       
</code></pre>
<p>src目录，编写代码的目录</p>
<pre><code>+-- src[目录]                       // 源文件/代码，程序员主要编写的目录
|  +-- app.controller.spec.ts      // 对于基本控制器的单元测试样例
|  +-- app.controller.ts           // 控制器文件，可以简单理解为路由文件
|  +-- app.module.ts               // 模块文件，在NestJS世界里主要操作的就是模块
|  +-- app.service.ts              // 服务文件，提供的服务文件，业务逻辑编写在这里
|  +-- app.main.ts                 // 项目的入口文件，里边包括项目的主模块和监听端口号
</code></pre>
<h2 id="2-2编写helloworld">2-2.编写helloworld</h2>
<p>在<code>main.ts</code>中可以看的启动的端口是3000，启动项目后在浏览器输入<code>localhost:3000</code>可以看的输出的HelloWorld。<br>
在<code>/src/app.service.ts</code>文件中修改<code>getHello()</code>的代码</p>
<pre><code>import { Injectable } from '@nestjs/common';
//方法
@Injectable()
export class AppService {
  getHello(): string {
    //return 'Hello World';  //原来代码
    return 'Hello';
  }
}

</code></pre>
<p>此时可以看到浏览器新的输出Hello。</p>
<h1 id="3controller控制器-路由和模块的创建">3.Controller控制器-路由和模块的创建</h1>
<h2 id="3-1-创建路由">3-1. 创建路由</h2>
<h3 id="3-1-1-新建路由">3-1-1. 新建路由</h3>
<p>在<code>app.controller.ts</code> 文件中<code>@Get()</code>新建路由</p>
<pre><code>import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';
//顶层路径 默认是'/'； 传'api'即顶层路径是'/api'
@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}
  //底层路由 不传是'/'  传'hellotest'即路由是'/hellotest' 路径根据顶层路由决定
  @Get('hellotest')
  getHello(): string {
    return this.appService.getHello();
  }
}

</code></pre>
<p>此时可以使用<code>localhost:3000/hellotest</code>访问getHello()的输出。</p>
<h3 id="3-1-2-添加顶层路径">3-1-2. 添加顶层路径</h3>
<p>在<code>app.controller.ts</code> 文件中的@Controller()装饰器中添加顶层路径</p>
<pre><code>import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';
@Controller('api')//修改内容
export class AppController {
  constructor(private readonly appService: AppService) {}
  @Get('hellotest')
  getHello(): string {
    return this.appService.getHello();
  }
}
</code></pre>
<p>此时使用<code>localhost:3000/api/hellotest</code>访问getHello()的输出。</p>
<p>##　3-2.新建模块</p>
<h3 id="3-2-1初始化目录">3-2-1.初始化目录</h3>
<ol>
<li>删除脚手架自动生成的测试文件<code>app.controller.spec.ts</code>、控制文件<code>app.controller.ts</code> 和<code>app.service.ts</code></li>
<li>删除<code>app.module.ts</code>文件中对刚刚删除文件的引入</li>
</ol>
<pre><code>//删除后的app.module.ts
import { Module } from '@nestjs/common';

@Module({
  imports: [],
  controllers: [],
  providers: [],
})
export class AppModule {}
</code></pre>
<h3 id="3-2-2使用命令创建模块">3-2-2.使用命令创建模块</h3>
<p><code>nest g module 模块名</code></p>
<p>在命令行输入<code>nest g module user</code>会在<code>src</code>目录自动生成<code>user/user.module.ts</code>文件</p>
<pre><code>import { Module } from '@nestjs/common';

@Module({})
export class UserModule {}
</code></pre>
<p>此时<code>app.module.ts</code>文件会自动引入当前模块</p>
<pre><code>import { Module } from '@nestjs/common';
import { GirlModule } from './girl/girl.module';

@Module({
  imports: [GirlModule],
  controllers: [],
  providers: [],
})
export class AppModule {}

</code></pre>
<h3 id="3-2-3-使用命令创建一个controller控制器">3-2-3. 使用命令创建一个controller控制器</h3>
<p><code>nest g controller 模块名 --no-spec </code><br>
在控制台输入<code>nest g controller user --no-spec</code>会自动生成一个<code>user.controller.ts</code>文件</p>
<pre><code>import { Controller } from '@nestjs/common';

@Controller('user')
export class UserController {}
</code></pre>
<p>此时<code>user.module.ts</code>文件会自动引入当前控制器模块</p>
<pre><code>import { Module } from '@nestjs/common';
import { UserController } from './user.controller';

@Module({
  controllers: [UserController],
})
export class UserModule {}

</code></pre>
<p>创建完成之后可以在<code>user.controller.ts</code>文件中写一个路由测试模块。</p>
<pre><code>import { Controller, Get } from '@nestjs/common';

@Controller('user')
export class UserController {
    @Get()
  getUserInfo(): any {
        return{
          code:0,
          data:[&quot;小明&quot;,&quot;小方&quot;],
        }
      };
}

</code></pre>
<p>测试<code>localhost:3000/user</code>返回内容</p>
<pre><code>{
     &quot;code&quot;: 0,
     &quot;data&quot;: [
          &quot;小明&quot;,
          &quot;小方&quot;
     ]
}
</code></pre>
<h2 id="3-3创建全局路由前缀">3-3.创建全局路由前缀</h2>
<p>在<code>main.ts</code>中添加<code>app.setGlobalPrefix('api');</code><br>
此时访问user模块的路由<code>localhost:3000/api/user</code><br>
所有模块的路由都会默认添加配置的<code>api</code>前缀</p>
<h1 id="4controller控制器-业务逻辑相结合">4.Controller控制器-业务逻辑相结合</h1>
<h2 id="4-1-使用命令创建一个service">4-1. 使用命令创建一个service</h2>
<p><code>nest g service 模块名 --no-spec</code></p>
<p>在控制台输入<code>nest g service user --no-spec</code>在src目录会自动生成一个<code>user.service.ts</code>文件。<br>
service属于逻辑层，主要写业务逻辑。</p>
<h2 id="4-2controller控制器引入service逻辑">4-2.Controller（控制器）引入service（逻辑）</h2>
<p><code>user.controller.ts</code></p>
<pre><code>import { Controller, Get } from '@nestjs/common';
import { UserService } from './user.service';//引入service
@Controller('user')
export class UserController {
    constructor(private userService: UserService) { }  //构造userService函数，private归定属性只能在内部使用
}
</code></pre>
<h2 id="4-3在service里编写业务逻辑">4-3.在service里编写业务逻辑</h2>
<p><code>user.service.ts</code></p>
<pre><code>import { Injectable } from '@nestjs/common';

@Injectable()
export class UserService {
    getInfos(){//类方法
        return {
            msg:'ok'
        }
    }
}

</code></pre>
<h2 id="4-4在controller中得到service的类方法">4-4.在Controller中得到service的类方法</h2>
<pre><code>import { Controller, Get } from '@nestjs/common';
import { UserService } from './user.service';//引入service
@Controller('user')
export class UserController {
    constructor(private userService: UserService) { }  //构造userService函数，private归定属性只能在内部使用
    @Get('getInfos')  //路由
    getInfos():any{ //any表示任意类型
        return this.userService.getInfos()
    }
}

</code></pre>
<h1 id="5get和post请求">5.Get和Post请求</h1>
<h2 id="5-1get请求">5-1.Get请求</h2>
<h3 id="在service里写一个带参数的方法根据参数指定返回值">在service里写一个带参数的方法，根据参数指定返回值。</h3>
<p><code>user.service.ts</code></p>
<pre><code>import { Injectable } from '@nestjs/common';
@Injectable()
export class UserService {
    //带参数的方法
    searchUser(userid: string) {
        let obj: Object = {}
        switch (userid) {
            case '1':
                obj = {
                    name: 'user1'
                }
                break;
            case '2':
                obj = {
                    name: 'user2'
                }
                break;
            default:
                break;
        }
        return obj
    }

}

</code></pre>
<h3 id="在controller中使用query装饰器接收参数">在<code>Controller</code>中使用<code>Query</code>装饰器接收参数</h3>
<p><code>user.controller.ts</code></p>
<pre><code>import { Controller, Get,Query } from '@nestjs/common';//引入Query装饰器
import { UserService } from './user.service';//引入service
@Controller('user')
export class UserController {
    constructor(private userService: UserService) { }  //构造userService函数，private归定属性只能在内部使用
    //带参数的get请求
    @Get(&quot;/searchUser&quot;)
    searchUser(@Query() query):any{//使用Query装饰器，相当于req.query.userid
        return this.userService.searchUser(query.userid)
    }
}

</code></pre>
<h2 id="5-2post请求">5-2.Post请求</h2>
<h3 id="在service里写一个带参数的方法">在service里写一个带参数的方法</h3>
<p><code>user.service.ts</code></p>
<pre><code>import { Injectable } from '@nestjs/common';
@Injectable()
export class UserService {
    //post接收对象的方法
    addUser(obj: any): any {
        interface User {    //定义接口
            name: string,
            age: number,
            readonly id: number
        }
        let userid = 1
        let xm: User = {
            name: obj.name,
            age: parseInt(obj.age),
            id: userid
        };
        return xm
    }
}

</code></pre>
<h3 id="在controller中使用body装饰器接收参数">在<code>Controller</code>中使用<code>Body</code>装饰器接收参数</h3>
<pre><code>
import { Body,Controller, Get,Post } from '@nestjs/common';
import { UserService } from './user.service';//引入service
@Controller('user')
export class UserController {
    constructor(private userService: UserService) { }  
    //带请求的post
    @Post(&quot;/addUser&quot;)
    addUser(@Body() body):any{
        return this.userService.addUser(body)
    }
}

</code></pre>
<h2 id="5-3使用request装饰器接收请求">5-3.使用Request装饰器接收请求</h2>
<p><code>Request</code>装饰器相当于<code>req</code>的简写，<code>Query</code>装饰器相当于<code>req.query</code>的简写，<code>Body</code>装饰器相当于<code>req.body</code>的简写。所以<code>Request</code>装饰器的使用与其他两个使用大同小异。</p>
<p><code>user.controller.ts</code></p>
<pre><code>import { Controller, Get,,Post,Request } from '@nestjs/common';
import { UserService } from './user.service';//引入service
@Controller('user')
export class UserController {
    constructor(private userService: UserService) { }  //构造userService函数，private归定属性只能在内部使用
    //带参数的get请求
    @Get(&quot;/searchUser&quot;)
    searchUser(@Request() req):any{
        return this.userService.searchUser(req.query.userid)
    }
}

</code></pre>
<p>先引入<code>Request</code>装饰器,然后在类方法中使用。</p>
<h1 id="6创建动态路由">6.创建动态路由</h1>
<h2 id="6-1介绍">6-1.介绍</h2>
<ul>
<li>普通的路由传参方法，显示传递</li>
</ul>
<p><code>http://localhost:3000/user/searchUser?id=1</code></p>
<ul>
<li>动态路由传参方法，隐式传递</li>
</ul>
<p><code>http://localhost:3000/user/searchUser/1</code></p>
<ul>
<li>动态路由使用<code>/info/:userid</code>的方式创建路由，使用<code>req.params</code>接收参数</li>
</ul>
<h2 id="6-2使用request装饰器接收动态路由参数">6-2.使用Request装饰器接收动态路由参数</h2>
<p><code>user.controller.ts</code></p>
<pre><code>...    
//@动态路由
    @Get(&quot;getByIdList/:userid&quot;)
    getByIdList(@Request() req): any {
        console.log(req.params)
        let userid:string=req.params.userid
        return this.userService.getByIdList(userid)
    }
...
</code></pre>
<h2 id="6-3使用param装饰器">6-3.使用Param装饰器</h2>
<p><code>Param</code>装饰器相当于<code>req.params</code>的简写</p>
<ul>
<li>
<p>先引入 <code>import { Param } from '@nestjs/common';</code></p>
</li>
<li>
<p>使用</p>
</li>
</ul>
<p><code>user.controller.ts</code>:</p>
<pre><code>...
    getByIdList(@Param() params): any {
        let userid: string = params.userid
        return this.userService.getByIdList(userid)
    }
...
</code></pre>
<h2 id="6-4动态路由多个参数传递">6-4.动态路由多个参数传递</h2>
<ul>
<li>请求</li>
</ul>
<p><code>getByIdList/1/18/xm</code></p>
<ul>
<li>接收</li>
</ul>
<p><code>getByIdList/:userid/:age/:name</code></p>
<h1 id="7-常用装饰器总结">7. 常用装饰器总结</h1>
<h2 id="7-1-get">7-1. @Get</h2>
<h2 id="7-2-post">7-2. @Post</h2>
<h2 id="7-3-request">7-3. @Request</h2>
<h2 id="7-4-param">7-4. @Param</h2>
<h2 id="7-5-query">7-5. @Query</h2>
<h2 id="7-6-body">7-6. @Body</h2>
<h2 id="7-7-headers">7-7. @Headers</h2>
<h3 id="介绍">介绍</h3>
<blockquote>
<p>读取请求头里边的信息</p>
</blockquote>
<h3 id="使用">使用</h3>
<ul>
<li>引入</li>
</ul>
<p><code>import {Headers } from '@nestjs/common';</code></p>
<ul>
<li>示例</li>
</ul>
<pre><code>    @Get(&quot;getByIdList/:userid&quot;)
    //使用params装饰器
    getByIdList(@Param() params,@Headers() header): any {
        console.log(header)  //打印header信息
        let userid: string = params.userid
        return this.userService.getByIdList(userid)
    }
</code></pre>
<h1 id="8使用orm工具">8.使用ORM工具</h1>
<h2 id="介绍-2">介绍</h2>
<blockquote>
<p>ORM 是 Object Relational Mapping 的缩写，译为“对象关系映射”，它解决了对象和关系型数据库之间的数据交互问题。ORM的作用就是：定义一个对象，这个对象就对应着一张表，这个对象的一个实例，就对应着表中的一条记录。 这样作的好处，就是我们可以通过对象的形式，来操作数据库。</p>
</blockquote>
<h2 id="常见的orm工具">常见的ORM工具</h2>
<p><code>TypeOrm</code> https://typeorm.bootcss.com/</p>
<h1 id="9nestjs中使用typeorm">9.nestJs中使用TypeOrm</h1>
<h2 id="9-1安装typeorm和mysql2">9-1.安装TypeOrm和mysql2</h2>
<pre><code>npm install --save @nestjs/typeorm typeorm mysql2
</code></pre>
<h2 id="9-2引入">9-2.引入</h2>
<p>在<code>/src/app.module.ts</code>中引入<code>typeorm</code></p>
<pre><code>import { TypeOrmModule } from '@nestjs/typeorm';

@Module({
  imports:[ TypeOrmModule.forRoot({
    type:'mysql',           // 数据库类型
    host:'localhost',       // 数据库的连接地址host
    port:3306,              // 数据库的端口 3306
    username:'root',        // 连接账号
    password:'root123',     // 连接密码
    database:'test_db',     // 连接的表名
    retryDelay:500,         // 重试连接数据库间隔
    retryAttempts:10,       // 允许重连次数
  })] 
})

</code></pre>
<h1 id="10数据库操作-typeorm的实体操作">10.数据库操作-TypeORM的实体操作</h1>
<h2 id="概念-typeorm中的实体entities">概念--TypeORM中的实体Entities</h2>
<blockquote>
<p>ORM中的实体其实就是把数据库映射成对象的那个类。这个类可以模拟数据库表，定义其中的字段。</p>
</blockquote>
<p>我们需要定义实体类操作数据库。</p>
<h2 id="增加配置项">增加配置项</h2>
<p>想让TypeORM自动工作，为我们创建对应的数据库结构，我们需要先在配置数据库连接的地方增加两个配置项</p>
<ol>
<li>允许实体同步到数据库</li>
<li>自动加载实体。</li>
</ol>
<pre><code>import { Module } from '@nestjs/common';
import { UserModule } from './user/user.module';
import { TypeOrmModule } from &quot;@nestjs/typeorm&quot;;
@Module({
  imports: [UserModule, //连接数据库
    TypeOrmModule.forRoot({
      type: 'mysql',           // 数据库类型
      host: 'localhost',       // 数据库的连接地址host
      port: 3306,              // 数据库的端口 3306
      username: 'root',        // 连接账号
      password: 'root',     // 连接密码
      database: 'nest-test',     // 连接的库名
      retryDelay: 500,         // 重试连接数据库间隔
      retryAttempts: 10,       // 允许重连次数
      synchronize:true,       // 是否将实体同步到数据库
      autoLoadEntities:true,  // 自动加载实体配置，forFeature()注册的每个实体都自己动加载
    })
  ],
  controllers: [],
  providers: [],
})
export class AppModule { }
</code></pre>
<h2 id="编写entities实体">编写Entities实体</h2>
<ol>
<li>创建文件</li>
</ol>
<blockquote>
<p>进入模块文件夹，新建<code>entities</code>文件夹，新建<code>modulename.entities.ts</code>文件</p>
</blockquote>
<ol start="2">
<li>编写实体类</li>
</ol>
<pre><code>//引入entity,Column装饰器定义列对应表头，PrimaryGeneratedColumn装饰器对应主键
import { Entity,Column,PrimaryGeneratedColumn } from &quot;typeorm&quot;;

@Entity()
export class User{
    @PrimaryGeneratedColumn()
    id:number   //id,主键
    @Column()
    username:string
    @Column()
    age:number
    @Column()
    skill:string
}
</code></pre>
<p>3.模块中引入<br>
在<code>@Module( )</code>装饰器中用<code>forFeature( )</code>方法，把User的实体引入。</p>
<pre><code>import { Module } from '@nestjs/common';
import { UserController } from './user.controller';
import { UserService } from './user.service';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from &quot;./entities/user.entities&quot;
@Module({
  imports: [TypeOrmModule.forFeature([User])],
  controllers: [UserController],
  providers: [UserService]
})
export class UserModule { }
</code></pre>
<p>重新启动<code>npm run start:dev</code>此时数据库新建了<code>user</code>表</p>
<h1 id="11数据库操作-orm对数据库的增删改查">11.数据库操作-ORM对数据库的增删改查</h1>
<p>创建实体后，可以进行增删改查</p>
<h2 id="在service中引入装饰器和工具">在<code>service</code>中引入装饰器和工具</h2>
<pre><code>...
// 依赖注入
import { Like, Repository } from 'typeorm'
import { InjectRepository } from '@nestjs/typeorm'
import { User } from &quot;./entities/user.entities&quot;//引入实体


@Injectable()
export class UserService {
    //注入依赖后可以进行增删改查操作 user是当前的模块
  constructor(@InjectRepository(User) private readonly user: Repository&lt;User&gt;) { }
   ...

}


</code></pre>
<h2 id="实现新增">实现新增</h2>
<blockquote>
<p>使用<code>save</code>方法<br>
先new出一个模块的对象，然后用这个对象的save( )保存数据</p>
</blockquote>
<p><code>service</code>逻辑层文件</p>
<pre><code>    addTest(){
        const data=new User()
        data.username=&quot;test&quot;
        data.age=16
        data.skill=&quot;篮球&quot;
        return this.user.save(data)//使用save方法保存到数据库
    }
</code></pre>
<p>在控制器中配置路由并且引入路由<br>
<code>controller</code>路由文件</p>
<pre><code>    @Post(&quot;addTest&quot;)
    addTest(){
        return this.userService.addTest()
    }
</code></pre>
<p>在<code>postman</code>中测试<code>user/addtest</code>接口，将会新增一条数据</p>
<pre><code>{
&quot;username&quot;: &quot;test&quot;,
&quot;age&quot;: 16,
&quot;skill&quot;: &quot;篮球&quot;,
&quot;id&quot;: 1
}
</code></pre>
<h2 id="实现删除">实现删除</h2>
<blockquote>
<p>删除方法使用delete( )</p>
</blockquote>
<p><code>service</code>逻辑层文件</p>
<pre><code>    deleteTest(id: number) { //删除
        return this.user.delete(id) //使用delete方法执行删除
    }
</code></pre>
<p><code>controller</code>路由文件</p>
<pre><code>    @Get(&quot;deleteTest/:id&quot;)
    deleteTest(@Param() params){
        return this.userService.deleteTest(params.id)
    }
</code></pre>
<h2 id="实现修改数据">实现修改数据</h2>
<blockquote>
<p>修改数据接收两个数据，一个id和要修改的数据</p>
</blockquote>
<p><code>service</code>逻辑层文件</p>
<pre><code>   updateTest({
        id
    }) {
        let data = new User()
        data.username = &quot;qwereqw&quot;
        data.age =14
        data.skill = &quot;0000kioi&quot;
        return this.user.update(id,data)
    }
</code></pre>
<p><code>controller</code>路由文件</p>
<pre><code>    @Post(&quot;updataTest&quot;)
    updateTest(@Body() body){
        return this.userService.updateTest({
            id:body.id,
        })
    }
</code></pre>
<h2 id="实现查询数据">实现查询数据</h2>
<h3 id="查询所有">查询所有</h3>
<blockquote>
<p><code>find( )</code>方法查询所有</p>
</blockquote>
<p><code>service</code>逻辑层文件</p>
<pre><code>    findAll():any{
        return this.user.find()
    }
</code></pre>
<p><code>controller</code>路由文件</p>
<pre><code>    //查询所有
    @Get('findAll')
    findTest(){
        return this.userService.findAll()
    }
</code></pre>
<h3 id="模糊查询">模糊查询</h3>
<p><code>service</code>逻辑层文件</p>
<pre><code>    // 模糊查询 使用like
    //根据username查询list
    findUsername(username:string):any{
        return this.user.find({
            where:{
                username:Like(`%${username}`)
            }
        })
    }

</code></pre>
<p><code>controller</code>路由文件</p>
<pre><code>    //模糊查询 使用like
    @Get('findUsername/:username')
    findUsername(@Param() params){
        return this.userService.findUsername(params.username)
    }
</code></pre>
<p><a href="https://typeorm.bootcss.com/find-options">详细选项</a></p>
<h1 id="12-providers提供者实现依赖注入">12. Providers(提供者)实现依赖注入</h1>
<h1 id="参考学习链接">参考学习链接：</h1>
<p>https://jspang.com/article/87#toc2</p>
<h1 id="相关文档">相关文档</h1>
<p>https://typeorm.bootcss.com/<br>
https://www.nestjs.com.cn/</p>
<h1 id="可以参考的开发项目结构">可以参考的开发项目结构</h1>
<pre><code>prisam // 数据库相关
src
├─ auth // 授权登陆模块
│   ├─ auth.controller.ts
│   ├─ auth.guard.ts // 守卫 
│   ├─ auth.interface.ts // 存放局部的该模块的类型声明
│   ├─ auth.module.ts
│   ├─ auth.service.ts
│   ├─ dto
│   │   ├─ sign-in.dto.ts
│   ├─ entities
│   │   └─ refresh-token.entity.ts
├─ common // 全局通用模块
|   ├─ configs // 全局配置 
|   ├─ constants // 定义一些常量
|   ├─ decorators // 全局装饰器
|   ├─ filters // 全局过滤器
|   ├─ interceptors // 全局拦截器
|   ├─ interfaces // 全局类型声明
|   ├─ services // 全局公共服务
|   ├─ * // 其他
├─ utils // 工具函数, 尽量存放纯函数
├─ app.*.ts // app 模块, 其他 module 需要引用到 app module
├─ main.ts // 应用入口

</code></pre>

            </div>
            <div class="toc-container">
              <ul class="markdownIt-TOC">
<li><a href="#1nestjs%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA">1.NestJS环境搭建和项目创建</a>
<ul>
<li><a href="#1-1%E7%AE%80%E4%BB%8B">1-1.简介</a></li>
<li><a href="#1-2%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA">1-2.项目创建</a>
<ul>
<li><a href="#1-2-1-%E5%87%86%E5%A4%87">1-2-1. 准备</a></li>
<li><a href="#1-2-2-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">1-2-2. 创建项目</a></li>
<li><a href="#1-2-3%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE">1-2-3.启动项目</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%AE%80%E4%BB%8B%E5%92%8C%E7%BC%96%E5%86%99helloworld">2.项目目录简介和编写helloworld</a>
<ul>
<li><a href="#2-1-%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D">2-1. 目录介绍</a></li>
<li><a href="#2-2%E7%BC%96%E5%86%99helloworld">2-2.编写helloworld</a></li>
</ul>
</li>
<li><a href="#3controller%E6%8E%A7%E5%88%B6%E5%99%A8-%E8%B7%AF%E7%94%B1%E5%92%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%9B%E5%BB%BA">3.Controller控制器-路由和模块的创建</a>
<ul>
<li><a href="#3-1-%E5%88%9B%E5%BB%BA%E8%B7%AF%E7%94%B1">3-1. 创建路由</a>
<ul>
<li><a href="#3-1-1-%E6%96%B0%E5%BB%BA%E8%B7%AF%E7%94%B1">3-1-1. 新建路由</a></li>
<li><a href="#3-1-2-%E6%B7%BB%E5%8A%A0%E9%A1%B6%E5%B1%82%E8%B7%AF%E5%BE%84">3-1-2. 添加顶层路径</a></li>
<li><a href="#3-2-1%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9B%AE%E5%BD%95">3-2-1.初始化目录</a></li>
<li><a href="#3-2-2%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97">3-2-2.使用命令创建模块</a></li>
<li><a href="#3-2-3-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAcontroller%E6%8E%A7%E5%88%B6%E5%99%A8">3-2-3. 使用命令创建一个controller控制器</a></li>
</ul>
</li>
<li><a href="#3-3%E5%88%9B%E5%BB%BA%E5%85%A8%E5%B1%80%E8%B7%AF%E7%94%B1%E5%89%8D%E7%BC%80">3-3.创建全局路由前缀</a></li>
</ul>
</li>
<li><a href="#4controller%E6%8E%A7%E5%88%B6%E5%99%A8-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E7%9B%B8%E7%BB%93%E5%90%88">4.Controller控制器-业务逻辑相结合</a>
<ul>
<li><a href="#4-1-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAservice">4-1. 使用命令创建一个service</a></li>
<li><a href="#4-2controller%E6%8E%A7%E5%88%B6%E5%99%A8%E5%BC%95%E5%85%A5service%E9%80%BB%E8%BE%91">4-2.Controller（控制器）引入service（逻辑）</a></li>
<li><a href="#4-3%E5%9C%A8service%E9%87%8C%E7%BC%96%E5%86%99%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91">4-3.在service里编写业务逻辑</a></li>
<li><a href="#4-4%E5%9C%A8controller%E4%B8%AD%E5%BE%97%E5%88%B0service%E7%9A%84%E7%B1%BB%E6%96%B9%E6%B3%95">4-4.在Controller中得到service的类方法</a></li>
</ul>
</li>
<li><a href="#5get%E5%92%8Cpost%E8%AF%B7%E6%B1%82">5.Get和Post请求</a>
<ul>
<li><a href="#5-1get%E8%AF%B7%E6%B1%82">5-1.Get请求</a>
<ul>
<li><a href="#%E5%9C%A8service%E9%87%8C%E5%86%99%E4%B8%80%E4%B8%AA%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E6%A0%B9%E6%8D%AE%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E5%80%BC">在service里写一个带参数的方法，根据参数指定返回值。</a></li>
<li><a href="#%E5%9C%A8controller%E4%B8%AD%E4%BD%BF%E7%94%A8query%E8%A3%85%E9%A5%B0%E5%99%A8%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0">在<code>Controller</code>中使用<code>Query</code>装饰器接收参数</a></li>
</ul>
</li>
<li><a href="#5-2post%E8%AF%B7%E6%B1%82">5-2.Post请求</a>
<ul>
<li><a href="#%E5%9C%A8service%E9%87%8C%E5%86%99%E4%B8%80%E4%B8%AA%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95">在service里写一个带参数的方法</a></li>
<li><a href="#%E5%9C%A8controller%E4%B8%AD%E4%BD%BF%E7%94%A8body%E8%A3%85%E9%A5%B0%E5%99%A8%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0">在<code>Controller</code>中使用<code>Body</code>装饰器接收参数</a></li>
</ul>
</li>
<li><a href="#5-3%E4%BD%BF%E7%94%A8request%E8%A3%85%E9%A5%B0%E5%99%A8%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82">5-3.使用Request装饰器接收请求</a></li>
</ul>
</li>
<li><a href="#6%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1">6.创建动态路由</a>
<ul>
<li><a href="#6-1%E4%BB%8B%E7%BB%8D">6-1.介绍</a></li>
<li><a href="#6-2%E4%BD%BF%E7%94%A8request%E8%A3%85%E9%A5%B0%E5%99%A8%E6%8E%A5%E6%94%B6%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0">6-2.使用Request装饰器接收动态路由参数</a></li>
<li><a href="#6-3%E4%BD%BF%E7%94%A8param%E8%A3%85%E9%A5%B0%E5%99%A8">6-3.使用Param装饰器</a></li>
<li><a href="#6-4%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">6-4.动态路由多个参数传递</a></li>
</ul>
</li>
<li><a href="#7-%E5%B8%B8%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8%E6%80%BB%E7%BB%93">7. 常用装饰器总结</a>
<ul>
<li><a href="#7-1-get">7-1. @Get</a></li>
<li><a href="#7-2-post">7-2. @Post</a></li>
<li><a href="#7-3-request">7-3. @Request</a></li>
<li><a href="#7-4-param">7-4. @Param</a></li>
<li><a href="#7-5-query">7-5. @Query</a></li>
<li><a href="#7-6-body">7-6. @Body</a></li>
<li><a href="#7-7-headers">7-7. @Headers</a>
<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8">使用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8%E4%BD%BF%E7%94%A8orm%E5%B7%A5%E5%85%B7">8.使用ORM工具</a>
<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D-2">介绍</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84orm%E5%B7%A5%E5%85%B7">常见的ORM工具</a></li>
</ul>
</li>
<li><a href="#9nestjs%E4%B8%AD%E4%BD%BF%E7%94%A8typeorm">9.nestJs中使用TypeOrm</a>
<ul>
<li><a href="#9-1%E5%AE%89%E8%A3%85typeorm%E5%92%8Cmysql2">9-1.安装TypeOrm和mysql2</a></li>
<li><a href="#9-2%E5%BC%95%E5%85%A5">9-2.引入</a></li>
</ul>
</li>
<li><a href="#10%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C-typeorm%E7%9A%84%E5%AE%9E%E4%BD%93%E6%93%8D%E4%BD%9C">10.数据库操作-TypeORM的实体操作</a>
<ul>
<li><a href="#%E6%A6%82%E5%BF%B5-typeorm%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BD%93entities">概念--TypeORM中的实体Entities</a></li>
<li><a href="#%E5%A2%9E%E5%8A%A0%E9%85%8D%E7%BD%AE%E9%A1%B9">增加配置项</a></li>
<li><a href="#%E7%BC%96%E5%86%99entities%E5%AE%9E%E4%BD%93">编写Entities实体</a></li>
</ul>
</li>
<li><a href="#11%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C-orm%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">11.数据库操作-ORM对数据库的增删改查</a>
<ul>
<li><a href="#%E5%9C%A8service%E4%B8%AD%E5%BC%95%E5%85%A5%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E5%B7%A5%E5%85%B7">在<code>service</code>中引入装饰器和工具</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B0%E5%A2%9E">实现新增</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E5%88%A0%E9%99%A4">实现删除</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE">实现修改数据</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE">实现查询数据</a>
<ul>
<li><a href="#%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89">查询所有</a></li>
<li><a href="#%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2">模糊查询</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#12-providers%E6%8F%90%E4%BE%9B%E8%80%85%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">12. Providers(提供者)实现依赖注入</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5">参考学习链接：</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3">相关文档</a></li>
<li><a href="#%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E7%9A%84%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84">可以参考的开发项目结构</a></li>
</ul>

            </div>
          </div>
        </article>
      </div>

      
      <div class="next-post">
        <div class="next">下一篇</div>
        <a href="https://qin_hu.gitee.io/blog/post/ye-wu-fa-song-you-jian-nodemailer/">
          <h3 class="post-title">
            业务 - 发送邮件（nodemailer）
          </h3>
        </a>
      </div>
      

      

      <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://qin_hu.gitee.io/blog//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>
<div id="backtop">
    <a href="#backtop" class="backTop" title="回到顶部">
        <svg t="1702280870845" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"
            p-id="5528" width="50" height="50">
            <path
                d="M679.936 482.176l0.32-0.32-157.44-157.44c-6.912-6.912-18.112-6.912-25.024 0L342.4 479.872 342.592 480c-10.88 11.776-6.208 34.624 10.816 51.648s39.872 21.632 51.648 10.816L405.12 542.592l62.336-62.336 0 195.648c0 24 19.392 43.52 43.392 43.52s43.392-19.52 43.392-43.52L554.24 481.28l61.696 61.696c0.064 0.064 0.064 0.064 0.128 0.128l0.128 0.064 1.408 1.408 0.192-0.192c12.032 9.728 33.984 4.928 50.56-11.584C684.8 516.16 689.6 494.208 679.936 482.176z"
                fill="#8F9EB230" p-id="5529"></path>
            <path
                d="M512 64C264.576 64 64 264.576 64 512s200.576 448 448 448c247.36 0 448-200.64 448-448S759.36 64 512 64zM512 864.256c-194.56 0-352.192-157.76-352.192-352.256C159.808 317.504 317.44 159.808 512 159.808c194.496 0 352.192 157.696 352.192 352.192C864.192 706.496 706.496 864.256 512 864.256z"
                fill="#8F9EB230" p-id="5530"></path>
        </svg>
    </a>
</div>
<style>
.backTop {
  width: 50px;
  height: 50px;
  position: fixed;
  bottom: 50px;
  right: 50px;
  text-align: center;
  line-height: 50px;
  transition: .5s ease-in-out;

}

.backTop:hover {
  transform: translateY(15px);
}

#backtop {
  position: absolute;
  top: 0px;
  z-index: 100;
  opacity: 0;
}
</style>
<script>
    const bodyDom = document.querySelector('body')
    const backTopDom = document.querySelector('#backtop')
    document.addEventListener('scroll', (e) => {
        // console.log(bodyDom.scrollTop)
        if (bodyDom.scrollTop > 3550) {
            backTopDom.style.opacity = 1
        } else {
            backTopDom.style.opacity = 0
        }
    })
</script>
      <!-- <div class="theme">
    <input class="switch-input" id="theme-switch" type="checkbox">
    <label class="switch-control" for="theme-switch"></label>
    <div class="container"></div>
</div>
 -->
    </div>
  </div>

  <script>
    // hljs.initHighlightingOnLoad()
    // hljs.highlightAll();
    document.addEventListener('DOMContentLoaded', () => {
      hljs.highlightAll();
    });
    let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

    // This should probably be throttled.
    // Especially because it triggers during smooth scrolling.
    // https://lodash.com/docs/4.17.10#throttle
    // You could do like...
    // window.addEventListener("scroll", () => {
    //    _.throttle(doThatStuff, 100);
    // });
    // Only not doing it here to keep this Pen dependency-free.

    window.addEventListener("scroll", event => {
      let fromTop = window.scrollY;

      mainNavLinks.forEach((link, index) => {
        let section = document.getElementById(decodeURI(link.hash).substring(1));
        let nextSection = null
        if (mainNavLinks[index + 1]) {
          nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
        }
        if (section.offsetTop <= fromTop) {
          if (nextSection) {
            if (nextSection.offsetTop > fromTop) {
              link.classList.add("current");
            } else {
              link.classList.remove("current");
            }
          } else {
            link.classList.add("current");
          }
        } else {
          link.classList.remove("current");
        }
      });
    });
  </script>
</body>

</html>