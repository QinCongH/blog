{"themeConfig":{"themeName":"notes","postPageSize":10,"archivesPageSize":50,"siteName":"禾耳","siteDescription":"逆风的方向，更适合飞翔。","footerInfo":"Powered by <a href=\"https://github.com/getgridea/gridea\" target=\"_blank\">Gridea</a>","showFeatureImage":false,"domain":"https://qin_hu.gitee.io/blog/","postUrlFormat":"SLUG","tagUrlFormat":"SHORT_ID","dateFormat":"YYYY-MM-DD","feedFullText":true,"feedCount":10,"archivesPath":"archives","postPath":"post","tagPath":"tag"},"posts":[{"content":"1. 安装 git clone -b v3 https://github.com/nuxt/starter.git nuxt3-app 2. 目录结构 https://nuxt.com.cn/docs/guide/directory-structure 3. 新建路由 1. 新建页面 在项目目录新建pages文件夹, pages文件夹中新建页面。 例如要创建首页路由/, 我们可以在pages路由中创建 /index/index.vue 路由 目录 / /index/index.vue /about /about/index.vue 2. 入口文件中显示页面 在pages目录下创建页面路由文件，然后在入口文件App.vue中使用 &lt;NuxtPage /&gt;组件显示页面 App.vue &lt;template&gt; &lt;div&gt; &lt;!-- &lt;NuxtWelcome /&gt; --&gt; &lt;NuxtPage /&gt; &lt;/div&gt; &lt;/template&gt; 4. 布局 1. 使用NuxtLayout启动布局 name: 指定要渲染的布局名称，可以是字符串、响应式引用或计算属性。它必须与 layouts/ 目录中相应布局文件的名称匹配。 App.vue &lt;script setup lang=&quot;ts&quot;&gt; // layouts/custom.vue const layout = 'custom' &lt;/script&gt; &lt;template&gt; &lt;NuxtLayout :name=&quot;layout&quot;&gt; &lt;NuxtPage /&gt; &lt;/NuxtLayout&gt; &lt;/template&gt; 2. 页面中需要指定布局 pages/index/index.vue &lt;script setup lang=&quot;ts&quot;&gt; definePageMeta({ layout: 'layout' }) &lt;/script&gt; 5. css /assets/css/style.less ： 自定义全局css样式 /assets/css/media.less ： 响应式css样式 main.css : css入口文件 @import url('~/assets/css/style.less'); @import url('~/assets/css/media.less'); 6. utils https://nuxt.com.cn/docs/guide/directory-structure/utils 方法1： 使用命名导出 utils/index.ts export const { format: formatNumber } = Intl.NumberFormat('en-GB', { notation: 'compact', maximumFractionDigits: 1 }) 方法2： 使用默认导出 utils/random-entry.ts 或 utils/randomEntry.ts // 它将作为randomEntry()可用（文件名的驼峰形式，不包括扩展名） export default function (arr: Array&lt;any&gt;) { return arr[Math.floor(Math.random() * arr.length)] } 使用 现在你可以在.js、.ts和.vue文件中使用自动导入的工具函数了。 app.vue &lt;template&gt; &lt;p&gt;{{ formatNumber(1234) }}&lt;/p&gt; &lt;/template&gt; 7. 静态图片 图片保存在&quot;~/assets/images/&quot;目录下。 使用images['图片名称']引入图片。 &lt;template&gt; &lt;img :src=&quot;images['close']&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt; &lt;/template&gt; &lt;script setup lang=&quot;ts&quot;&gt; definePageMeta({ layout: &quot;layout&quot;, }); &lt;/script&gt; 参考链接 https://nuxt.com.cn/docs/guide ","tags":[],"title":"【nuxt】开发指南","feature":"","link":"https://qin_hu.gitee.io/blog/post/nuxt-kai-fa-zhi-nan/","stats":{"text":"3 min read","time":153000,"words":530,"minutes":3},"date":"2024-04-23 13:11:40","dateFormat":"2024-04-23"},{"content":"安装 1. 下载leaflet npm i leaflet 2. 入口文件引入leafletJs的样式 import &quot;leaflet/dist/leaflet.css&quot;; 使用 1. 封装组件 基于vue封装的一个基础展示地图的组件 ：LeafletMap.vue &lt;script setup lang=&quot;ts&quot;&gt; import { ref, onMounted } from &quot;vue&quot;; import L from &quot;leaflet&quot;; interface Props { isGetLocation: boolean; width?: string; height?: string; latitude?: number; longitude?: number; } const props = withDefaults(defineProps&lt;Props&gt;(), { isGetLocation: false, width: &quot;100vw&quot;, height: &quot;100vh&quot;, latitude: 0, longitude: 0, }); onMounted(async () =&gt; { if (props.latitude &amp;&amp; props.longitude) { loadMap({ latitude: props.latitude, longitude: props.longitude, }); return; } if (props.isGetLocation) { const res = await getPostion(); if (res.coords) { loadMap({ latitude: res.coords.latitude, longitude: res.coords.longitude, }); return; } } loadMap({}); }); function getPostion() { return new Promise((res, rej) =&gt; { if (&quot;geolocation&quot; in navigator) { /* geolocation 存在 */ function success(position) { res(position); } function error() { rej(&quot;Sorry, no position available.&quot;); alert(&quot;Sorry, no position available.&quot;); } const options = { enableHighAccuracy: true, // maximumAge: 30000, // timeout: 27000, }; const watchID = navigator.geolocation.watchPosition( success, error, options, ); } else { return 0; /* geolocation 不存在 */ } }); } function loadMap({ latitude, longitude }) { // 创建实例 var map = L.map(&quot;map&quot;).setView([latitude || 0, longitude || 0], 13); // 获取地图片 L.tileLayer(&quot;http://{s}.tile.osm.org/{z}/{x}/{y}.png&quot;).addTo(map); // 显示定位图表 L.marker([latitude || 0, longitude || 0]) .addTo(map) // .bindPopup(&quot;marker&quot;) .openPopup(); } &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;div :style=&quot;{ width: width, height: height }&quot; id=&quot;map&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 支持传经纬度，通过获取定位显示位置。 2. 使用组件 &lt;leaflet-map isGetLocation width=&quot;100vw&quot; height=&quot;100vh&quot; &gt; &lt;/leaflet-map&gt; ","tags":[{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"}],"title":"【leafletJs】基本使用","feature":"","link":"https://qin_hu.gitee.io/blog/post/leafletjs-ji-ben-shi-yong/","stats":{"text":"2 min read","time":115000,"words":344,"minutes":2},"date":"2024-04-16 17:36:50","dateFormat":"2024-04-16"},{"content":"1. 使用meta标签和语义化的代码 &lt;head&gt; &lt;meta name=&quot;description&quot; content=&quot;网站名称&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;网站名称，网站,名称&quot;&gt; &lt;meta name=&quot;anthor&quot; content=&quot;禾耳&quot;&gt; &lt;meta name=&quot;robots&quot; content=&quot;网站名称，网站,名称&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;网站名称，网站,名称&quot;&gt; &lt;meta name=&quot;application-name&quot; content=&quot;网站名称，网站,名称&quot;&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=yes&quot;&gt; &lt;title&gt;网站名称，网站,名称&lt;/title&gt; &lt;/head&gt; 2. 使用SSR服务端渲染（ Server-Side Rendering） 3. 预渲染prerender-spa-plugin 使用 prerender-spa-plugin 插件来实现预渲染页面，在构建时就针对特定的路有生成静态的 html 文件 参考链接 ","tags":[],"title":"seo优化","feature":"","link":"https://qin_hu.gitee.io/blog/post/seo-you-hua/","stats":{"text":"1 min read","time":59000,"words":207,"minutes":1},"date":"2024-04-16 11:55:19","dateFormat":"2024-04-16"},{"content":"1. [Vue warn]: Property &quot;showHandle&quot; was accessed during render but is not defined on instance. [VUE WARN]：在呈现期间访问了属性，但未在实例上定义该属性。 原因 :模板中使用到了响应式变量，但是未定义这个响应式变量 &lt;template v-if=&quot;showHandle&quot;&gt; &lt;/template&gt; 解决方案:声明这个变量 const showHandle=ref(false) 在没有声明变量，事件等情况使用到都会报这个提醒错误。 2. [Vue warn]: Missing required prop: &quot;modelVlaue&quot; [VUE WARN]：缺少必需的道具：“ModelValue” 原因：自定义组件中设置了必填prop 解决方案：将model设置为非必填或者在组件使用 时正确传入prop属性 interface Props { modelVlaue?: boolean; } // 或者 &lt;component v-model=&quot;value&quot; /&gt; 3. [Vue warn] Write operation failed: computed value is readonly [VUE WARN]写入操作失败：计算值为只读 原因：更改了计算属性值。 我出现这个错误原因主要是自定义组件中使用第三方组件响应式变量绑定的计算属性。 应该不使用受控的双向绑定，而是使用model-value替代v-model &lt;script setup lang=&quot;ts&quot;&gt; import { computed } from &quot;vue&quot;; interface Props { modelVlaue?: boolean; } const props = withDefaults(defineProps&lt;Props&gt;(), { modelVlaue: false, }); const emit = defineEmits([&quot;update:modelValue&quot;, &quot;cancel&quot;, &quot;confirm&quot;]); const dialogVisible = computed(() =&gt; { return props.modelVlaue; }); const cancel = () =&gt; { emit(&quot;update:modelValue&quot;, false); emit(&quot;cancel&quot;, false); }; &lt;/script&gt; &lt;template&gt; &lt;!-- (X)错误写法:使用了v-model 绑定了计算属性 &lt;el-drawer :show-close=&quot;false&quot; @close=&quot;cancel&quot; v-model=&quot;dialogVisible&quot; :model-value=&quot;dialogVisible&quot; &gt; &lt;/el-drawer&gt; --&gt; &lt;!-- (V) --&gt; &lt;el-drawer :show-close=&quot;false&quot; @close=&quot;cancel&quot; :model-value=&quot;dialogVisible&quot; &gt; &lt;/el-drawer&gt; &lt;/template&gt; ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"}],"title":"vue常见提醒报错","feature":"","link":"https://qin_hu.gitee.io/blog/post/vue-chang-jian-ti-xing-bao-cuo/","stats":{"text":"2 min read","time":119000,"words":422,"minutes":2},"date":"2024-04-11 12:40:43","dateFormat":"2024-04-11"},{"content":"docker 执行一下命令，安装最新版本的 Docker Engine-Community 和 containerd。 sudo yum install -y docker-ce docker-ce-cli containerd.io docker-ce为社区免费版本。稍等片刻，docker即可安装成功。但安装完成之后的默认是未启动的，需要进行启动操作。 判断docker是否安装成功 docker -v 设置开机自启动 systemctl enable docker docker-compose sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose # 比较新的版本2.23.0 # sudo curl -L &quot;https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker-compose --version #查看 docker-compose 版本 Docker启动 启动Docker的命令： sudo systemctl start docker 通过运行hello-world镜像来验证是否正确安装了Docker Engine-Community。 // 拉取镜像 sudo docker pull hello-world // 执行hello-world sudo docker run hello-world 如果执行之后，控制台显示如下信息，则说明Docker安装和启动成功： [root@iZ8vb8pfb2awsz4qy7vm7qZ ~]# docker run hello-world Hello from Docker! This message shows that your installation appears to be working correctly. …… 除了启动Docker，一些其他启动相关的命令： 守护进程重启：systemctl daemon-reload 重启Docker服务：systemctl restart docker / service docker restart 关闭Docker服务：docker service docker stop / docker systemctl stop docker 删除Docker 删除安装包： yum remove docker-ce 删除镜像、容器、配置文件等内容： rm -rf /var/lib/docker Docker其他常见命令 安装完成Docker之后，这里汇总列一下常见的Docker操作命令： 搜索仓库镜像：docker search 镜像名 拉取镜像：docker pull 镜像名 查看正在运行的容器：docker ps 查看所有容器：docker ps -a 删除容器：docker rm container_id 查看镜像：docker images 删除镜像：docker rmi image_id 启动（停止的）容器：docker start 容器ID 停止容器：docker stop 容器ID 重启容器：docker restart 容器ID 启动（新）容器：docker run -it ubuntu /bin/bash 进入容器：docker attach 容器ID或docker exec -it 容器ID /bin/bash，推荐使用后者。 ","tags":[{"index":13,"name":"部署与测试运维","slug":"NBjDaStCA","used":true,"link":"https://qin_hu.gitee.io/blog/tag/NBjDaStCA/"}],"title":"Linux安装docker/docker-compose","feature":"","link":"https://qin_hu.gitee.io/blog/post/linux-an-zhuang-dockerdocker-compose/","stats":{"text":"3 min read","time":138000,"words":505,"minutes":3},"date":"2024-03-22 18:47:59","dateFormat":"2024-03-22"},{"content":"学习文档 https://www.cnblogs.com/zhinian-/p/12575441.html 1. HelloWorld 1-1， 没有子节点时插入标签 select选择标签，selectAll选择标签下的子集，append插入节点，text插入文本 &lt;script setup lang=&quot;ts&quot;&gt; import { ref, onMounted } from &quot;vue&quot;; import { select, selectAll } from &quot;d3&quot;; onMounted(() =&gt; { select(&quot;.main&quot;).append(&quot;p&quot;).text(&quot;hello world&quot;); }); defineProps&lt;{ msg: string }&gt;(); &lt;/script&gt; &lt;template&gt; &lt;div class=&quot;main&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 1-2. 有子节点时插入标签 &lt;script setup lang=&quot;ts&quot;&gt; import { ref, onMounted } from &quot;vue&quot;; import { select, selectAll } from &quot;d3&quot;; onMounted(() =&gt; { select(&quot;.main&quot;).selectAll(&quot;p&quot;).text(&quot;hello world&quot;); }); defineProps&lt;{ msg: string }&gt;(); &lt;/script&gt; &lt;template&gt; &lt;div class=&quot;main&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; d3.select()：是选择所有指定元素的第一个 d3.selectAll()：是选择指定元素的全部 2. 绑定数据 2-1. datum 将数据重复绑定到节点。 先选中节点，在使用datum绑定到api节点 &lt;script setup lang=&quot;ts&quot;&gt; import { ref, onMounted } from &quot;vue&quot;; import { select, selectAll } from &quot;d3&quot;; /** * 2. 绑定数据 */ // 2-1. datum 将数据重复绑定到节点 let str = `hello world`; onMounted(() =&gt; { select(&quot;.main&quot;) .selectAll(&quot;p&quot;) .datum(str) .text((d, i) =&gt; { return `第${i}个元素,${d}`; }); }); defineProps&lt;{ msg: string }&gt;(); &lt;/script&gt; &lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 2-2. data 将数据集合分别绑定到节点 &lt;script setup lang=&quot;ts&quot;&gt; import { ref, onMounted } from &quot;vue&quot;; import { select, selectAll } from &quot;d3&quot;; /** * 2. 绑定数据 */ // 2-2.data 将数据集合分别绑定到节点 const data = [1, 2, 3, 4]; onMounted(() =&gt; { select(&quot;.main&quot;) .selectAll(&quot;p&quot;) .data(data) .text((d, i) =&gt; { return `第${i}个元素,${d}`; }); }); defineProps&lt;{ msg: string }&gt;(); &lt;/script&gt; &lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; text方法循环遍历： // d代表值，i代表索引 text((d, i) =&gt; { return `第${i}个元素,${d}`; }); 3. 插入元素 append向后插入元素 insert向前插入元素 &lt;script setup lang=&quot;ts&quot;&gt; import { ref, onMounted } from &quot;vue&quot;; import { select, selectAll } from &quot;d3&quot;; /** * 3. 插入元素 */ // 3-1. append onMounted(() =&gt; { select(&quot;.main&quot;).append(&quot;span&quot;).text(&quot;往后插入元素&quot;); }); // 3-2.insert onMounted(() =&gt; { select(&quot;.main&quot;).insert(&quot;span&quot;).text(&quot;往前插入元素&quot;); }); defineProps&lt;{ msg: string }&gt;(); &lt;/script&gt; &lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 4. 删除节点 remove() &lt;script setup lang=&quot;ts&quot;&gt; import { ref, onMounted } from &quot;vue&quot;; import { select, selectAll } from &quot;d3&quot;; /** * 4. 删除元素 */ function del() { select(&quot;.isme&quot;).remove(); } defineProps&lt;{ msg: string }&gt;(); &lt;/script&gt; &lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;button @click=&quot;del&quot;&gt;删除p节点1&lt;/button&gt; &lt;p class=&quot;isme&quot;&gt;1&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;p&gt;5&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 5. 元素与数据数量对应的标记回调 5-1. 默认情况 &lt;script setup lang=&quot;ts&quot;&gt; import { ref, onMounted } from &quot;vue&quot;; import { select, selectAll } from &quot;d3&quot;; /** * @desc 元素与数据数量对应的标记回调 */ // 1. 默认情况 绑定数据数量=对应数量 onMounted(() =&gt; { let data = [1, 2, 3, 4]; selectAll(&quot;p&quot;) .data(data) .text((d, i) =&gt; { return `第${i}个元素,${d}`; }) }); &lt;/script&gt; &lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;p class=&quot;isme&quot;&gt;1&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;p&gt;5&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 5-2. enter 绑定数据数量&gt;对应数量 &lt;script setup lang=&quot;ts&quot;&gt; import { ref, onMounted } from &quot;vue&quot;; import { select, selectAll } from &quot;d3&quot;; /** * @desc 元素与数据数量对应的标记回调 */ // 1. 默认情况 绑定数据数量=对应数量 onMounted(() =&gt; { let data = [1, 2, 3, 4, 5]; select(&quot;.main&quot;) .selectAll(&quot;p&quot;) .data(data) .text((d, i) =&gt; { return `第${i}个元素,${d}`; }) .enter() // 处理多余数据 .append(&quot;p&quot;) .text((d, i) =&gt; { console.info(d); return d; }); }); &lt;/script&gt; &lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;p class=&quot;isme&quot;&gt;1&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;p&gt;5&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 5-3. exit() 当对应的元素过多时 （ 绑定数据数量 &lt; 对应元素 ） &lt;script setup lang=&quot;ts&quot;&gt; import { ref, onMounted } from &quot;vue&quot;; import { select, selectAll } from &quot;d3&quot;; /** * @desc 元素与数据数量对应的标记回调 */ // 3. exit 绑定数据数量 &lt; 对应元素 onMounted(() =&gt; { let data = [1, 2, 3]; select(&quot;.main&quot;) .selectAll(&quot;p&quot;) .data(data) .text((d, i) =&gt; { return `第${i}个元素,${d}`; }) .exit() // 处理多余元素 .remove(); }); &lt;/script&gt; &lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;p class=&quot;isme&quot;&gt;1&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;p&gt;5&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 6. 画图 先了解一下svg标签组成 直角坐标系原点在网页窗口左上角，水平向右是x轴正轴，垂直向下是y轴正轴。 6-1. 矩形（rect） onMounted(() =&gt; { const svg = select(&quot;svg&quot;); svg // 设置画布宽高 .attr(&quot;width&quot;, 500) .attr(&quot;height&quot;, 500) // 设置矩形 .append(&quot;rect&quot;) .attr(&quot;width&quot;, 100) .attr(&quot;height&quot;, 100) // 位置 .attr(&quot;x&quot;, 0) .attr(&quot;y&quot;, 0) .attr(&quot;fill&quot;, &quot;blue&quot;); }); 6-2. 画一个圆(circle) onMounted(() =&gt; { const data = [1, 2, 3]; select(&quot;.main&quot;) .selectAll(&quot;svg&quot;) .attr(&quot;width&quot;, 500) .attr(&quot;height&quot;, 500) .append(&quot;circle&quot;) .attr(&quot;cx&quot;, 100) .attr(&quot;cy&quot;, 100) .attr(&quot;r&quot;, 50) .attr(&quot;fill&quot;, &quot;red&quot;) .text(&quot;nihaa&quot;) .color(&quot;red&quot;); }); 6-3. 画一个三角形 (polygon) onMounted(() =&gt; { // 创建 SVG 元素 var svg = select(&quot;.main&quot;) .selectAll(&quot;svg&quot;) .attr(&quot;width&quot;, 200) .attr(&quot;height&quot;, 200); // 定义三角形a,b,c三个顶点的坐标 var points = &quot;20,20 20,100 120,100&quot;; // 绘制三角形 使用polygon多边形 svg .append(&quot;polygon&quot;) .attr(&quot;points&quot;, points) .style(&quot;fill&quot;, &quot;yellow&quot;) .style(&quot;stroke&quot;, &quot;red&quot;); }); 6-4. 画一个线(line) onMounted(() =&gt; { select(&quot;.main&quot;) .selectAll(&quot;svg&quot;) .attr(&quot;width&quot;, 200) .attr(&quot;height&quot;, 200) // 直线 .append(&quot;line&quot;) .attr(&quot;x1&quot;, 50) .attr(&quot;y1&quot;, 50) .attr(&quot;x2&quot;, 120) .attr(&quot;y2&quot;, 120) .attr(&quot;stroke&quot;, &quot;red&quot;) .attr(&quot;stroke-width&quot;, 1); }); 6. 拖拽 /** * @desc 元素实现拖拽 = 适合单个元素拖拽 */ elementDrag({ element, key, onDragStart, onDragEnd, onDrag }) { let currentSvg = null; if (element) { currentSvg = element } else { currentSvg = d3.select(`[key=${key}]`) } const dragBehavior = d3.drag() .on(&quot;start&quot;, function (event) { const x = event.x; const y = event.y; currentSvg.attr(&quot;x&quot;, x); currentSvg.attr(&quot;y&quot;, y); onDragStart(event) // console.log(&quot;拖拽开始&quot;, event); }) .on(&quot;drag&quot;, (event) =&gt; { // 根据拖拽的行为更新矩形的位置 onDrag(event) let x = event.x; let y = event.y; console.info(event.x, event.y) // currentSvg.attr(&quot;x&quot;, x); // currentSvg.attr(&quot;y&quot;, y); // 限制矩形不超出SVG画布边界 const svgWidth = Number(this.svg.attr('width')); const svgHeight = Number(this.svg.attr('height')); const ractWidth = Number(currentSvg.attr('height')); const ractHeight = Number(currentSvg.attr('height')); x = Math.min(Math.max(x, 0), svgWidth - ractWidth); y = Math.min(Math.max(y, 0), svgHeight - ractHeight); currentSvg.attr(&quot;x&quot;, x); currentSvg.attr(&quot;y&quot;, y); currentSvg.transition() .duration(500) }) .on(&quot;end&quot;, function (event) { onDragEnd(event) console.log(&quot;拖拽结束&quot;, event); currentSvg.attr(&quot;x&quot;, event.x); currentSvg.attr(&quot;y&quot;, event.y); }) // 应用拖拽行为到矩形 currentSvg.call(dragBehavior); } /** * @desc 获取拖拽实例 用于多个拖拽时处罚 * */ getDragBehavior({ onDragStart, onDragEnd, onDrag }) { const that=this; return d3.drag() .on(&quot;start&quot;, function (event, d) { onDragStart(event) d3.select(this).raise().classed(&quot;active&quot;, true); }) .on(&quot;drag&quot;, function (event, d) { // 计算新位置 d.x = parseFloat(d.x) + event.dx; d.y = parseFloat(d.y) + event.dy; console.info('MyD3.svg',that.svg) // 限制矩形不超出SVG画布边界 const svgWidth = Number(that.svg.attr('width')); const svgHeight = Number(that.svg.attr('height')); const ractWidth = d.width; const ractHeight = d.height; d.x = Math.min(Math.max(d.x, 0), svgWidth - ractWidth); d.y = Math.min(Math.max(d.y , 0), svgHeight - ractHeight); // 更新位置 d3.select(this) .attr(&quot;x&quot;, d.x) .attr(&quot;y&quot;, d.y); onDrag(event) }) .on(&quot;end&quot;, function (event, d) { onDragEnd(event) d3.select(this).classed(&quot;active&quot;, false); }) } 7. 力导向图 d3.forceSimulation是D3.js中用于创建和控制力导向图的函数。它通过模拟物理力的作用（如引力、斥力等）来对节点进行布局。这里是一些基本的参数和概念介绍： 创建力模拟 当你创建一个力模拟时，可以传递一个节点数组给d3.forceSimulation(nodes)，其中nodes是包含节点数据的数组。每个节点至少包含节点的唯一标识符。 var simulation = d3.forceSimulation(nodes); 力 力模拟中的“力”用于定义节点如何相互作用。D3提供了多种内置力的类型，每种力都有其特定的参数和作用。 d3.forceLink(links)：根据链接数组创建链接力，用于连接节点。可以设置链接的距离和强度。 d3.forceManyBody()：创建多体力，用于模拟节点之间的引力或斥力。 d3.forceCenter(x, y)：创建一个力，将节点向指定的中心点(x, y)吸引。 d3.forceCollide([radius])：创建一个碰撞力，防止节点重叠，可以指定碰撞半径。 力的参数 每种力都有其特定的参数，可以通过链式调用的方式设置。例如，为链接力设置距离： simulation.force(&quot;link&quot;, d3.forceLink(links).distance(50)); 节点和链接的数据结构 节点（nodes）：通常是一个对象数组，每个对象代表图中的一个节点。节点对象可以包含任意属性，但是力模拟会添加一些特定的属性，如x、y（节点的当前位置）、vx、vy（节点的当前速度）等。 链接（links）：表示节点之间的连接，通常也是一个对象数组。每个对象代表一个链接，至少包含source和target属性，这些属性指向节点数组中的节点或节点的索引。 更新和控制模拟 力模拟提供了控制其行为的方法，如simulation.alpha(target)用于设置模拟的冷却参数，simulation.restart()用于重启模拟等。 事件监听 可以监听力模拟的事件，如tick事件，在每个模拟步骤时执行特定的操作，通常用于更新节点和链接的位置。 simulation.on(&quot;tick&quot;, function() { // 更新节点和链接的位置 }); 通过组合不同的力和调整它们的参数，你可以创建复杂且动态的力导向图表现。 8. d3Js的一些技巧 1. 力导向图元素定位技巧 监听拖拽 监听力方法 创建时的更新位置 ","tags":[{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"}],"title":"【d3Js】基本使用","feature":"","link":"https://qin_hu.gitee.io/blog/post/d3js-ji-ben-shi-yong/","stats":{"text":"14 min read","time":818000,"words":2708,"minutes":14},"date":"2024-03-05 15:14:08","dateFormat":"2024-03-05"},{"content":"nvm安装文档 下载 windows https://github.com/coreybutler/nvm-windows/releases 下载node nvm install 18.8.0 使用指定版本 nvm use 18.8.0 列出已安装的实例 nvm ls 安装最新的node nvm install node 查看nvm目录 nvm root ","tags":[{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"nvm的使用","feature":"","link":"https://qin_hu.gitee.io/blog/post/nvm-de-shi-yong/","stats":{"text":"1 min read","time":17000,"words":60,"minutes":1},"date":"2024-02-22 10:00:37","dateFormat":"2024-02-22"},{"content":"插件 1. ant-g6 https://antv-g6.gitee.io/zh/examples/gallery 2. highcharts https://www.highcharts.com/demo 3. D3 https://observablehq.com/@d3/gallery?utm_source=d3js-org&amp;utm_medium=nav&amp;utm_campaign=try-observable 实现可视化项目方案： 确定是否是大屏（新增入口显示可行性方），设计一个可视化主题，通过可视化插件实现组件部分。 常见的可视化主题： 嵌入中后台管理边栏显示 顶部 swiper 全局概况 数据详情显示 ","tags":[{"index":-1,"name":"Html&Css","slug":"18jtBTPqK","used":true,"link":"https://qin_hu.gitee.io/blog/tag/18jtBTPqK/"}],"title":"前端可视化插件方案","feature":"","link":"https://qin_hu.gitee.io/blog/post/qian-duan-ke-shi-hua-cha-jian-fang-an/","stats":{"text":"1 min read","time":29000,"words":117,"minutes":1},"date":"2024-02-17 21:31:33","dateFormat":"2024-02-17"},{"content":"js function sortable(section, onUpdate) { if(!props.list?.length){ return } var dragEl, nextEl, newPos, dragGhost; let oldPos = [...section.children].map(item =&gt; { item.draggable = true let pos = document.getElementById(item.id).getBoundingClientRect(); return pos; }); function _onDragOver(e) { console.info('start ', e) // debugger e.preventDefault(); e.dataTransfer.dropEffect = 'move'; var target = e.target; if (target &amp;&amp; target !== dragEl &amp;&amp; target.nodeName == 'DIV') { if (target.classList.contains('inside')) { e.stopPropagation(); } else { //getBoundinClientRect contains location-info about the element (relative to the viewport) var targetPos = target.getBoundingClientRect(); //checking that dragEl is dragged over half the target y-axis or x-axis. (therefor the .5) var next = (e.clientY - targetPos.top) / (targetPos.bottom - targetPos.top) &gt; .5 || (e.clientX - targetPos.left) / (targetPos.right - targetPos.left) &gt; .5; section.insertBefore(dragEl, next &amp;&amp; target.nextSibling || target); /* console.log(&quot;oldPos:&quot; + JSON.stringify(oldPos)); console.log(&quot;newPos:&quot; + JSON.stringify(newPos)); */ /* console.log(newPos.top === oldPos.top ? 'They are the same' : 'Not the same'); */ console.log(oldPos); } } } function _onDragEnd(evt) { console.info(evt) // debugger evt.preventDefault(); newPos = [...section.children].map(child =&gt; { let pos = document.getElementById(child.id).getBoundingClientRect(); return pos; }); let curList= [...section.children].map(child =&gt; { let pos = document.getElementById(child.id); return pos.id; }); emit('select',curList) dragEl.classList.remove('ghost'); section.removeEventListener('dragover', _onDragOver, false); section.removeEventListener('dragend', _onDragEnd, false); nextEl !== dragEl.nextSibling ? onUpdate(dragEl) : false; } section.addEventListener('dragstart', function (e) { dragEl = e.target; nextEl = dragEl.nextSibling; /* dragGhost = dragEl.cloneNode(true); dragGhost.classList.add('hidden-drag-ghost'); */ /* document.body.appendChild(dragGhost); e.dataTransfer.setDragImage(dragGhost, 0, 0); */ e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('Text', dragEl.textContent); section.addEventListener('dragover', _onDragOver, false); section.addEventListener('dragend', _onDragEnd, false); setTimeout(function () { dragEl.classList.add('ghost'); }, 0) }); } html &lt;section id=&quot;list&quot;&gt; &lt;div :id='item.id' class='divRec' v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot;&gt; &lt;div @click=&quot;start&quot; class='inside'&gt;{{ item.value }}&lt;/div&gt; &lt;/div&gt; &lt;/section&gt; css [draggable] { -moz-user-select: none; -khtml-user-select: none; -webkit-user-select: none; user-select: none; /* Required to make elements draggable in old WebKit */ -khtml-user-drag: element; -webkit-user-drag: element; } section { margin: 0; padding: 0; list-style: none; -webkit-user-select: none; -moz-user-select: none; user-select: none; // display: grid; // grid-gap: 15px; // grid-auto-flow: row dense; max-height: 600px; overflow-y: scroll; } .inside { background-color:var(--el-color-primary-light-3); } .divRec { cursor: move; font-size: 20px; background-color: var(--el-color-primary-light-3); margin-bottom: 10px; padding: 12px 9px; grid-area: span 1/span 2; color: #fff; border-radius: 5px; } .divQuad { cursor: move; padding: 35px 20px; font-size: 20px; background-color: #fff333; grid-area: span 1/span 1; } .divCard { cursor: move; padding: 35px 20px; font-size: 20px; background-color: #00ff00; grid-area: span 2/span 1; } .ghost { border: 1px dashed #000; // background-color: #fff; } .custom-drag-ghost { /* The original cloned element must not take place up in the page and must not be visible */ position: absolute; top: -99999px; left: -99999px; /* Just for appearance */ background-color: #edb458; border: 1px solid #e8871e; } .hidden-drag-ghost { opacity: 0; } .transition { transition: all 2s ease-out .5s; top: 0; } ","tags":[{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"},{"index":-1,"name":"Html&Css","slug":"18jtBTPqK","used":true,"link":"https://qin_hu.gitee.io/blog/tag/18jtBTPqK/"}],"title":"实现拖拽排序list","feature":"","link":"https://qin_hu.gitee.io/blog/post/shi-xian-tuo-zhuai-pai-xu-list/","stats":{"text":"4 min read","time":201000,"words":538,"minutes":4},"date":"2024-02-01 17:03:41","dateFormat":"2024-02-01"},{"content":"简介 数据库审计管理，是数据安全规范中不可或缺的一环，通过审计管理我们能够把控、追溯sql执行情况。 我们可以通过yearning来创建用户，设置权限，规定哪些用户可以查询哪个库，哪些用户可以修改哪个库，查询、修改操作需要经过那些人的审批后才能执行，执行完成的SQL修改语句可以进行回退，可以监控追溯到哪些人执行了哪些SQL。 新建一个数据库 使用navicat或者1Panel或者宝塔 安装 1. 下载安装包存储在linux系统文件夹 服务器文件系统opt目录下创建yearning文件夹 下载地址 https://github.com/cookieY/Yearning/releases 2. 压缩文件夹 cd /opt/yearning unzip Yearning-v3.1.1-linux-amd64.zip 得到Yearning文件夹 3. 修改配置 cd /opt/yearning vim conf.toml 在conf.toml文件中配置数据库 [Mysql] Db = &quot;Yearning&quot; Host = &quot;127.0.0.1&quot; Port = &quot;3306&quot; Password = &quot;&quot; User = &quot;root&quot; 4. 执行下载 ./Yearning install 5. 启动命令 1、使用默认8000端口启动 $ ./Yearning run 2、使用指定端口启动 ./Yearning run --push “you ip:you port” --port “your port” 3、放到后台运行 $ nohup ./Yearning run --push “you ip:you port” --port “your port” &gt;&gt; /var/log/yearning.log 2&gt;&amp;1 &amp; 官网下载 ","tags":[{"index":-1,"name":"数据库","slug":"SWTlIAzfL","used":true,"link":"https://qin_hu.gitee.io/blog/tag/SWTlIAzfL/"}],"title":"Yearning Guide - linux搭建数据库审计后台","feature":"","link":"https://qin_hu.gitee.io/blog/post/yearning-guide-linux-da-jian-shu-ju-ku-shen-ji-hou-tai/","stats":{"text":"2 min read","time":85000,"words":339,"minutes":2},"date":"2024-02-01 13:03:43","dateFormat":"2024-02-01"},{"content":"一般在前端项目中测试可以分为单元测试，集成测试和UI测试。 单元测试负责测试组件和函数，集成测试负责测试集成度较高的组件和函数，一般UI测试需要前端自己mock数据，以保证UI的正确显示。 有效检测问题的方案是使用单元测试，jest是单元测试常用到的插件。 思路：对方法输出验证结果的正确性。 安装 npm i --save-dev jest npm i --save-dev @types/jest 包管理文件中配置测试命令 package.json { &quot;name&quot;: &quot;jest-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;app.js&quot;, &quot;scripts&quot;: { // 添加测试命令 &quot;test&quot;: &quot;jest&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { &quot;@types/jest&quot;: &quot;^29.5.11&quot;, &quot;jest&quot;: &quot;^29.7.0&quot; } } 简单的测试demo 封装一个sum方法： function sum(a,b){ return a+b; } module.exports={ sum } 在同级目录添加test.spec.js文件，使用toBe方法精准测试： const {sum} =require('./index') test('测试1+1',()=&gt;{ expect(sum(1,1)).toBe(2) }) Jest使用“匹配器”的机制让你可以使用各种方法进行测试: 测试是否为真 toBeNull 只匹配 null toBeUndefined 只匹配 undefined toBeDefined 与 toBeUndefined 相反 toBeTruthy 匹配任何 if 语句为真 toBeFalsy 匹配任何 if 语句为假 测试数值用例 test('two plus two', () =&gt; { const value = 2 + 2; expect(value).toBeGreaterThan(3); expect(value).toBeGreaterThanOrEqual(3.5); expect(value).toBeLessThan(5); expect(value).toBeLessThanOrEqual(4.5); // toBe and toEqual are equivalent for numbers expect(value).toBe(4); expect(value).toEqual(4); }); 测试字符串 test('there is no I in team', () =&gt; { expect('team').not.toMatch(/I/); }); test('but there is a &quot;stop&quot; in Christoph', () =&gt; { expect('Christoph').toMatch(/stop/); }); 测试数组和可迭代的对象 const shoppingList = [ 'diapers', 'kleenex', 'trash bags', 'paper towels', 'milk', ]; test('shoppingList数组中包含milk', () =&gt; { expect(shoppingList).toContain('milk'); expect(new Set(shoppingList)).toContain('milk'); }); 测试函数是否抛出错误 function compileAndroidCode() { throw new Error('you are using the wrong JDK!'); } test('compiling android goes as expected', () =&gt; { expect(() =&gt; compileAndroidCode()).toThrow(); expect(() =&gt; compileAndroidCode()).toThrow(Error); // You can also use a string that must be contained in the error message or a regexp expect(() =&gt; compileAndroidCode()).toThrow('you are using the wrong JDK'); expect(() =&gt; compileAndroidCode()).toThrow(/JDK/); // Or you can match an exact error message using a regexp like below expect(() =&gt; compileAndroidCode()).toThrow(/^you are using the wrong JDK$/); // Test fails expect(() =&gt; compileAndroidCode()).toThrow(/^you are using the wrong JDK!$/); // Test pass }); 官方链接 ","tags":[{"index":13,"name":"部署与测试运维","slug":"NBjDaStCA","used":true,"link":"https://qin_hu.gitee.io/blog/tag/NBjDaStCA/"},{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"}],"title":"jest单元测试","feature":"","link":"https://qin_hu.gitee.io/blog/post/jest-dan-yuan-ce-shi/","stats":{"text":"3 min read","time":171000,"words":579,"minutes":3},"date":"2024-01-30 14:55:39","dateFormat":"2024-01-30"},{"content":"1. 安装Three.js与环境搭建 html文件中直接引入 像js库一样引入： &lt;!-- cdn链接 --&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/three.js/0.156.1/three.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.onload = () =&gt; { // 运行一下three.js的Api console.info(window.THREE.UnsignedByteType) } &lt;/script&gt; 或者通过es6的import模块引入 &lt;script type=&quot;module&quot;&gt; import &quot;https://cdn.bootcdn.net/ajax/libs/three.js/0.156.1/three.js&quot; // 运行一下three.js的Api console.info(window.THREE.UnsignedByteType) &lt;/script&gt; npm环境引入 安装 npm i three app.js import * as THREE from 'three'; console.info(THREE.UnsignedByteType) 注意package.json文件中要设置 &quot;type&quot;: &quot;module&quot; 2. 创建3D案例 思路： 初始设置 创建场景 创建相机 创建可见对象 创建渲染器 渲染场景 构成每个 three.js 应用程序的基本组件。首先是场景、相机和渲染器，它们构成了应用程序的基本脚手架。接下来是 HTML &lt;canvas&gt;元素，我们可以在其中看到结果。 创建3d小宇宙 (场景) - Scene import {Scene} from 'three'; const scene = new Scene(); 创建一个场景Scene将生成一个世界空间坐标系，世界空间是一个 3D 笛卡尔坐标系。场景的中心是点(0,0,0)，也称为坐标系的原点。每当我们创建一个新对象并将其添加到我们的场景中时，它将被放置在原点。 相机(指向小宇宙的望远镜) - PerspectiveCamera / OrthographicCamera 有两种相机，透视投影和正交投影。透视视图 ( Perspective View ) : 近大远小 , 符合正常人眼观察 3D 世界的规律 ;正交视图 ( Orthographic View ) : 又称为 &quot; 等距视图 &quot; , 在视图中 显示的 游戏物体 的大小 与 当前的视点距离无关 ; 摄像机的作用就是不断的拍摄我们创建好的场景，然后通过渲染器渲染到屏幕中。 import { PerspectiveCamera } from 'three'; const fov = 35; // 视场高度 const aspect = container.clientWidth / container.clientHeight; //宽高比 const near = 0.1; // the near clipping plane // 近裁面 const far = 100; // the far clipping plane // 远裁面 const camera = new PerspectiveCamera(fov, aspect, near, far); 创建可见的对象 - 网格 网格是 3D 计算机图形学中最常见的可见对象，用于显示各种 3D 对象 Mesh构造函数有两个参数：几何和材料。 import { Mesh } from 'three'; const mesh = new Mesh(geometry, material); 几何体定义了网格的形状 import { BoxBufferGeometry } from 'three'; const length = 2; //长度 const width = 2; //宽度 const depth = 2; //深度 const geometry = new BoxBufferGeometry(length, width, depth); 材料定义了网格表面的外观。 import { MeshBasicMaterial } from 'three'; const material = new MeshBasicMaterial(); 渲染器 渲染器就是一个艺术家，他通过望远镜观察并将他们看到的东西 非常快 的绘制到一个&lt;canvas&gt;中去。 我们把这个过程叫做渲染 import { WebGLRenderer } from 'three'; const renderer = new WebGLRenderer(); 正方体案例 正方体案例：demo.js import { Scene, Color, PerspectiveCamera, BoxGeometry, MeshBasicMaterial, Mesh, WebGLRenderer } from 'three' function createDemo() { const container = document.querySelector('.container') const clientWidth=container?container.clientWidth:0 const clientHeight=container?container.clientHeight:0 // 创建场景 const scene = new Scene(); scene.background = new Color(&quot;skyblue&quot;);// 设置场景背景颜色为黑色 // 创建网格 const geometry = new BoxGeometry(100, 100, 100); const material = new MeshBasicMaterial({// 给物体添加材质 color: 0x3cf438, }); const mesh = new Mesh(geometry, material);//网格模型对象Mesh mesh.position.set(0, 10, 0); // 设置位置 scene.add(mesh);// 将网格添加到场景中 // 创建相机 const camera = new PerspectiveCamera(30, clientWidth / clientHeight, 1, 3000);// 根据需要设置相机位置具体值 camera.position.set(200, 200, 200); camera.lookAt(mesh.position); //坐标原点 // 创建渲染器 const renderer = new WebGLRenderer(); renderer.setPixelRatio(window.devicePixelRatio); //设置像素比率，以适应高分辨率屏幕。 renderer.setSize(clientWidth, clientHeight); // 设置渲染器的大小为容器的大小 renderer.render(scene, camera); // 渲染 if(container){ container.appendChild(renderer.domElement); // 将渲染器的domElement添加到容器中 } } 3. 模块化设计 将应用程序拆分为多个小模块，每个模块处理复杂整体中的一小部分。保证在其他前端应用框架中直接使用。 思路：创建World类创建场景，网格和摄像机。定义两个模块，组件（components）和系统（systems）。组件是可以放置到场景中的任何东西，例如立方体、相机和场景本身；系统是在组件或其他系统上运行的东西，渲染器（renderer）和大小调整函数(Resizer )。 components/camera.js import { PerspectiveCamera } from 'three'; function createCamera() { const camera = new PerspectiveCamera( 30, // fov = Field Of View 1, // aspect ratio (dummy value) 1, // near clipping plane 3000, // far clipping plane ); // move the camera back so we can view the scene camera.position.set(200, 200, 200); return camera; } export { createCamera }; components/cube.js import { BoxGeometry, Mesh, MeshBasicMaterial } from 'three'; function createCube() { // create a geometry const geometry = new BoxGeometry(100, 100, 100); // create a default (white) Basic material const material = new MeshBasicMaterial({ // 给物体添加材质 color: 0x3cf438, }); // create a Mesh containing the geometry and material const cube = new Mesh(geometry, material); cube.position.set(0, 10, 0); // 设置位置 return cube; } export { createCube }; components/scene.js import { Color, Scene } from 'three'; function createScene() { const scene = new Scene(); scene.background = new Color('skyblue'); return scene; } export { createScene }; systems/renderer.js import { WebGLRenderer } from 'three'; function createRenderer() { const renderer = new WebGLRenderer(); return renderer; } export { createRenderer }; systems/Resizer.js class Resizer { constructor(container, camera, renderer) { // Set the camera's aspect ratio camera.aspect = container.clientWidth / container.clientHeight; // update the camera's frustum camera.updateProjectionMatrix(); // update the size of the renderer AND the canvas renderer.setSize(container.clientWidth, container.clientHeight); // set the pixel ratio (for mobile devices) renderer.setPixelRatio(window.devicePixelRatio); } } export { Resizer }; World.js import { createCamera } from './components/camera.js'; import { createCube } from './components/cube.js'; import { createScene } from './components/scene.js'; import { createRenderer } from './systems/renderer.js'; import { Resizer } from './systems/Resizer.js'; // These variables are module-scoped: we cannot access them // from outside the module let camera; let renderer; let scene; class World { constructor(container) { scene = createScene(); camera = createCamera(); renderer = createRenderer(); const cube = createCube(); new Resizer(container, camera, renderer); camera.lookAt(cube.position) scene.add(cube); container.append(renderer.domElement); } render() { // draw a single frame renderer.render(scene, camera); } } export { World }; 4. 基于物理的渲染和照明 three.js中的光照分为两种类型：直接光照和环境光 直接光照：直接来自灯泡并撞击物体的光线。 环境光：光线在击中物体之前已经从墙壁和房间内的其他物体反弹，每次反弹都会改变颜色并失去强度。 需要使用MeshStandardMaterial材料代替基本材料MeshBasicMaterial。这是一种高质量、通用、物理精确的材料，可以使用真实世界的物理方程对光做出反应。 基本示例： 在World/components的文件夹下面新增lights.js文件 import { DirectionalLight } from 'three'; function createLights() { // Create a directional light const light = new DirectionalLight('white', 10); // move the light right, up, and towards us light.position.set(10, 10, 10); return light; } export { createLights }; components/cube.js文件中将基本材料设置为MeshStandardMaterial材质 import { BoxGeometry, Mesh, MeshStandardMaterial } from 'three'; function createCube() { // create a geometry const geometry = new BoxGeometry(100, 100, 100); const material = new MeshStandardMaterial({ // 给物体添加材质 color: 0x213547, }); const cube = new Mesh(geometry, material); cube.position.set(0, 10, 0); // 设置位置 cube.rotation.set(100, -100, -10); return cube; } export { createCube }; 将光照添加到场景中 scene.add(light); 以上案例使用的是平行光： 平行光（DirectionalLight） 平行光是沿着特定方向发射的光。这种光的表现像是无限远，从它发出的光线都是平行的。常常用平行光来模拟太阳光的效果。 // 从上方照射的白色平行光，强度为 0.5。 const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 ); scene.add( directionalLight ); 光照详细文档 5. 变换、坐标系和场景图 场景图： 场景图中的每个对象（顶级场景除外）只有一个父对象，并且可以有任意数量的子对象。 Object3D 这是Three.js中大部分对象的基类，提供了一系列的属性和方法来对三维空间中的物体进行操纵。 将网格添加到场景中 scene.add(mesh); 调用.add方法添加到场景的对象都属于全局场景的子级 给对象添加name名称 const geometry = new BoxGeometry(100, 100, 100); // 基础线条材质（LineBasicMaterial） const material = new LineBasicMaterial( { color: 0xffffff, linewidth: 1, linecap: 'round', //ignored by WebGLRenderer linejoin: 'round' //ignored by WebGLRenderer } ); const mesh = new Mesh(geometry, material); mesh.name=&quot;长方体&quot; 获取场景中的所有对象 // 获取所有子对象 scene.children // 获取所有场景对象的名称 scene.children.map(item=&gt;item.name) 坐标系：全局坐标系和局部坐标系(对象空间，局部空间) 添加到场景中的每个对象也都有一个局部坐标系，这个局部坐标系有X、Y和Z轴，就像世界空间一样。 变换 当我们直接将一个对象添加到场景中，然后平移、旋转或缩放它时，该对象将相对于世界空间移动——即相对于场景的中心。 X轴是向左或向右移动，在Y轴是向上或向下移动，在Z轴是向内或向外移动。这些方向是相对于您的屏幕的，并假设您没有旋转相机。 平移 .position 设置相机的位置 camera.position.set(0, 0, 10); 设置光的位置 light.position.set(10, 10, 10); 设置物体的位置 cube.position.set(-0.5, -0.1, 0.8); 缩放 设置相机 camera.scale.set(1, 1, 1); 设置光 light.scale.set(1, 1, 1); 设置物体 cube.scale.set(1, 1, 1); 旋转 设置相机 camera.rotation.set(0, 0, 10); 设置光 light.rotation.set(10, 10, 10); 设置物体 cube.rotation.set(-0.5, -0.1, 0.8); 学习链接 three.js中文学习网 官网 《探索three.js》 ","tags":[{"index":-1,"name":"WEBGl&Webgis","slug":"G1LyZwTWb","used":true,"link":"https://qin_hu.gitee.io/blog/tag/G1LyZwTWb/"}],"title":"three.js","feature":"","link":"https://qin_hu.gitee.io/blog/post/threejs/","stats":{"text":"11 min read","time":606000,"words":2275,"minutes":11},"date":"2024-01-26 15:43:09","dateFormat":"2024-01-26"},{"content":"1/25 three.js开发 了解使用ai创作全过程 ","tags":[{"index":-1,"name":"清单","slug":"zAiIIHeCP","used":true,"link":"https://qin_hu.gitee.io/blog/tag/zAiIIHeCP/"}],"title":"学习清单","feature":"","link":"https://qin_hu.gitee.io/blog/post/xue-xi-qing-dan/","stats":{"text":"1 min read","time":4000,"words":16,"minutes":1},"date":"2024-01-25 17:40:27","dateFormat":"2024-01-25"},{"content":"1.介绍jsonp跨域 由于同源策略，这里用到动态创建script标签，使用script的src属性来获取数据的方法，实现跨域 2.步骤 动态创建script 2. script传值设置回调函数&amp;callback=test 3. 将script插入head标签内 4.在浏览器节点中调用test函数 5. 效果实现后删除创建的script标签 3.代码 一个搜索单词的案例来体验jsonp跨域 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- https://suggest.taobao.com/sug?code=utf-8&amp;q=%E5%85%8D%E8%B4%B9 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 官网提供的 axios 在线地址 --&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;inputVle&quot; @blur=&quot;servle&quot; placeholder=&quot;请输入内容&quot;&gt; &lt;button @click=&quot;servle&quot;&gt;搜索&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;value in vleList&quot;&gt;{{value[0]}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; var app = new Vue({ el: '#app', data: { inputVle: null, vleList:[], }, methods: { servle:function() { // 跨域 /* 1.动态创建script 2.script传值设置回调函数&amp;callback=test 3.将script插入head标签内 4.在浏览器节点中调用test函数 5.效果实现后删除创建的script标签 */ let script=document.createElement(&quot;script&quot;); script.src=&quot;https://suggest.taobao.com/sug?code=utf-8&amp;q=&quot;+this.inputVle+&quot;&amp;callback=test&quot;; let head=document.querySelector(&quot;head&quot;); head.appendChild(script); // 方法1需要存储this // that=this;//存this // window[&quot;test&quot;]=function(data){ // that.vleList=data.result; // console.log(that.vleList); // } is //方法2 使用箭头函数不需要存储this window[&quot;test&quot;]=(data)=&gt;{ this.vleList=data.result; console.log(this.vleList); } head.removeChild(script); //去除script } } }) &lt;/script&gt; &lt;/html&gt; ","tags":[{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"}],"title":"Ajax - jsonp解决跨域","feature":"","link":"https://qin_hu.gitee.io/blog/post/ajax-jsonp-jie-jue-kua-yu/","stats":{"text":"3 min read","time":154000,"words":494,"minutes":3},"date":"2024-01-25 10:51:26","dateFormat":"2024-01-25"},{"content":"1.介绍 axios Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中。 get &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;!--随机笑话https://autumnfish.cn/api/joke --&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;getjoke&quot;&gt;获取笑话&lt;/button&gt; &lt;p&gt; {{joke}} &lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; var app = new Vue({ el: &quot;#app&quot;, data: { joke: '' }, methods: { getjoke: function () { var that = this; //将this存到that中防止数据变化 // 方法1 //es6语法不需存储this // axios.get(&quot;https://autumnfish.cn/api/joke&quot;).then(response =&gt; ( // that.joke = response.data // )).catch(error =&gt; (console.log(error))); // 方法2 axios.get(&quot;https://autumnfish.cn/api/joke&quot;).then(function(response){ that.joke=response.data; },function(err){ console.log(err); }) } } }) &lt;/script&gt; &lt;/html&gt; post &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/vue/2.4.2/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/axios/0.18.0/axios.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; {{ info }} &lt;/div&gt; &lt;script type = &quot;text/javascript&quot;&gt; new Vue({ el: '#app', data () { return { info: null } }, mounted () { axios .post('https://www.runoob.com/try/ajax/demo_axios_post.php') .then(response =&gt; (this.info = response)) .catch(function (error) { // 请求失败处理 console.log(error); }); } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意点 使用 response.data 读取 JSON 数据： ","tags":[{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"}],"title":"Ajax - Axios简单使用","feature":"","link":"https://qin_hu.gitee.io/blog/post/ajax-axios-jian-dan-shi-yong/","stats":{"text":"3 min read","time":145000,"words":419,"minutes":3},"date":"2024-01-25 10:50:32","dateFormat":"2024-01-25"},{"content":"1.同步或者异步 例:xmlhttp.open(&quot;GET&quot;,&quot;ajax_test.html&quot;,true);中，其 open() 方法如果async=true则为异步 async=false则为同步。 1-1.当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数： xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/ajax_info.txt&quot;,true); xmlhttp.send(); xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; } } 1-2.当您使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可: 由于在同步请求中，当执行到send()语句时,readyState的状态值为4,故不需要回调函数 xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/ajax_info.txt&quot;,false); xmlhttp.send(); document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; ","tags":[{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"}],"title":"Ajax - 同步请求","feature":"","link":"https://qin_hu.gitee.io/blog/post/ajax-tong-bu-qing-qiu/","stats":{"text":"1 min read","time":51000,"words":183,"minutes":1},"date":"2024-01-25 10:49:20","dateFormat":"2024-01-25"},{"content":"1.使用场景 网页异步刷新。需要在不加载整个页面的情况下获取到后端数据。 2.案例准备 准备后端php文件与服务环境，使用get/post获取到html文件数据 准备html文件,创建一个输入框和一个按钮，给按钮添加点击事件函数，使点击按钮时通过ajax获取到后端文件 &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;button&quot; name=&quot;btn&quot; id=&quot;btn&quot; value=&quot;校验&quot; /&gt; 首先获取到input输入框数据 var username_value = document.getElementById('username').value; 3.四个步骤 3-1.创建XMLHttpRequest实例化对象,注意IE6的兼容处理 var xhr = null; if (window.XMLHttpRequest) { //如果电脑中有XMLHttpRequest对象 xhr = new XMLHttpRequest(); } else { // 电脑处于ie6浏览器状态 xhr = ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } 3-2.open 准备发送 3-2-1.如果是get方法发送 注意：a.php?username=&quot; + username_value中,username指输入框id名称，username_value指输入框的值 xhr.open(&quot;get&quot;, &quot;a.php?username=&quot; + username_value, true); 3-2-2.如果是post方法发送 xhr.open(&quot;post&quot;,&quot;a.php&quot;,true); var param=&quot;username=&quot;+username_value; xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//设置请求体信息,仅适用于post 3-3.send 执行发送 3-3-1.如果是get方法发送 xhr.send(null); 3-3-2.如果是post方法发送 xhr.send(param);//post请求参数在请求体中 3-4.回调函数 xhr.onreadystatechange = function() { // xhr.status服务器访问状态,xhr.readyState 数据解析 if (xhr.readyState == 4) { if (xhr.status == 200) { var result = xhr.responseText; wrong[0].innerHTML = result; } } } 4.代码 var username_value = document.getElementById('username').value;//username_value 按情况而定 // 1.创建XMLHttpRequest实例化对象,注意IE6的兼容处理 var xhr = null; if (window.XMLHttpRequest) { //如果电脑中有XMLHttpRequest对象 xhr = new XMLHttpRequest(); } else { // 电脑处于ie6浏览器状态 xhr = ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } // 2.open 准备发送// 3.send 执行发送 // (1)get方法得到数据时 // xhr.open(&quot;get&quot;, &quot;a.php?username=&quot; + username_value, true); // xhr.send(null); //(2) post方法得到数据时 xhr.open(&quot;post&quot;,&quot;a.php&quot;,true); var param=&quot;username=&quot;+username_value; xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//设置请求体信息,仅适用于post xhr.send(param);//post请求参数在请求体中 // 4.回调函数 xhr.onreadystatechange = function() { // xhr.status服务器访问状态,xhr.readyState 数据解析 if (xhr.readyState == 4) { if (xhr.status == 200) { var result = xhr.responseText; console.log(result); } } } ","tags":[{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"}],"title":"Ajax - 四个步骤","feature":"","link":"https://qin_hu.gitee.io/blog/post/ajax-si-ge-bu-zou/","stats":{"text":"3 min read","time":171000,"words":610,"minutes":3},"date":"2024-01-25 10:48:31","dateFormat":"2024-01-25"},{"content":"理解 将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端,此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP地址。 基本配置 server { listen 8888; #本地服务器 server_name localhost; location / { root html/dist; index index.html; try_files $uri $uri/ @router; } #将本地地址后缀是/api/的路径指向http://101.34.72.205:3001/的路径 location /api/ { rewrite ^/api/(.*) /$1 break; proxy_pass http://101.34.72.205:3001/; } location /youdao/ { rewrite ^/youdao/(.*) /$1 break; proxy_pass http://dict.youdao.com; } ","tags":[{"index":-1,"name":"nginx","slug":"M7LDc3_DQ","used":true,"link":"https://qin_hu.gitee.io/blog/tag/M7LDc3_DQ/"}],"title":"反向代理","feature":"","link":"https://qin_hu.gitee.io/blog/post/fan-xiang-dai-li/","stats":{"text":"1 min read","time":40000,"words":161,"minutes":1},"date":"2024-01-25 10:45:33","dateFormat":"2024-01-25"},{"content":"1.html设置meta头 在本地开发使用http，线上使用https，所以要根据情况设置同源策略。本地时使用第一行，线上使用第二行。 &lt;!-- 本地http --&gt; &lt;!-- &lt;meta http-equiv=&quot;Content-Security-Policy&quot;/&gt; --&gt; &lt;!-- 线上https --&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt; 2.nginx配置反向代理 官网示例 修改nginx.conf文件内容 2-1.基本配置 http { server { listen 80; server_name example.com; location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_pass http://localhost:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; } } } 2-2.如果您只想转发 Socket.IO 请求 http { server { listen 80; root /var/www/html; location /socket.io/ { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_pass http://localhost:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; } } } 2-3. 配置了https时在监听443端口配置 server { listen 443 ssl; server_name localhost; ssl_certificate heerblog.top_bundle.pem; ssl_certificate_key heerblog.top.key; location / { root html/heerblog/dist; index index.html index.htm; try_files $uri $uri/ @router; } location /api/ { rewrite ^/api/(.*) /$1 break; proxy_pass http://101.34.72.205:3001/; } #配置socket location /socket.io/ { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_pass http://localhost:3001; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; } } 3.连接soket.io 3-1.客户端 const socket = io.connect(&quot;https://www.heerblog.top/&quot;, { rejectUnauthorized: false }); 本地连接时设置meta为&lt;meta http-equiv=&quot;Content-Security-Policy&quot;/&gt; 2.3-2.服务端 const { createServer } = require(&quot;http&quot;); const { Server } = require(&quot;socket.io&quot;); const httpServer = createServer(); const io = new Server(httpServer, { /* options */ }); io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); httpServer.listen(3000); ","tags":[{"index":-1,"name":"nginx","slug":"M7LDc3_DQ","used":true,"link":"https://qin_hu.gitee.io/blog/tag/M7LDc3_DQ/"}],"title":"nginx配置socket.io","feature":"","link":"https://qin_hu.gitee.io/blog/post/nginx-pei-zhi-socketio/","stats":{"text":"2 min read","time":113000,"words":351,"minutes":2},"date":"2024-01-25 10:44:28","dateFormat":"2024-01-25"},{"content":"1. 介绍 Gitea是一个极易安装，运行非常快速，安装和使用体验良好的自建Git服务。采用Go作为后端语言，这使得只要生成一个可执行程序即可。并且他还支持跨平台，支持Linux、macOS和Windows以及各种架构，除了x86，amd64，还包括ARM和 PowerPC。 2. 准备工作 1、安装MySQL/Mariadb数据库 安装完成后，安装MySQL，至少5.5.3版本。 2、安装Git Debian和Ubuntu系统 apt-get -y install git CentOS系统 yum -y install git 3. 安装gitea // 创建文件目录 cd /usr/local/gitea // 下载 wget -O gitea https://dl.gitea.io/gitea/1.6.0/gitea-1.6.0-linux-amd64 //运行 chmod +x gitea ./gitea web 4. 启动gitea 在服务器上打开防火墙3000端口，使用localhost:3000来查看gitea。 选择注册，新建一个gitea账号 5. 使用服务来持久化启动gitea 新建一个rclone.service文件： vi /usr/lib/systemd/system/gitea.service 写入： [Unit] Description=gitea [Service] User=root ExecStart=/usr/local/gitea/gitea Restart=on-abort [Install] WantedBy=multi-user.target 重载daemon，让新的服务文件生效： systemctl daemon-reload 现在就可以用systemctl来启动gitea了： systemctl start gitea 设置开机启动： systemctl enable gitea 停止、查看状态可以用： systemctl stop gitea systemctl status gitea vim基本使用 vim是我们在使用Linux是经常会使用的工具，新手总是忘记使用方法（当然我也是）。在这里记录下常用命令以防止以后再忘记 进入编辑模式： i （在当前位置插入，开始编辑）； 保存编辑文本： :w (英文冒号，保存当前编辑的文件）； 退出编辑文件： :q（英文冒号，退出当前编辑的文件）； 保存并退出： :wq （英文冒号，保存并退出当前编辑的文件）； 强制退出： :q! （英文冒号，强制退出不保存）。 ","tags":[{"index":-1,"name":"git","slug":"EkPmoJq_R","used":true,"link":"https://qin_hu.gitee.io/blog/tag/EkPmoJq_R/"}],"title":"Gitea - 搭建私有git服务","feature":"","link":"https://qin_hu.gitee.io/blog/post/gitea-da-jian-si-you-git-fu-wu/","stats":{"text":"2 min read","time":113000,"words":461,"minutes":2},"date":"2024-01-25 10:33:28","dateFormat":"2024-01-25"},{"content":"1. 10054 解决方法: 打开Git命令页面，执行git命令脚本：修改设置，解除ssl验证 git config --global http.sslVerify &quot;false&quot; 打开Git命令页面，执行git命令脚本：修改设置，解除ssl验证 打开Git命令页面，执行git命令脚本：修改设置，解除ssl验证 2.pull时本地分支的更改没有保存下来 error: Your local changes to the following files would be overwritten by merge: package-lock.json 解决方法：丢弃本地改动 //只针对本地没有修改代码的情况 //丢弃所有本地未提交的修改 git checkout . 3. Note about fast-forwards 问题解决 问题： 解决方案：因为远程仓库新建时，有LIENCE，由于本地仓库和远程仓库有不同的开始点，也就是两个仓库没有共同的commit出现，无法提交，此时我们需要allow-unrelated-histories。也就是我们的 pull 命令改为下面这样的： git pull origin master --allow-unrelated-histories 如果设置了默认分支，可以这样写： git pull --allow-unrelated-histories ","tags":[{"index":-1,"name":"git","slug":"EkPmoJq_R","used":true,"link":"https://qin_hu.gitee.io/blog/tag/EkPmoJq_R/"}],"title":"git常见错误","feature":"","link":"https://qin_hu.gitee.io/blog/post/git-chang-jian-cuo-wu/","stats":{"text":"2 min read","time":64000,"words":267,"minutes":2},"date":"2024-01-25 10:31:59","dateFormat":"2024-01-25"},{"content":"1. 什么是算法 算法指的是在有限时间内解决特定问题的一组指令或操作步骤。 算法是一种过程，数据结构是一种组织数据的方式： 算法是一系列定义好的步骤，用于解决特定问题或执行特定任务。数据结构则是在计算机中组织和存储数据的方式。 将数据结构与算法类比为拼装积木，积木代表数据，积木的形状和连接方式等代表数据结构，拼装积木的步骤则对应算法。 2. 复杂度分析 2-1. 算法效率评估 算法设计追求两个目标： 找到问题解法 寻找最优解法（既快又省） 时间效率：算法运行速度的快慢 空间效率：算法占用内存空间的大小 2-2. 迭代和递归 在程序中实现重复执行任务，即两种基本的程序控制结构：迭代、递归。 /** * @description for求和 * @returns */ function summationFor(num) { let sum = 0; for (let index = 1; index &lt;= num; index++) { sum += index } return sum } console.info(&quot;for:&quot;, summationFor(100)) /** * @desc while求和 */ function summationWhile(num) { let sum = 0; let i = 1; while (i &lt;= num) { sum += i; i++; } return sum } console.info(&quot;while:&quot;, summationFor(100)) 递归 递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。 函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。 递归调用函数会产生额外的开销。因此递归通常比循环的时间效率更低。 /** * @description 普通递归求和 */ function summationRecursion(num) { if (num === 1) { return 1; } return num + summationRecursion(num - 1); } console.info(&quot;递归:&quot;, summationRecursion(100)); /** * @description 尾递归求和 */ function summationTailRecursion(num, sum = 0) { if (num === 0) { return sum; } return summationTailRecursion(num - 1, sum + num); } console.info(&quot;尾递归:&quot;, summationTailRecursion(100)); /** * @description 递归树 * 例子：斐波那契数列 ：0,1,1,2,3,5,8,13....,。求给定的第n个数 * 先写思路 f(n)=f(n-2)+f(n-1) */ function fibonacci(n) { if(n==1||n==2){ return n-1 } return fibonacci(n-2)+fibonacci(n-1) } console.info(&quot;斐波那契数列:&quot;,fibonacci(10)) ","tags":[{"name":"问题","slug":"SHR-RR261","used":true,"link":"https://qin_hu.gitee.io/blog/tag/SHR-RR261/"},{"name":"经验","slug":"hvFj4jXRRU","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hvFj4jXRRU/"}],"title":"算法","feature":"","link":"https://qin_hu.gitee.io/blog/post/suan-fa/","stats":{"text":"3 min read","time":136000,"words":554,"minutes":3},"date":"2024-01-24 14:07:43","dateFormat":"2024-01-24"},{"content":"useState 用于管理组件的响应式状态，第一个参数声明状态变量名称，第二个参数用于设置状态变量。修改状态变量组件会自动更新。 import React from &quot;react&quot; export default function HookDemo() { &lt;!-- 定义状态变量 --&gt; const [count, setCount] = React.useState(0) return &lt;div&gt; &lt;h1&gt;useState&lt;/h1&gt; &lt;!-- 设置状态变量 --&gt; &lt;button onClick={()=&gt;setCount((count)=&gt;count+1)}&gt;点击我+1&lt;/button&gt;{count} &lt;/div&gt; } useEffect 在react函数式组件中充当生命周期的作用 //等价于 componentDidUpdate，在组件挂载完成后执行 React.useEffect(() =&gt; { console.log(&quot;componentDidUpdate&quot;) }) //等价于 componentDidMount，在组件每次更新执行 React.useEffect(() =&gt; { console.log(&quot;componentDidMount&quot;) }, []) //等价于 componentWillUnmount，在组件将要销毁的时候执行.每次状态更新后组件渲染都会被执行 React.useEffect(() =&gt; { return () =&gt; { console.log(&quot;componentWillUnmount&quot;) } }) //等价于 componentDidMount，在组件每次更新执行 React.useEffect(() =&gt; { console.log(&quot;count is change&quot;) }, [count]) useLayoutEffect useEffect 的执行时机是浏览器完成渲染之后，而 useLayoutEffect 的执行时机是浏览器把内容真正渲染到界面之前，和 componentDidMount 等价。useLayoutEffect比useEffect先执行。 import React from &quot;react&quot; export default function HookDemo() { const [isFlag,setIsFlag] = React.useState(false) React.useEffect(() =&gt; { console.log(&quot;isFlag is change&quot;) }, [isFlag]) return &lt;div&gt; &lt;h1&gt;useLayoutEffect&lt;/h1&gt; &lt;button onClick={()=&gt;setIsFlag(!isFlag)}&gt;切换颜色&lt;/button&gt; &lt;button style={{backgroundColor:isFlag?&quot;red&quot;:&quot;skyblue&quot;}}&gt;&lt;/button&gt; &lt;/div&gt; } useRef 获取Dom元素 import React from &quot;react&quot; export default function HookDemo() { const mybox=React.useRef(null) console.info(mybox.current) return &lt;div&gt; &lt;h1&gt;useRef&lt;/h1&gt; &lt;div ref={mybox}&gt;111&lt;/div&gt; &lt;/div&gt; } useImperativeHandle useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值（组件内部状态或者方法的hook）。 const Child = forwardRef(function Child(props, ref) { let [text, setText] = useState(&quot;child&quot;); const submit = () =&gt; { console.log(&quot;submit&quot;) }; useImperativeHandle(ref, () =&gt; { return { text, submit, }; }); return ( &lt;div className=&quot;child-box&quot;&gt; &lt;span&gt;Child&lt;/span&gt; &lt;/div&gt; ); }); const App = function Demo() { let x = useRef(null); useEffect(() =&gt; { console.log(x.current); }, []); return ( &lt;div className=&quot;demo&quot;&gt; App &lt;Child ref={x} /&gt; &lt;/div&gt; ); }; useMemo 依赖于组件的某个依赖改变时再重新渲染。 用于缓存复杂函数的计算结果或者构造的值。它返回缓存的结果。 import React from &quot;react&quot; export default function HookDemo(props, ref) { // ==useState const [count, setCount] = React.useState(0) // == useMemo const isOdd =React.useMemo(()=&gt;{ return count%2==1 },[count]) return &lt;div&gt; &lt;h1&gt;useState&lt;/h1&gt; &lt;button onClick={() =&gt; setCount((count) =&gt; count + 1)}&gt;点击我+1&lt;/button&gt;{count} &lt;h1&gt;useMemo&lt;/h1&gt; &lt;button&gt;{isOdd?'奇数':'偶数'}&lt;/button&gt; &lt;/div&gt; } useCallback 用于缓存函数本身，确保函数的引用在依赖没有改变时保持稳定。 何时使用： 子组件的性能优化：当你将函数作为 prop 传递给已经通过React.memo进行优化的子组件时，使用2. useCallback可以确保子组件不会因为父组件中的函数重建而进行不必要的重新渲染。 Hook 依赖：如果你正在传递的函数会被用作其他 Hook（例如useEffect）的依赖时，使用useCallback可确保函数的稳定性，从而避免不必要的副作用的执行。 复杂计算与频繁的重新渲染：在应用涉及很多细粒度的交互，如绘图应用或其它需要大量操作和反馈的场景，使用useCallback可以避免因频繁的渲染而导致的性能问题。 const memoizedCallback = useCallback( () =&gt; { // 函数体 }, [dependency1, dependency2, ...] // 依赖数组 ); useContext 使用Context可以避免的组件的层层props嵌套的问题 const ThemeContext = React.createContext(); const App = function App() { let [number,setNumber] = useState(0) const changeNumber = (n)=&gt;{ setNumber(n) } return &lt;ThemeContext.Provider value={{ number, changeNumber }}&gt; &lt;div &gt; &lt;Child /&gt; &lt;/div&gt; &lt;/ThemeContext.Provider&gt;; }; const Child = function Child() { let { number, changeNumber } = useContext(ThemeContext); return &lt;div className=&quot;main&quot;&gt; &lt;p&gt;child：{number}&lt;/p&gt; &lt;Button onClick={()=&gt;{changeNumber(++number)}} &gt;点击&lt;/Button&gt; &lt;/div&gt;; }; useReducer useReducer相当于是对useState的升级处理，useReducer的思想采用了redux中对状态的管理，每次改变一个状态的时候通过派发一个action去通知reducer去更新状态，但一般使用useReducer的场景是一个组件中含有大量的状态、大量的修改状态的逻辑，才会选择采用useReducer进行管理，使用如下： const initialState = { num: 0 }; const reducer = function reducer(state, action) { state = { ...state }; switch (action.type) { case 'plus': state.num++; break; case 'minus': state.num--; break; default: } return state; }; const A1 = function A1() { //state：获取的状态 dispatch：负责派发action通知reducer更新数据 //reducer：状态管理者，根据传入的action来进行不同的数据操作 initialState：初始化状态值 let [state, dispatch] = useReducer(reducer, initialState); return &lt;div className=&quot;box&quot;&gt; &lt;span&gt;{state.num}&lt;/span&gt; &lt;br /&gt; &lt;button onClick={() =&gt; { dispatch({ type: 'plus' }); }}&gt;增加&lt;/button&gt; &lt;button onClick={() =&gt; { dispatch({ type: 'minus' }); }}&gt;减少&lt;/button&gt; &lt;/div&gt;; }; 参考链接 https://juejin.cn/post/7221047453963812920?searchId=202401231153449449ECDEAE6FD16781DC#heading-9 ","tags":[{"index":-1,"name":"React","slug":"TL1T7hUz1","used":true,"link":"https://qin_hu.gitee.io/blog/tag/TL1T7hUz1/"}],"title":"hook - react基本内置组件","feature":"","link":"https://qin_hu.gitee.io/blog/post/hook-react-ji-ben-nei-zhi-zu-jian/","stats":{"text":"6 min read","time":344000,"words":1227,"minutes":6},"date":"2024-01-23 13:31:47","dateFormat":"2024-01-23"},{"content":"什么是性能优化？ 产品的性能影响网站转化率和用户留存率以及产品体验和传播。 网站转化率：访问用户转化为消费用户的转化率。（网站卡顿，访问速度慢降低网站转化率） 用户留存率：网站访问速度慢会被多数用户摈弃。 产品体验和传播：网站访问速度慢，用户会拒绝向周边用户推荐产品，影响产品口碑。 性能优化的方向：RAIL性能模型 响应（Response）: 用户操作的响应控制在100ms内 动画（Animation） 加载（Load） 空闲（Idle）：利用空闲时间来处理可延迟的任务 ","tags":[{"name":"问题","slug":"SHR-RR261","used":true,"link":"https://qin_hu.gitee.io/blog/tag/SHR-RR261/"},{"name":"经验","slug":"hvFj4jXRRU","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hvFj4jXRRU/"},{"index":-1,"name":"Html&Css","slug":"18jtBTPqK","used":true,"link":"https://qin_hu.gitee.io/blog/tag/18jtBTPqK/"}],"title":"优化 - 性能加载速度","feature":"","link":"https://qin_hu.gitee.io/blog/post/you-hua-xing-neng-jia-zai-su-du/","stats":{"text":"1 min read","time":36000,"words":175,"minutes":1},"date":"2024-01-23 10:41:24","dateFormat":"2024-01-23"},{"content":"html 1. src和href的区别 两者都是用来引用外部资源。 src会嵌入到当前标签所在的位置，浏览器解析到该元素，会暂停其他资源的加载，直到该资源加载完毕。js脚本放在script底部。 href表示超文本引用，并行下载资源，不会停止对当前文档的处理。 2. 对Html语义化的理解 常见语义化标签：footer,main,header,section,article,aside,nav 有利于seo，机器搜索引擎更容易爬取有效信息。 有利于开发者维护代码，增强代码可读性。 3. DOCTYPE(⽂档类型) 的作用 目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档。 4. script标签中defer和async的区别 不加这两个属性将会直接加载外部资源。 defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析。 defer会按照顺序异步加载，async不会。 5. 常用的meta标签 charset 描述编码文档类型。 keywords 页面关键字。 description 页面描述。 refresh 页面重定向和刷新。 viewport 适配移动端，控制视口的大小。 content 设置文件索引的范围。 all：文件将被检索，且页面上的链接可以被查询； none：文件将不被检索，且页面上的链接不可以被查询； index：文件将被检索； follow：页面上的链接可以被查询； noindex：文件将不被检索； nofollow：页面上的链接不可以被查询。 ","tags":[{"name":"问题","slug":"SHR-RR261","used":true,"link":"https://qin_hu.gitee.io/blog/tag/SHR-RR261/"},{"name":"经验","slug":"hvFj4jXRRU","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hvFj4jXRRU/"}],"title":"基础 - html,css,js","feature":"","link":"https://qin_hu.gitee.io/blog/post/ji-chu-htmlcssjs/","stats":{"text":"2 min read","time":87000,"words":401,"minutes":2},"date":"2024-01-23 09:17:10","dateFormat":"2024-01-23"},{"content":"了解Stable Diffusion https://foresightnews.pro/article/detail/41306 安装Stable Diffusion https://nenly.notion.site/c5805e7ae26b4683a277c5586ea05904#12a3450e2e204e64b30bd80345d096c3 1. 安装python 通过python国内镜像下载： https://repo.huaweicloud.com/python/3.10.6/。 下载成功后正常安装（勾选Path选项），然后电脑搜索输入框输入cmd打开命令终端窗口，输入python -V显示版本号则安装成功。 学习链接 https://tob-design.yuque.com/kxcufk/sd/nxw6acd2bbohuaqo https://nenly.notion.site/nenly/017c3341c8b84a7ebb4c2cb16f36e28f?v=8d3885a8404b4f27a998d03b23a87f19 模型免费下载网址 https://civitai.com/ https://www.liblib.art/ 炼丹阁 (https://liandange.com) 抱脸网 (https://huggingface.com) 1. 原理分析： 扩散模型。 ","tags":[{"index":-1,"name":"AIGC","slug":"kb2X9iD0-","used":true,"link":"https://qin_hu.gitee.io/blog/tag/kb2X9iD0-/"}],"title":"Stable Diffusion","feature":"","link":"https://qin_hu.gitee.io/blog/post/stable-diffusion/","stats":{"text":"1 min read","time":39000,"words":145,"minutes":1},"date":"2024-01-19 13:05:05","dateFormat":"2024-01-19"},{"content":"1. 上中下布局（上下固定，中间自适应布局） 最基本的一个layout布局：上中下布局。 思路：使用Flex组件，顶部和底部设置高度，中间设置自适应高并且显示进度条。 @Component export default struct Layout { scroller: Scroller = new Scroller(); @Builder LayoutHeader() { Column(){ Text('这是头部') } .justifyContent(FlexAlign.Center) .height(50) .width(&quot;100%&quot;) .backgroundColor(&quot;#ffcaa5a5&quot;) } @Builder LayoutFooter() { Column(){ Text('这是底部') } .height(50) .width(&quot;100%&quot;) .justifyContent(FlexAlign.Center) .backgroundColor(&quot;#ffe7c7c7&quot;) } @BuilderParam Header:()=&gt;void=this.LayoutHeader; @BuilderParam Footer:()=&gt;void=this.LayoutFooter; build(){ Flex({direction:FlexDirection.Column}){ this.Header() Column(){ Scroll(){ Column(){ Text(&quot;内容&quot;) } } .width(&quot;100%&quot;) .height(&quot;100%&quot;) .scrollable(ScrollDirection.Vertical) // 滚动方向为垂直方向 .scrollBar(BarState.Off) // 滚动条常驻显示 .scrollBarColor(Color.Gray) // 滚动条颜色 .scrollBarWidth(10) // 滚动条宽度 .edgeEffect(EdgeEffect.Spring) // 滚动到边沿后回弹 } .flexGrow(1) .width('100%') this.Footer() } } } ","tags":[{"index":-1,"name":"HarmonyOS","slug":"sjEwf3qeE","used":true,"link":"https://qin_hu.gitee.io/blog/tag/sjEwf3qeE/"}],"title":"自定义页面布局","feature":"","link":"https://qin_hu.gitee.io/blog/post/zi-ding-yi-ye-mian-bu-ju/","stats":{"text":"1 min read","time":57000,"words":202,"minutes":1},"date":"2024-01-18 21:53:25","dateFormat":"2024-01-18"},{"content":"1. 新建项目目录 ├── entry │ ├── ets │ │ ├── model 数据模型 │ │ ├── network 网络请求 │ │ ├── pages ui界面 │ │ ├── utils 工具集 │ │ ├── components 视图组件 │ │ ├── layouts 布局组件 │ │ └── workers 异步线程 2. 创建页面 创建页面的方法 2-1. 通过编辑器创建页面 打开ProjectName\\entry\\src\\main\\ets\\pages目录，右键点击鼠标选择创建页面。 然后在ProjectName\\entry\\src\\main\\resources\\base\\profile\\main_pages.json文件查看创建的页面。 { &quot;src&quot;: [ &quot;pages/Index&quot; ] } 2-2. 手动创建页面 项目中页面过多为了方便管理，一般都会创建二级页面。这个时候通过编辑器创建就不好实现，为了实现多级page目录，我们可以这样做： 1. 修改项目目录初始化页面 在Projectname\\entry\\src\\main\\ets\\entryability\\EntryAbility.ts文件中的 onWindowStageCreate方法中修改页面初始化页面。 .. onWindowStageCreate(windowStage: window.WindowStage) { // 在此处修改文件初始化路径 windowStage.loadContent('pages/Index/Index', (err, data) =&gt; { if (err.code) { .. return; } .. }); } ... 2. 自定义页面 在`Projectname\\entry\\src\\main\\ets\\pages`文件夹下新建Index目录，然后新建一个`Index.ets`文件 ├── entry │ ├── ets │ │ ├── pages │ │ ├──├── Index 目录 │ │ ├──├──├── Index ui界面 3. 注册页面 在Projectname\\entry\\src\\main\\resources\\base\\profile\\main_pages.json文件中注册页面 { &quot;src&quot;: [ &quot;pages/Index/Index&quot; ] } 3. 设计布局，创建布局组件 搭配Tabs组件自定义Layou布局组件 4. 封装axios,网络请求工具（可选） 5. 开始开发 尝试打包 参考优秀项目的项目文件目录 【OH哔哩】是一款基于OpenHarmony系统ArkUI框架开发的哔哩哔哩动画第三方客户端。 ","tags":[{"index":-1,"name":"HarmonyOS","slug":"sjEwf3qeE","used":true,"link":"https://qin_hu.gitee.io/blog/tag/sjEwf3qeE/"}],"title":"创建项目思路","feature":"","link":"https://qin_hu.gitee.io/blog/post/chuang-jian-xiang-mu-si-lu/","stats":{"text":"2 min read","time":98000,"words":401,"minutes":2},"date":"2024-01-17 21:58:04","dateFormat":"2024-01-17"},{"content":"1. 先根据官方教程安装和配置ohpm包 https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/ide-command-line-ohpm-0000001490235312-V3 具体思路 安装ohpm包 执行初始化ohpm命令 将ohpm命令配置到环境变量中 cmd检查是否配置成功 ohpm -v 2. 下载依赖 打开ohpm官网选择第三方库。 这里以@ohos/pinyin4js(将中文转拼音)库为例： 在项目根目录执行一下命令 ohpm install @ohos/pinyin4js 下载后查看oh-package.json5文件 { &quot;name&quot;: &quot;helloworld&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Please describe the basic information.&quot;, &quot;main&quot;: &quot;&quot;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;&quot;, &quot;dependencies&quot;: { &quot;@ohos/pinyin4js&quot;: &quot;^2.0.0&quot; }, &quot;devDependencies&quot;: { &quot;@ohos/hypium&quot;: &quot;1.0.6&quot; } } 3. 在项目中使用 import {pinyin4js} from '@ohos/pinyin4js'; @Entry @Component struct OhpmDemo { @State message: string = 'Hello World' onPageShow(){ console.info(pinyin4js.convertToPinyinString('你好鸿蒙', ' ', pinyin4js.WITH_TONE_MARK)); // nǐ hǎo hóng mēng } build() { } } ","tags":[{"index":-1,"name":"HarmonyOS","slug":"sjEwf3qeE","used":true,"link":"https://qin_hu.gitee.io/blog/tag/sjEwf3qeE/"}],"title":"实战 - 使用ohpm引入三方库","feature":"","link":"https://qin_hu.gitee.io/blog/post/shi-yong-ohpm-yin-ru-san-fang-ku/","stats":{"text":"2 min read","time":68000,"words":229,"minutes":2},"date":"2024-01-17 21:09:46","dateFormat":"2024-01-17"},{"content":"AIGC（AI Generated Content）是指使用人工智能技术生成的内容。它可以用于生成文本、图像、视频等内容。与其他内容生成技术（如PGC和UGC）相比，AIGC可以更快、更准确地生成内容，并且可以更好地模仿人类语言。AIGC可以用于各种应用，如自动文档生成、聊天机器人、自动新闻编写等。 编程 CodeGeeX 国内代码生成工具，个人开发者免费使用 screenshot2html 截图生成html代码 screenshot to code 截图转换为前端代码 截图生成前端代码 html代码片段块 20秒生成页面 截图生成前端代码 提问 AI智慧岛 设计 Figma Figma是一个在线协作设计工具,设计师可以在浏览器中设计UI,进行原型设计,方便团队成员实时协作。 framer 超级好用的设计网站 图像 vegaai https://www.vegaai.net/ leonardo https://leonardo.ai/ 导航站点 AIGC交流群工具沉淀 by 乔向阳 ai-apps huggingface AI世界的github gptdemo 超多aigc插件 aibase 发现最佳的ai库 开发全部流程 sahnirmatha sahnirmatha是一款基于人工智能的原型设计与开发工具。它可以帮助用户在几分钟内创建令人惊叹的原型、全栈应用和 MVP，无需编码技能。 室内设计 免费生成3d室内设计 ","tags":[{"index":-1,"name":"AIGC","slug":"kb2X9iD0-","used":true,"link":"https://qin_hu.gitee.io/blog/tag/kb2X9iD0-/"}],"title":"AIGC生产力工具","feature":"","link":"https://qin_hu.gitee.io/blog/post/aigc-sheng-chan-li-gong-ju/","stats":{"text":"2 min read","time":77000,"words":352,"minutes":2},"date":"2024-01-17 17:16:56","dateFormat":"2024-01-17"},{"content":"1. 打包问题 1-1. window打包解决Electron，nsis、winCodeSign 下载慢 根目录创建.npmrc文件,新增镜像源变量 ELECTRON_MIRROR=https://npmmirror.com/mirrors/electron/ ELECTRON_BUILDER_BINARIES_MIRROR=https://npmmirror.com/mirrors/electron-builder-binaries/ 2. 打包vue-router失效 https://blog.csdn.net/qq_42611074/article/details/123947573 3. 外部引入的js依赖，umd在预加载层处理 在预加载文件中引入依赖 import { contextBridge } from 'electron' import { electronAPI } from '@electron-toolkit/preload' // 引入依赖 import LibGenerateTestUserSig from './lib-generate-test-usersig-es.min.js'; const api = { // 当前引入 libGenerateTestUserSig:LibGenerateTestUserSig } if (process.contextIsolated) { try { contextBridge.exposeInMainWorld('electron', electronAPI) contextBridge.exposeInMainWorld('api', api) } catch (error) { console.error(error) } } else { // @ts-ignore (define in dts) window.electron = electronAPI // @ts-ignore (define in dts) window.api = api // LibGenerateTestUserSig // window.libGenerateTestUserSig=LibGenerateTestUserSig } 在渲染层使用 const generator = new window.api.libGenerateTestUserSig(sdkAppId, SECRETKEY, EXPIRETIME); 4. 在electron中使用router 使用hash模式 5. 多窗口的创建 使用代理对象 6. electron-vite项目对文件进行了ASAR加密,打包会出现无法操作node内置file文件的问题 解决方案：对进行fule文件的主进程文件取消ASAR加密 import { resolve } from 'path' import { defineConfig, externalizeDepsPlugin } from 'electron-vite' import resolvePlugin from 'vite-plugin-resolve' import requireTransform from 'vite-plugin-require-transform' import vue from '@vitejs/plugin-vue' export default defineConfig({ main: { // 这里注释掉下面代码 // plugins: [externalizeDepsPlugin()] }, preload: { plugins: [externalizeDepsPlugin()] }, renderer: { resolve: { alias: { '@renderer': resolve('src/renderer/src') } }, plugins: [vue(), requireTransform({ fileRegex: /.js$|.vue$/ }) ] } }) 7. The requested address is not valid in its context 运行npm run build:win 报以下错误： Get &quot;https://npmmirror.com/mirrors/electron/25.9.8/electron-v25.9.8-win32-x64.zip&quot;: proxyconnect tcp: dial tcp :0: connectex: The requested address is not valid in its context 解决方案： 关闭npm设置的代理npm config rm proxy 8. electron使用nodeJs时保存路径位置 代码示例 import path from 'path'; import { app } from 'electron' import { is } from '@electron-toolkit/utils' /** * path路径转化斜杠 * @param path 路径 * @returns */ function getPath(path) { return path.replaceAll('\\\\', '/') } let path=is.dev &amp;&amp; process.env['ELECTRON_RENDERER_URL'] ? getPath(`${app.getAppPath()}\\\\hrary.json`) : getPath(`${path.dirname(app.getPath('userData'))}\\\\hrary.json`) 开发环境 app.getAppPath() 当前app可执行的根路径 正式环境 path.dirname(app.getPath('userData')) app安装根目录文件夹 ","tags":[{"index":-1,"name":"Electron","slug":"6V806ttsC","used":true,"link":"https://qin_hu.gitee.io/blog/tag/6V806ttsC/"}],"title":"常见问题与electron开发经验","feature":"","link":"https://qin_hu.gitee.io/blog/post/chang-jian-wen-ti-yu-electron-kai-fa-jing-yan/","stats":{"text":"3 min read","time":144000,"words":481,"minutes":3},"date":"2024-01-17 16:01:59","dateFormat":"2024-01-17"},{"content":" 渲染层跟主进程发送消息，通过打开系统的录音设置 1. 渲染层传事件 async function microphoneAccess() { try { const microphoneAccess = window.electron.ipcRenderer.sendSync('getMediaAccessStatus', { mediaType: 'microphone' }) console.log('microphoneAccess', microphoneAccess) } catch (error) { throw error } } 2. 主进程调用打开窗口事件 const execCommand = require('child_process').exec function openWindow() { const curtOS = 'Windows' // 比如是Mac const curtMediaType = 'microphone' // 比如是麦克风 const platformCommandMap = { Windows: { camera: `start ms-settings:privacy-webcam`, microphone: `start ms-settings:privacy-microphone` }, Mac: { camera: `open x-apple.systempreferences:com.apple.preference.security\\?Privacy_Camera`, microphone: `open x-apple.systempreferences:com.apple.preference.security\\?Privacy_Microphone` } } const command = platformCommandMap[curtOS][curtMediaType] || '' command &amp;&amp; execCommand(command) } ipcMain.on('getMediaAccessStatus', (event, params) =&gt; { const mediaType = params.mediaType || '' const res = systemPreferences.getMediaAccessStatus(mediaType) console.log(`${mediaType}: `, res) event.returnValue = (res === 'granted') openWindow() }) 参考链接 https://juejin.cn/post/7162919977517842440#heading-3 https://www.jianshu.com/p/79f27ea74c26 https://blog.csdn.net/liulilittle/article/details/126240799 https://www.wikihow.com/Open-Applications-Using-Terminal-on-Mac ","tags":[{"index":-1,"name":"Electron","slug":"6V806ttsC","used":true,"link":"https://qin_hu.gitee.io/blog/tag/6V806ttsC/"}],"title":"系统操作 - electron对系统进行操作","feature":"","link":"https://qin_hu.gitee.io/blog/post/xi-tong-cao-zuo-electron-dui-xi-tong-jin-xing-cao-zuo/","stats":{"text":"2 min read","time":62000,"words":190,"minutes":2},"date":"2024-01-17 15:46:38","dateFormat":"2024-01-17"},{"content":" 渲染层跟主进程发送消息，通过打开系统的录音设置 1. 渲染层传事件 async function microphoneAccess() { try { const microphoneAccess = window.electron.ipcRenderer.sendSync('getMediaAccessStatus', { mediaType: 'microphone' }) console.log('microphoneAccess', microphoneAccess) } catch (error) { throw error } } 2. 主进程调用打开窗口事件 const execCommand = require('child_process').exec function openWindow() { const curtOS = 'Windows' // 比如是Mac const curtMediaType = 'microphone' // 比如是麦克风 const platformCommandMap = { Windows: { camera: `start ms-settings:privacy-webcam`, microphone: `start ms-settings:privacy-microphone` }, Mac: { camera: `open x-apple.systempreferences:com.apple.preference.security\\?Privacy_Camera`, microphone: `open x-apple.systempreferences:com.apple.preference.security\\?Privacy_Microphone` } } const command = platformCommandMap[curtOS][curtMediaType] || '' command &amp;&amp; execCommand(command) } ipcMain.on('getMediaAccessStatus', (event, params) =&gt; { const mediaType = params.mediaType || '' const res = systemPreferences.getMediaAccessStatus(mediaType) console.log(`${mediaType}: `, res) event.returnValue = (res === 'granted') openWindow() }) 参考链接 https://juejin.cn/post/7162919977517842440#heading-3 https://www.jianshu.com/p/79f27ea74c26 https://blog.csdn.net/liulilittle/article/details/126240799 https://www.wikihow.com/Open-Applications-Using-Terminal-on-Mac ","tags":[{"index":-1,"name":"Electron","slug":"6V806ttsC","used":true,"link":"https://qin_hu.gitee.io/blog/tag/6V806ttsC/"}],"title":"系统操作 - 打开系统窗口","feature":"","link":"https://qin_hu.gitee.io/blog/post/electron-xue-xi-da-kai-xi-tong-chuang-kou/","stats":{"text":"2 min read","time":62000,"words":190,"minutes":2},"date":"2024-01-17 15:45:07","dateFormat":"2024-01-17"},{"content":"1. 与vue-router结合使用 1-1. 按照环境变量设置路径 if (is.dev &amp;&amp; process.env['ELECTRON_RENDERER_URL']) { mainWindow.loadURL(process.env['ELECTRON_RENDERER_URL']) } else { mainWindow.loadFile(join(__dirname,process.env.NODE_ENV === 'development'?'http://localhost:5174':'../renderer/index.html')) } 2. 根据路由打开指定页面窗口 渲染层发送事件 &lt;script setup lang='ts'&gt; /** * 打开关于页面 */ function openAboutHandle(){ console.log('openAboutHandle') window.api.openAbout() } function openLoginHandle(){ console.log('openLoginHandle') window.api.openLogin() } &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;button&gt;home&lt;/button&gt; &lt;button @click=&quot;openAboutHandle&quot;&gt;about&lt;/button&gt; &lt;button @click=&quot;openLoginHandle&quot;&gt;login&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;style lang='scss' scoped&gt;&lt;/style&gt; 预加载脚本建立桥梁 preload.ts import { contextBridge, ipcRenderer } from 'electron' import { electronAPI } from '@electron-toolkit/preload' // 建立事件 const api = { openAbout:()=&gt;ipcRenderer.invoke('open:openAbout'), openLogin:()=&gt;ipcRenderer.invoke('open:openLogin') } if (process.contextIsolated) { try { contextBridge.exposeInMainWorld('electron', electronAPI) contextBridge.exposeInMainWorld('api', api) } catch (error) { console.error(error) } } else { // @ts-ignore (define in dts) window.electron = electronAPI // @ts-ignore (define in dts) window.api = api } 主进程创建页面 ... app.whenReady().then(() =&gt; { electronApp.setAppUserModelId('com.electron') app.on('browser-window-created', (_, window) =&gt; { optimizer.watchWindowShortcuts(window) }) createWindow() app.on('activate', function () { if (BrowserWindow.getAllWindows().length === 0) createWindow() }) /** * 打开页面 */ ipcMain.handle('open:openAbout', () =&gt; {//打开新的窗口 const openAboutWindow = new BrowserWindow({ width: 450, height: 900, show: false, autoHideMenuBar: false, ...(process.platform === 'linux' ? { icon } : {}), webPreferences: { preload: join(__dirname, '../preload/index.js'), sandbox: false, nodeIntegration: true, contextIsolation: false, } }) if (is.dev &amp;&amp; process.env['ELECTRON_RENDERER_URL']) { openAboutWindow.loadURL(`${process.env['ELECTRON_RENDERER_URL']}/#/about`) } else { openAboutWindow.loadFile(join(__dirname, '../renderer/index.html'), { hash: 'about' }) } openAboutWindow.once('ready-to-show', () =&gt; { console.log('about page show') openAboutWindow.show() }) }) /** * login */ ipcMain.handle('open:openLogin', () =&gt; {//打开新的窗口 const openLoginWin = new BrowserWindow({ width: 450, height: 900, show: false, autoHideMenuBar: false, ...(process.platform === 'linux' ? { icon } : {}), webPreferences: { preload: join(__dirname, '../preload/index.js'), sandbox: false, nodeIntegration: true, contextIsolation: false, } }) if (is.dev &amp;&amp; process.env['ELECTRON_RENDERER_URL']) { openLoginWin.loadURL(`${process.env['ELECTRON_RENDERER_URL']}/#/login`) } else { openLoginWin.loadFile(join(__dirname, '../renderer/index.html'), { hash: 'login' }) } openLoginWin.once('ready-to-show', () =&gt; { console.log('login page show') openLoginWin.show() }) // openLoginWin.webContents.openDevTools() }) }) ... 2. 封装窗口管理方法 main/service/window.ts 通过对象代理将窗口存储起来，并且标记名称，通过名称操作窗口 注意点： 监听窗口关闭时的回调，窗口关闭时需要销毁窗口 当name为'main'时，默认为主窗口 生产环境路径使用hash模式 打开新窗口时设置窗口偏移 /** * 窗口管理文件 */ import { join } from 'path' import { shell, BrowserWindow } from 'electron' import { is } from '@electron-toolkit/utils' import icon from '../../../resources/icon.png?asset' /** * 创建代理对象，存储窗口 */ const winDict: any = {}; const defaultWidth=375; const defaultHeight=812; const WindowDictProxy = new Proxy(winDict, { get: function (obj: any, prop: string) { return obj[prop] }, set: function (obj: any, prop: string, value: any) { if (obj[prop]) { return false } else { obj[prop] = value; return true; } }, has(target: any, key: string) { if (Object.getOwnPropertyNames(target).includes(key)) { return true } else { return false } }, ownKeys: function (target: any) { return [...Object.getOwnPropertyNames(target)] }, deleteProperty: function (target: any, prop: string) { try { delete target[prop] return true; } catch (e) { return false; } } }) /** * 通过name托管窗口，name='main'时指定为主窗口 */ const setWindowByName = (Window: any, name: string) =&gt; { try { WindowDictProxy[name] = Window; return name; } catch (e) { console.log(`${name} window is not destroyed. Please try again later`) return false } } /** * 创建窗口 * @param options 创建窗口的配置 * @param isMain 自定义配置---是否主窗口 * @param path 跳转路由 * @param name 路由名称 --- 用来生成窗口id，通过name获取窗口 * @param isOpenDevTools 是否默认打开控制台 * @param isExceptWin 打开窗口是否关闭其他窗口 * @param isEqualScaling 是否等比例缩放 //默认等比例 * @param title 页面的标题 */ export const createWindow = (options, { isMain = false, path = '', name, isOpenDevTools = false, isEqualScaling = true, title ='思梦' }) =&gt; { let x, y; if (!isMain &amp;&amp; getWinByName('main')) { // 设置偏移量 const [currentWindowX, currentWindowY] = getWinByName('main').getPosition(); x = isMain ? currentWindowX : (currentWindowX + defaultWidth); y = isMain ? currentWindowY : (currentWindowY + 0); } const win = isMain ? new BrowserWindow({ ...options, width: options.width || defaultWidth, height: options.height || defaultHeight, show: options.show || false, center: options.center || true, autoHideMenuBar: options.autoHideMenuBar || true, icon:icon, webPreferences: options.webPreferences || { preload: join(__dirname, '../preload/index.js'), sandbox: false, nodeIntegration: true, contextIsolation: false, }, title }) : new BrowserWindow({ ...options, width: options.width || defaultWidth, height: options.height || defaultHeight, show: options.show || false, center: options.center || true, autoHideMenuBar: options.autoHideMenuBar || true, webPreferences: options.webPreferences || { preload: join(__dirname, '../preload/index.js'), sandbox: false, nodeIntegration: true, contextIsolation: false, }, x: options.x || x, y: options.y || y, title }) setWindowByName(win, name) if (isOpenDevTools) { win.webContents.openDevTools() } // 主窗口事件 if (isMain) { // 页面显示时触发 win.on('show', () =&gt; { console.log('show') }) // 页面隐藏时触发 win.on('hide', () =&gt; { console.log('hide') }) // 页面最小化触发 win.on('minimize', () =&gt; { console.log('minimize') }) // 调节页面大小时触发 win.on('resize', () =&gt; { console.log('resize') }) win.webContents.setWindowOpenHandler((details) =&gt; { shell.openExternal(details.url) return { action: 'deny' } }) } // 等比例缩放 if (isEqualScaling) { if (options.width &amp;&amp; options.height) { win.setAspectRatio(options.width / options.height) } else { win.setAspectRatio(defaultWidth / defaultHeight) } } // 监听窗口关闭时的回调，窗口关闭时需要销毁窗口 win.on('closed', () =&gt; { console.log('closed success', name) delete WindowDictProxy[name] }) win.webContents.setWindowOpenHandler((details) =&gt; { shell.openExternal(details.url) return { action: 'deny' } }) if (is.dev &amp;&amp; process.env['ELECTRON_RENDERER_URL']) { win.loadURL(`${process.env['ELECTRON_RENDERER_URL']}/#${path}`) } else { win.loadFile(join(__dirname, '../renderer/index.html'), { hash: isMain ? '' : path.split('/')[1] }) } win.once('ready-to-show', () =&gt; { console.log('about page show') win.show() }) } /** * 获取所有缓存key * @returns Array 缓存key */ export const getAllCacheWin = () =&gt; { // const allWin = myCache.getStats() // return allWin; } /** * 根据name获取指定的窗口 * @param name 路由名称 */ export const getWinByName = (name: string) =&gt; { try { return WindowDictProxy[name] } catch (error) { return false } } /** * 根据name关闭指定的窗口没并且删除窗口缓存 * @param name 路由名称 */ export const closeWinByName = (name: string) =&gt; { try { getWinByName[name].closed() delete WindowDictProxy[name] } catch (error) { throw error } } /** * 通过name隐藏窗口 * @param name * */ export const hideWindowByName = (name: string) =&gt; { try { getWinByName(name).hide() } catch (e) { throw e } } /** * 通过name显示窗口 * @param name * */ export const showWindowByName = (name: string) =&gt; { try { getWinByName(name).show() } catch (e) { throw e } } /** * 通过name最小化窗口 * @param name * */ export const minimizeWindowByName = (name: string) =&gt; { try { getWinByName(name).minimize() } catch (e) { throw e } } /** * 通过name最大化窗口 * @param name * */ export const maximizeWindowByName = (name: string) =&gt; { try { getWinByName(name).maximize() } catch (e) { throw e } } /** * 通过name还原窗口 * @param name * */ export const restoreWindowByName = (name: string) =&gt; { try { getWinByName(name).restore() } catch (e) { throw e } } /** * 关闭所有窗口 * */ export const closeAllWindows = () =&gt; { Object.getOwnPropertyNames(WindowDictProxy).forEach( (name: string) =&gt; { WindowDictProxy[name].close(); delete WindowDictProxy[name]; } ) } /** * 关闭除主窗口以外的所有窗口 * */ export const closeExceptMainWindows = () =&gt; { Object.getOwnPropertyNames(WindowDictProxy).forEach( (name: string) =&gt; { if (name === 'main') return WindowDictProxy[name].close(); delete WindowDictProxy[name]; } ) } 页面中使用 1. 创建router页面 route.ts import { Router, createRouter, createWebHashHistory } from &quot;vue-router&quot;; import Home from '../view/home/index.vue' import About from '../view/about/index.vue' import Login from '../view/login/index.vue' import LiveHome from '../view/live/home/index.vue' const routes = [ { path: '/', component: Home }, { path: '/about', component: About }, { path: '/login', component: Login }, { path: '/live', redirect: { name: 'liveHome' }, name:'live', children: [ { path: 'home', name: 'liveHome', component: LiveHome } ] } ] export const router: Router = createRouter({ history: createWebHashHistory(), routes: routes, strict: true, }); export default router 2. 渲染层触发打开窗口事件 home.vue &lt;script setup lang='ts'&gt; function openAboutHandle(){ console.log('openAboutHandle') window.api.openAbout() } function openLoginHandle(){ console.log('openLoginHandle') window.api.openLogin() } function openLiveHomeHandle(){ window.api.openLiveHome() } &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;button&gt;home&lt;/button&gt; &lt;button @click=&quot;openAboutHandle&quot;&gt;about&lt;/button&gt; &lt;button @click=&quot;openLoginHandle&quot;&gt;login&lt;/button&gt; &lt;button @click=&quot;openLiveHomeHandle&quot;&gt;live-home&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;style lang='scss' scoped&gt;&lt;/style&gt; 3. 预加载脚本中发送事件 preload.ts import { contextBridge, ipcRenderer } from 'electron' import { electronAPI } from '@electron-toolkit/preload' // 此处创建自定义事件 const api = { openAbout:()=&gt;ipcRenderer.invoke('open:openAbout'), openLogin:()=&gt;ipcRenderer.invoke('open:openLogin'), openLiveHome:()=&gt;ipcRenderer.invoke('open:openLiveHome'), } if (process.contextIsolated) { try { contextBridge.exposeInMainWorld('electron', electronAPI) contextBridge.exposeInMainWorld('api', api) } catch (error) { console.error(error) } } else { // @ts-ignore (define in dts) window.electron = electronAPI // @ts-ignore (define in dts) window.api = api } 4. 主进程中调用创建新窗口事件 main.ts app.whenReady().then(() =&gt; { electronApp.setAppUserModelId('com.electron') app.on('browser-window-created', (_, window) =&gt; { optimizer.watchWindowShortcuts(window) }) // 主窗口页面 createWindow({}, { isMain: true, isOpenDevTools: true, name:'main' }) getWinByName('main').setAspectRatio(450 / 900) app.on('activate', function () { if (BrowserWindow.getAllWindows().length === 0) createWindow({}, { isMain: true, isOpenDevTools: true, name:'main' }) }) /** * 打开about页面 */ ipcMain.handle('open:openAbout', () =&gt; { closeExceptMainWindows() createWindow({}, { path: '/about', isMain: false, name: 'about', isOpenDevTools: true }) }) /** * 打开login */ ipcMain.handle('open:openLogin', () =&gt; { closeExceptMainWindows() createWindow({}, { path: '/login', isMain: false, name: 'login', isOpenDevTools: true }) }) // 打开live-home 测试二级 ipcMain.handle('open:openLiveHome',()=&gt;{ closeExceptMainWindows() createWindow({}, { path: '/live/home', isMain: false, name: 'live/home', isOpenDevTools: true }) }) }) ","tags":[{"index":-1,"name":"Electron","slug":"6V806ttsC","used":true,"link":"https://qin_hu.gitee.io/blog/tag/6V806ttsC/"}],"title":"electron学习 - 封装多窗口管理和router结合","feature":"","link":"https://qin_hu.gitee.io/blog/post/electron-xue-xi-feng-zhuang-duo-chuang-kou-guan-li-he-router-jie-he/","stats":{"text":"10 min read","time":585000,"words":1797,"minutes":10},"date":"2024-01-17 15:43:47","dateFormat":"2024-01-17"},{"content":"1. 菜单 function createWindow(): void { const menu = Menu.buildFromTemplate([ { label: '测试栏', submenu: [ { click: () =&gt; mainWindow.webContents.send('update-counter', -1), label: '减少' }, { click: () =&gt; mainWindow.webContents.send('update-counter', 1), label: '新增' } ] } ]) Menu.setApplicationMenu(menu) } 2. 选择文件 async function handleFileOpen() { const { canceled, filePaths } = await dialog.showOpenDialog({}) if (!canceled) { return filePaths[0] } } 3. 通知 options Object (可选) title string（可选）- 通知标题，在通知窗口顶部显示。 subtitlestring (可选) 通知的副标题, 显示在标题下面。 macOS body string (可选) - 通知的正文文本，将显示在标题或副标题下面。 silent boolean（可选）- 是否在显示通知时禁止操作系统发出通知提示音。 icon(string | NativeImage ) (可选) 用于在该通知上显示的图标。 hasReplyboolean (可选) 是否在通知中添加一个答复选项。 macOS timeoutType string (可选) Linux Windows - 通知的超时持续时间 可以是 'default' 或 'never'. replyPlaceholderstring (可选) 答复输入框中的占位符。 macOS sound string (可选) 显示通知时播放的声音文件的名称。 macOS urgency string (可选) Linux - 通知的紧急级别。 可以是 'normal', 'critical', 或者 'low' actions NotificationAction[] (可选) macOS - 要添加到通知中的操作 请阅读 NotificationAction文档来了解可用的操作和限制。 closeButtonText string (可选) macOS - 自定义关闭按钮提示内容。 空字符串将替换为默认的本地化文本。 toastXml string (可选) Windows - 自定义的窗口通知描述可取代上面所有属性。 提供完全自定义的设计和通知行为。 function (option){ const notification = new Notification({ ...option, title :option.title }) notification.show() } ","tags":[{"index":-1,"name":"Electron","slug":"6V806ttsC","used":true,"link":"https://qin_hu.gitee.io/blog/tag/6V806ttsC/"}],"title":"electron学习 - 主进程Electron示例","feature":"","link":"https://qin_hu.gitee.io/blog/post/electron-xue-xi-zhu-jin-cheng-electron-shi-li/","stats":{"text":"2 min read","time":92000,"words":373,"minutes":2},"date":"2024-01-17 15:42:52","dateFormat":"2024-01-17"},{"content":" 主进程和渲染进程通讯需要借助预加载脚本进行通讯，预加载脚本拥有主进程的部分权限。 App =&gt; preload =&gt; BrowserWindow BrowserWindow =&gt; preload =&gt; App 1. 渲染进程向主进程发消息 思路：预加载脚本中使用exposeInMainWorld创建函数，渲染进程调用这个函数并且发送值，在函数中调用ipcRenderer.send向主进程发送消息，主进程通过ipcMain.on接受预加载脚本 1-1. preload中新建通信函数 contextBridge.exposeInMainWorld('方法'，函数) contextBridge.exposeInMainWorld('electronApi', { setTitle: (title) =&gt; ipcRenderer.send('set-title', title) }) 详细写法： preload/index.ts import { contextBridge, ipcRenderer } from 'electron' import { electronAPI } from '@electron-toolkit/preload' const api = {} if (process.contextIsolated) { try { contextBridge.exposeInMainWorld('electron', electronAPI) contextBridge.exposeInMainWorld('api', api) // 向主进程发送消息 start contextBridge.exposeInMainWorld('electronApi', { setTitle: (title) =&gt; ipcRenderer.send('set-title', title) }) // end } catch (error) { console.error(error) } } else { // @ts-ignore (define in dts) window.electron = electronAPI // @ts-ignore (define in dts) window.api = api } 1-2. 渲染函数中调用预加载函数，并且传值 index.html // window.方法名（传的值） window.electronApi.setTitle(keyword.value) 1-3. 主进程接收值 // ipcMain.on('事件名') ipcMain.on('set-title',(event,title)=&gt;{ //获取当前窗口视图对象 const win=BrowserWindow.fromWebContents(event.sender) win?.setTitle(title) }) 2. 主进程向渲染器发送消息 将消息从主进程发送到渲染器进程时，需要指定是哪一个渲染器接收消息。 消息需要通过其 WebContents 实例发送到渲染器进程。 此 WebContents 实例包含一个 send 方法，其使用方式与 ipcRenderer.send 相同 计数器案例：使用 Electron 的 Menu 模块在主进程中构建一个自定义菜单,并给菜单添加点击事件 Menu // 构建一个自定义菜单 const menu = Menu.buildFromTemplate([ { label: '计数器', submenu: [ { click: () =&gt; mainWindow.webContents.send('update-counter', 1), label: '减少' }, { click: () =&gt; mainWindow.webContents.send('update-counter', -1), label: '新增' } ] } ]) Menu.setApplicationMenu(menu) 2-1. 使用 webContents 模块发送消息 请确保您为以下步骤加载了 index.html 和 preload.js 入口点！ click: () =&gt; mainWindow.webContents.send('update-counter', -1) 2-2. 通过预加载脚本暴露 ipcRenderer.on 向渲染层发送消息 preload/index.ts const { contextBridge, ipcRenderer } = require('electron') contextBridge.exposeInMainWorld('electronAPI', { onUpdateCounter: (callback) =&gt; ipcRenderer.on('update-counter', callback) }) 2-3. 渲染层接收值 index.html window.electronAPI.onUpdateCounter((_event, value) =&gt; { value == '-1' ? number.value-- : number.value++ console.log(value) }) 2-4. 渲染层回复主进程 通过 counter-value 通道将回复发送回主进程 渲染层发送 const counter = document.getElementById('counter') window.electronAPI.onUpdateCounter((event, value) =&gt; { const oldValue = Number(counter.innerText) const newValue = oldValue + value counter.innerText = newValue event.sender.send('counter-value', newValue)//使用event.sender送 }) 主进程中，监听 counter-value 事件 ipcMain.on('counter-value', (_event, value) =&gt; { console.log(value) // will print value to Node console }) 3. 渲染层到主进程双向传递 双向 IPC 的一个常见应用是从渲染器进程代码调用主进程模块并等待结果。 这可以通过将 ipcRenderer.invoke 与 ipcMain.handle 搭配使用来完成 案例：渲染层调用主进程去选择系统文件，系统文件将文件地址返给渲染层并且显示出来 3-1. 使用ipcMain.handle 监听事件 preload/index.ts contextBridge.exposeInMainWorld('electronAPIThree', { openFile: () =&gt; ipcRenderer.invoke('dialog:openFile') }) 3-2. 渲染层触发事件 const filePath = await window.electronAPIThree.openFile() fielUrl.value=filePath console.log('filePathfilePathfilePathfilePath', filePath) } 3-3. 主进程中接受事件 async function handleFileOpen () { const { canceled, filePaths } = await // 选择电脑的文件 dialog.showOpenDialog({}) if (!canceled) { return filePaths[0] } } import { app, shell, BrowserWindow, ipcMain, Menu, dialog } from 'electron' ipcMain.handle('dialog:openFile', handleFileOpen) ","tags":[{"index":-1,"name":"Electron","slug":"6V806ttsC","used":true,"link":"https://qin_hu.gitee.io/blog/tag/6V806ttsC/"}],"title":"elecrton学习 - 主进程和渲染进程通讯","feature":"","link":"https://qin_hu.gitee.io/blog/post/elecrton-xue-xi-zhu-jin-cheng-he-xuan-ran-jin-cheng-tong-xun/","stats":{"text":"4 min read","time":226000,"words":836,"minutes":4},"date":"2024-01-17 15:40:47","dateFormat":"2024-01-17"},{"content":"1. 判断操作系统 if(process.platform == 'darwin'){ console.log('这是mac系统'); } if(process.platform == 'win32'){ console.log('这是windows系统'); } if(process.platform == 'linux'){ console.log('这是linux系统'); } 2. 生命周期事件 具体分为App 事件、BrowserWindow 事件以及 Renderer 进程中的 Web 事件 2-1. app事件 2-2. BrowserWindow事件 const mainWindow = new BrowserWindow({ width: 450, height: 900, show: false, autoHideMenuBar: true, ...(process.platform === 'linux' ? { icon } : {}), webPreferences: { preload: join(__dirname, '../preload/index.js'), sandbox: false } }) // 页面即将显示时触发 - mainWindow.on('ready-to-show', () =&gt; { console.log(process.platform) mainWindow.show() }) // 页面显示时触发 mainWindow.on('show',()=&gt;{ console.log('show') }) // 页面隐藏时触发 mainWindow.on('hide',()=&gt;{ console.log('hide') }) // 页面最小化触发 mainWindow.on('minimize',()=&gt;{ console.log('minimize') }) // 调节页面大小时触发 mainWindow.on('resize',()=&gt;{ console.log('resize') }) 参考链接：https://developer.aliyun.com/article/792149 ","tags":[{"index":-1,"name":"Electron","slug":"6V806ttsC","used":true,"link":"https://qin_hu.gitee.io/blog/tag/6V806ttsC/"}],"title":"electron学习 - Electron生命周期和判断操作系统","feature":"","link":"https://qin_hu.gitee.io/blog/post/electron-xue-xi-electron-sheng-ming-zhou-qi-he-pan-duan-cao-zuo-xi-tong/","stats":{"text":"1 min read","time":56000,"words":191,"minutes":1},"date":"2024-01-17 15:39:59","dateFormat":"2024-01-17"},{"content":"1. Electron简介 Electron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入 Chromium 和 Node.js 到 二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux 2. 安装Electron 2-1. 安装淘宝镜像 npm install -g cnpm --registry=https://registry.npmmirror.com 2-2. 使用命令创建项目文件夹,并初始化nodeJs mkdir my-electron-app &amp;&amp; cd my-electron-app npm init 2-3. 下载Electron cnpm install electron --save-dev 3. 将网页显示在BrowserWindow，并且运行起来 3-1. 创建一个页面 在 Electron 中，每个窗口展示一个页面，后者可以来自本地的 HTML，也可以来自远程 URL。 在项目的根目录中创建一个index.html文件，并写入下面的内容： 3-2. 创建main.js入口文件来加载页面 // app，应用程序的事件生命周期。 // BrowserWindow，负责创建和管理应用窗口。 const { app, BrowserWindow } = require('electron') // 将可复用的函数写入实例化窗口 const createWindow = () =&gt; { const win = new BrowserWindow({ width: 800, height: 600 }) win.loadFile('index.html') } // 在应用准备就绪时调用函数 app.whenReady().then(() =&gt; { createWindow() }) 3-3. 添加运行命令 在 package.json 的 scripts 字段中添加一个 start 命令，内容为 electron .。 这个命令会告诉 Electron 在当前目录下寻找主脚本，并以开发模式运行它 { &quot;name&quot;: &quot;my-electron-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Hello World!&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: { &quot;start&quot;: &quot;electron .&quot;,//新增代码 &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;Jane Doe&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;devDependencies&quot;: { &quot;electron&quot;: &quot;23.1.3&quot; } } 在控制台执行npm run start启动项目 4. 管理页面的生命周期 4-1 关闭所有窗口时退出应用 (Windows &amp; Linux) 所有窗口关闭回调 /** * 关闭所有窗口时退出应用 * window&amp;lilux * */ app.on('window-all-closed', () =&gt; { console.log('退出应用啦') if (process.platform !== 'darwin') app.quit() }) 5. 使用electron-builder打包 5-1. 下载 npm install electron-builder --dev 5-2. package.json中配置 { &quot;name&quot;: &quot;electron_demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;electron .&quot;, //从这里配置打包命令 &quot;build:win&quot;: &quot;electron-builder --win --x64 --ia32&quot;, &quot;build:mac&quot;:&quot;electron-builder -mwl&quot;, &quot;build:linux&quot;:&quot;electron-builder --linux deb tar.xz&quot; }, //start 配置打包参数 &quot;build&quot;: { &quot;productName&quot;: &quot;electron-demo&quot;,// 安装包文件名 &quot;directories&quot;: { &quot;output&quot;: &quot;dist&quot;// // 安装包生成目录 }, &quot;nsis&quot;: { &quot;oneClick&quot;: false,// 是否一键安装 &quot;allowToChangeInstallationDirectory&quot;: true // 允许用户选择安装目录 }, &quot;mac&quot;: { &quot;category&quot;: &quot;your.app.category.type&quot;, &quot;target&quot;: [&quot;dmg&quot;,&quot;zip&quot;] }, &quot;win&quot;: { &quot;icon&quot;: &quot;build/icons/food.png&quot;, // 安装包图标，必须为 256 * 256 像素图片 &quot;target&quot;: [&quot;nsis&quot;,&quot;zip&quot;] } }, // end &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { &quot;@electron-forge/cli&quot;: &quot;^6.4.1&quot;, &quot;electron&quot;: &quot;^26.1.0&quot;, &quot;electron-builder&quot;: &quot;^24.6.4&quot; } } *6. 使用脚手架快速创建electron程序 使用electron-vite https://cn.electron-vite.org/ // 创建程序 npm create @quick-start/electron // 打包 npm run build 7. 使用脚手架快速创建与react和vue依赖的Electron程序 @quick-start/electron npm create @quick-start/electron ","tags":[{"index":-1,"name":"Electron","slug":"6V806ttsC","used":true,"link":"https://qin_hu.gitee.io/blog/tag/6V806ttsC/"}],"title":"electron学习 - 创建一个基本的Electron应用","feature":"","link":"https://qin_hu.gitee.io/blog/post/electron-xue-xi-chuang-jian-yi-ge-ji-ben-de-electron-ying-yong/","stats":{"text":"5 min read","time":249000,"words":856,"minutes":5},"date":"2024-01-17 15:37:45","dateFormat":"2024-01-17"},{"content":" ","tags":[{"index":-1,"name":"uniapp&taro","slug":"aUWAN2tZz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/aUWAN2tZz/"}],"title":"配置 - 微信小程序支付配置","feature":"","link":"https://qin_hu.gitee.io/blog/post/pei-zhi-wei-xin-xiao-cheng-xu-zhi-fu-pei-zhi/","stats":{"text":"0 min read","time":0,"words":0,"minutes":0},"date":"2024-01-15 13:58:05","dateFormat":"2024-01-15"},{"content":" uniapp提供了uni.addInterceptor(STRING, OBJECT)来拦截网络请求和路由跳转，可以根据情况来拦截路由，在页面初始化时加载拦截器 封装拦截器 common/interceptor.js export function navInterceptor() { let list = [&quot;navigateTo&quot;, &quot;redirectTo&quot;, &quot;reLaunch&quot;, &quot;switchTab&quot;, &quot;navigateBack&quot;]; list.forEach(item =&gt; { //用遍历的方式分别为,uni.navigateTo,uni.redirectTo,uni.reLaunch,uni.switchTab这4个路由方法添加拦截器 uni.addInterceptor(item, { invoke(e) { // 调用前拦截 //1. 当前页面如果为null return //2. 去掉query后的参数，拿到url地址 //2. 返回时页面栈小于2重定向到首页 //3. 检测token是否失效重定向到登陆页面 //@@@@这里写对象 const isHavePage = () =&gt; { //在首页? let pages = getCurrentPages(); return pages.length } const getUrl = (e) =&gt; { //获取地址 return e.url.split('?')[0]; } const isBackHome = (item) =&gt; { //返回时页面栈小于2? let pages = getCurrentPages(); if (item == 'navigateBack') { //返回时回到首页 return pages.length &lt; 2 } return false } const tokenOverdue = (token, tokenExpired) =&gt; { //tokenExpired传token到期日 if (!token) { //token不存在返回false return false } return (tokenExpired || 0) &lt; Date.now() } const inLoginPage = (u) =&gt; u.indexOf('/login/login') != -1 //判断是否登陆页 const inIndexPage = (u) =&gt; u == '/' || u.indexOf('/pages/index/index') != -1 //判断是否是首页 const tokenExpired = uni.getStorageSync('tokenExpired') const token = uni.getStorageSync('token') //@@@@这里执行逻辑 if (!isHavePage()) { return e } // 1. 当前页面如果为null return const url = getUrl(e) //2. 去掉query后的参数，拿到url地址 console.log(url) if (isBackHome(item)) { uni.reLaunch({ url: '/pages/index/index' }) return e } if (tokenOverdue(token, tokenExpired)) { //执行退出登陆logout uni.navigateTo({ url: &quot;/pages/login/login&quot; }) return e } return e }, fail(err) { // 失败回调拦截 console.log(err); uni.showModal({ content: JSON.stringify(err), showCancel: false }); } }) }) } export function reqInterceptor() { //请求拦截 uni.addInterceptor('request', { invoke(args) { // request 触发前拼接 请求数据 args.header = { Authorization: '11' } console.log(args) }, success(args) { // 请求成功后，修改code值为1 console.log(args) }, fail(err) { // console.log('interceptor-fail',err) }, complete(res) { // console.log('interceptor-complete',res) } }) } //取消拦截器 export function cancelInterceptor() { uni.removeInterceptor('request') let list = [&quot;navigateTo&quot;, &quot;redirectTo&quot;, &quot;reLaunch&quot;, &quot;switchTab&quot;, &quot;navigateBack&quot;]; list.forEach(item =&gt; { uni.removeInterceptor(item) }) } 全局使用拦截器 在App.vue的onLunch事件下使用 import {navInterceptor, reqInterceptor} from '@/common/interceptor.js' ... onLaunch: function() { console.log('App Launch') navInterceptor() reqInterceptor() }, ","tags":[{"index":-1,"name":"uniapp&taro","slug":"aUWAN2tZz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/aUWAN2tZz/"}],"title":"uniapp封装路由守卫，请求响应拦截器","feature":"","link":"https://qin_hu.gitee.io/blog/post/uniapp-feng-zhuang-lu-you-shou-wei-qing-qiu-xiang-ying-lan-jie-qi/","stats":{"text":"3 min read","time":152000,"words":517,"minutes":3},"date":"2024-01-15 13:49:29","dateFormat":"2024-01-15"},{"content":"1. 原因 在uniapp中发起一个网络请求使用的是uni.request()api,在网络请求时一般要处理网络错误处理，loading加载，判断api路径，这时候可以封装一个request请求。 2. 基本步骤 2-1. 封装api根路径地址，根据环境变化地址 2-1-1.小程序中封装根路径 common/baseUrl.js export default { //接口 api: function() { let version = wx.getAccountInfoSync().miniProgram.envVersion; switch (version) { case &quot;develop&quot;: //开发预览版 return &quot;https://www.baidu.com/&quot; break; case 'trial': //体验版 return &quot;https://www.baidu.com/&quot; break; case 'release': //正式版 return &quot;https://www.baidu.com/&quot; break; default: //未知,默认调用正式版 return &quot;http://www.baidu.com/&quot; break; } } 2-1-2.h5中封装根路径 export default { //接口 api: function() { let env = process.env.NODE_ENV switch (env) { case &quot;development&quot;: //生产环境 return &quot;https://www.baidu.com/&quot; break; ... default: //未知,默认调用正式版 return &quot;http://www.baidu.com/&quot; break; } } 2-2. 创建Request类 common/request.js import baseUrl from '../common/base.js' export default class Request { http(option) { // 请求参数 var url = option.url, method = option.method, header = {}, data = option.data || {}, token = option.token || &quot;&quot;, showLoading = option.showLoading; // 拼接请求路径 var requestUrl = baseUrl.api + url; //请求方式:GET或POST(POST需配置 // header: {'content-type' : &quot;application/x-www-form-urlencoded&quot;},) if (method) { method = method.toUpperCase(); //小写改为大写 if (method == &quot;POST&quot;) { header = { 'content-type': &quot;application/x-www-form-urlencoded&quot; }; } else { header = { 'content-type': &quot;application/json&quot; }; } } //...这里可以进行判断token操作 //加载圈 if (showLoading) { uni.showLoading({ title: '加载中...' }); } // 返回promise return new Promise((resolve, reject) =&gt; { // 请求 uni.request({ url: requestUrl, data: data, method: method, header: header, success: (res) =&gt; { // 判断 请求api 格式是否正确 if (res.statusCode &amp;&amp; res.statusCode != 200) { uni.showToast({ title: &quot;api错误&quot; + res.errMsg, icon: 'none' }); return; } // 将结果抛出 resolve(res.data) }, //请求失败 fail: (e) =&gt; { uni.showToast({ title: &quot;&quot; + e.data.msg, icon: 'none' }); resolve(e.data); }, //请求完成 complete() { //隐藏加载 if (showLoading) { uni.hideLoading(); } resolve(); return; } }) }) } } 2-3. 创建api模块，在模块中使用Request 假如有一个user Api模块，我们可以创建一个user.js文件,在文件中使用Request network/user.js import Request from '@/common/requset.js' let request = new Request().http // 按需引入的 请求头 export const getUserInfo= function(data) { return request({ url: &quot;order/user&quot;, method: &quot;POST&quot;, data, token: operate.isToken() }) } 2-4. 在页面中使用 //引入 import { getUserInfo } from '@/network/user.js' //放入生命周期 async init() { //用户信息 let res=await getUserInfo({ name:'禾耳' }) }, 参考连接 https://juejin.cn/post/7023983465892675614 https://uniapp.dcloud.net.cn/api/request/request.html ","tags":[{"index":-1,"name":"uniapp&taro","slug":"aUWAN2tZz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/aUWAN2tZz/"}],"title":"uniapp封装request请求","feature":"","link":"https://qin_hu.gitee.io/blog/post/uniapp-feng-zhuang-request-qing-qiu/","stats":{"text":"3 min read","time":176000,"words":594,"minutes":3},"date":"2024-01-15 13:48:40","dateFormat":"2024-01-15"},{"content":"1. 使用cli创建项目报错 ERROR Failed fetching remote preset dcloudio/uni-preset-vue 解决： https://blog.csdn.net/zmh_csdn/article/details/122231745 ","tags":[{"index":-1,"name":"uniapp&taro","slug":"aUWAN2tZz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/aUWAN2tZz/"}],"title":"uniapp问题","feature":"","link":"https://qin_hu.gitee.io/blog/post/uniapp-wen-ti/","stats":{"text":"1 min read","time":9000,"words":29,"minutes":1},"date":"2024-01-15 13:47:58","dateFormat":"2024-01-15"},{"content":"1. 简介 uniCloud 是 DCloud 联合阿里云、腾讯云，为开发者提供的基于 serverless 模式和 js 编程的云开发平台 关于serverless 基于node 自动的弹性扩容，按量收费 免域名使用，服务器 unicloud的三大部分 服务空间 数据库 云函数 三者关系:服务空间包括数据库和云函数，此处我们通过云函数处理逻辑。 我们通过uniapp调用云函数来处理相关逻辑。 2. 新建项目 2-1.uniCloud进行实名认证，新建一个服务空间 新用户可以创建一个免费云服务空间。 2-2.新建uniapp项目，管理云服务空间 打开hbuilderx新建一个uniapp项目，在此之前要先完成uniCloud的实名认证 确认应用的应用标识appleID已经获取 3. 关联云服务空间 登录hbuilderX,右击uniCloud文件夹选&quot;关联云服务空间或项目&quot; 4. 创建云函数 选择uniCloud/cloudfunctions右击选择创建云函数 会自动生成一个云函数文件夹，index.js示例 'use strict'; exports.main = async (event, context) =&gt; { //event为客户端上传的参数 console.log('event : ', event) //返回数据给客户端 return event }; 上传云函数到云服务空间 web端云函数列表查看是否有云函数出现 5. 在本地调用云函数 语法: // promise方式 uniCloud.callFunction({ name: 'hellocf', data: { a: 1 } }) .then(res =&gt; {}); // callback方式 uniCloud.callFunction({ name: 'hellocf', data: { a: 1 }, success(){}, fail(){}, complete(){} }); 示例 pages/index/index.vue &lt;script&gt; export default { data() { return { title: 'Hello' } }, onLoad() { uniCloud.callFunction({ name: &quot;heer-test&quot;, data: { name: &quot;测试地址&quot; } }).then(res =&gt; { console.log(res) }) }, methods: { } } &lt;/script&gt; cloudfunctions/heer-test/index.js 'use strict'; exports.main = async (event, context) =&gt; { //event为客户端上传的参数 console.log('event : ', event) //返回数据给客户端 return event }; 在浏览器查看返回值 注意：每次修改云函数，都需要上传 6. 云数据库 6-1. 在web控制台创建一个新表 数据库表 ： 数据，索引，表结构 6-2. 在HBuilderX中编写schema约束表字段 创建schema 在uniCloud项目右键，选择创建database目录（如已有目录则忽略） 在 database 目录右键选择新建数据集合schema 假如我有resume表，即新建的resume.schema.json { &quot;bsonType&quot;: &quot;object&quot;, &quot;required&quot;: [&quot;name&quot;, &quot;birth_year&quot;, &quot;tel&quot;, &quot;email&quot;], &quot;permission&quot;: {//数据库操作权限 &quot;read&quot;: true, &quot;create&quot;: true, &quot;update&quot;: true, &quot;delete&quot;: true }, &quot;properties&quot;: {//字段类型 &quot;_id&quot;: { &quot;description&quot;: &quot;ID，系统自动生成&quot; }, &quot;name&quot;: { &quot;bsonType&quot;: &quot;string&quot;, &quot;title&quot;: &quot;姓名&quot;, &quot;trim&quot;: &quot;both&quot;, &quot;minLength&quot;: 2, &quot;maxLength&quot;: 17 }, &quot;birth_year&quot;: { &quot;bsonType&quot;: &quot;int&quot;, &quot;title&quot;: &quot;出生年份&quot;, &quot;minimum&quot;: 1950, &quot;maximum&quot;: 2020 }, &quot;tel&quot;: { &quot;bsonType&quot;: &quot;string&quot;, &quot;title&quot;: &quot;手机号码&quot;, &quot;pattern&quot;: &quot;^\\\\+?[0-9-]{3,20}$&quot;, &quot;trim&quot;: &quot;both&quot; }, &quot;email&quot;: { &quot;bsonType&quot;: &quot;string&quot;, &quot;title&quot;: &quot;email&quot;, &quot;format&quot;: &quot;email&quot;, &quot;trim&quot;: &quot;both&quot; }, &quot;address&quot;: { &quot;bsonType&quot;: &quot;object&quot;, &quot;title&quot;: &quot;地址&quot;, &quot;required&quot;: [&quot;city&quot;], &quot;properties&quot;: { &quot;city&quot;: { &quot;bsonType&quot;: &quot;string&quot;, &quot;title&quot;: &quot;城市&quot; }, &quot;street&quot;: { &quot;bsonType&quot;: &quot;string&quot;, &quot;title&quot;: &quot;街道&quot;, &quot;trim&quot;: &quot;both&quot; } } }, &quot;intro&quot;:{ &quot;bsonType&quot;: &quot;string&quot;, &quot;title&quot;: &quot;简介&quot;, &quot;trim&quot;: &quot;both&quot; } } } schema新建和保存时不会自动上传也不会自动下载，此时需要更新schema 上传schema database目录右键可以上传全部schema / Ctrl+u 下载schema database目录右键可以下载所有schema及扩展校验函数 6-3. 索引 索引有两个用途： 在集合中为查询条件的字段建立索引，是保证数据库性能、提升用户体验的重要手段。 索引可以控制字段中各记录的唯一性。比如某字段被设为唯一索引，则这个字段在整个数据记录集合中的值不会有重复。如果是普通唯一索引，则意味着该字段不能为null。如果是稀疏索引，则代表可以为null，但不为null的值不能重复。 详细使用：https://uniapp.dcloud.net.cn/uniCloud/db-index.html 7. 数据库的增删改查操作（JQL） JQL简介 JQL，全称 javascript query language，是一种js方式操作数据库的规范。 连接数据库 //对数据库的对象获取 const db = uniCloud.database() // 对mydatabase数据库的获取 const collection = db.collection('mydatabase') 新增操作 先连接数据库再进行操作 connection.add(data) 示例 新建一个添加云函数方法 // 新增操作 'use strict'; const db = uniCloud.database() exports.main = async (event, context) =&gt; { //event为客户端上传的参数 console.log('event : ', event) const collection = db.collection(&quot;todolist&quot;) let data = [{ _id: Math.random().toString().slice(2), msg: &quot;你好啊&quot;, label: &quot;js&quot; }, { _id: Math.random().toString().slice(2), msg: &quot;heihei&quot;, label: &quot;html&quot; } ] let res = await collection.add(data) //返回数据给客户端 return { code: 200, message: 'ok', data: res } }; 本地运行云函数后在web控制台查看新增的数据。 删除操作 collection.doc('id字段').remove() 示例 'use strict'; const db = uniCloud.database() exports.main = async (event, context) =&gt; { //event为客户端上传的参数 const collection = db.collection(&quot;todolist&quot;) console.log('event : ', event) let id=&quot;2260189312153693&quot; let res=await collection.doc(id).remove() //返回数据给客户端 return { code: 200, message: 'ok', data: res } }; 修改数据 需求: 将id字段为11016100222286762的msg字段改为“嘿嘿嘿” collection.doc('id字段').update(修改的数据) 'use strict'; const db = uniCloud.database() exports.main = async (event, context) =&gt; { const collection = db.collection(&quot;todolist&quot;) //event为客户端上传的参数 console.log('event : ', event) const data = { msg: '嘿嘿嘿' } let id = '11016100222286762' let res = await collection.doc(id).update(data) console.log(JSON.stringify(res)) //返回数据给客户端 return { code: 200, message: 'ok', data: res } }; 更新数据 collection.doc(更新数据id).set(更新数据) 'use strict'; const db = uniCloud.database() exports.main = async (event, context) =&gt; { const collection = db.collection(&quot;todolist&quot;) //event为客户端上传的参数 console.log('event : ', event) let res=await collection.doc(&quot;11016100222286762&quot;).set({ label:&quot;js&quot;, msg:&quot;heihei&quot; }) //返回数据给客户端 return { msg:&quot;ok&quot;, code:200, data:res } }; 查询数据 collection.where(查询条件).get() 'use strict'; const db = uniCloud.database() exports.main = async (event, context) =&gt; { //event为客户端上传的参数 console.log('event : ', event) const collection = db.collection(&quot;todolist&quot;) let res = await collection.where({ _id: &quot;11016100222286762&quot; }).get() console.log(JSON.stringify(res)) //返回数据给客户端 return { msg: 'ok', code: 200, data: res } }; 8. 参考链接 https://uniapp.dcloud.net.cn/uniCloud/schema.html ","tags":[{"index":-1,"name":"uniapp&taro","slug":"aUWAN2tZz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/aUWAN2tZz/"}],"title":"unicloud基本使用","feature":"","link":"https://qin_hu.gitee.io/blog/post/unicloud-ji-ben-shi-yong/","stats":{"text":"8 min read","time":443000,"words":1606,"minutes":8},"date":"2024-01-15 13:42:10","dateFormat":"2024-01-15"},{"content":"1.注意事项 在uniapp使用webview嵌入自己的html需在\\hybrid\\html下面包括资源文件js等都需要放入同等该目录下 webvew默认全屏 比如我们想半屏嵌入我们的直播插件，等等虽然官方有fullscreen属性设置但是在app端仍有不支持 解决方案 onReady() { // #ifdef APP-PLUS var currentWebview = this.$scope.$getAppWebview() //此对象相当于html5plus里的plus.webview.currentWebview()。在uni-app里vue页面直接使用plus.webview.currentWebview()无效 setTimeout(function() { wv = currentWebview.children()[0] this.wv = currentWebview.children()[0] wv.setStyle({top:60,height:320}) }, 1000); //如果是页面初始化调用时，需要延时一下 // #endif } 2.初始化webview 2-1. 在项目中创建hybrid目录和html项目文件 local.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;测试uniapp的webview和APP之间的通信&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;title&quot;&gt;这个是hybrid下的html页面哦！&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;!-- 引入uniapp的SDK (必须引用)--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;common/uni-webview.js&quot;&gt; &lt;/script&gt; &lt;!-- 引入vue方法--&gt; &lt;script src=&quot;common/vue@2.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;js/index.js&quot;&gt;&lt;/script&gt; --&gt; &lt;/html&gt; 依赖文件 &lt;!-- 引入uniapp的SDK (必须引用)--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://js.cdn.aliyun.dcloud.net.cn/dev/uni-app/uni.webview.1.5.2.js&quot;&gt; &lt;/script&gt; &lt;!-- 引入vue方法--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; 2-2.uniapp页面中使用web-view引入local.html &lt;template&gt; &lt;view&gt; &lt;web-view src=&quot;/hybrid/html/local.html&quot;&gt;&lt;/web-view&gt; &lt;!-- &lt;web-view src=&quot;https://www.baidu.com&quot;&gt;&lt;/web-view&gt; --&gt; &lt;/view&gt; &lt;/template&gt; 3.web-view页面向uniapp页面发送数据 3-1.local.html页面发送 ... &lt;script type=&quot;text/javascript&quot;&gt; // 在引用依赖的文件后，需要在 HTML 中监听 UniAppJSBridgeReady 事件触发后，才能安全调用 uni 的 API。 document.addEventListener('UniAppJSBridgeReady', function() { uni.getEnv(function(res) { console.log('获取当前环境：' + JSON.stringify(res)); }); // 向APP发送消息 （注意看这里 01） uni.postMessage({ data: { name: 'polly', age: '18' } }); }); &lt;/script&gt; ... 3-2.uniapp页面接收 绑定事件 &lt;web-view src=&quot;/hybrid/html/local.html&quot; ref=&quot;webview&quot; @message=&quot;handleMessage&quot;&gt;&lt;/web-view&gt; h5端接收 onLoad() { //h5接收消息 // #ifdef H5 window.addEventListener('message', e =&gt; { console.log(e.data, '接收h5页面发来的消息') // this.webV = e.source // window的对象 // 接收Html发送过来的消息 (H端) 控制台打印看结果 // console.log(e.data.data.arg, '接收h5页面发来的消息'); }, false) // #endif //app端接收消息 }, app端接收 methods: { //app端接收消息 // #ifdef APP-PLUS // 接收Html发送过来的消息 (APP端) 手机真机测试看打印结果 handleMessage(evt) { console.log(evt); console.log('接收Html发送过来的消息：' + JSON.stringify(evt.detail.data[0])); }, // #endif } 4.uniapp页面向webview发送数据 4-1.使用webview对象节点 4-1-1.uniapp页面初始化webview对象节点 ... data() { return { wv: null, // 定义(app)webview对象节点 webV: {}, // 定义(H5)webview对象节点 sendData: [{ //准备发送的数据 msg: 'ok' }] } }, ... onLoad() { // 1.web节点初始化---------- // App端 // #ifdef APP-PLUS // 页面栈最顶层就是当前webview let currentWebview = this.$scope.$getAppWebview(); setTimeout(() =&gt; { this.wv = currentWebview.children()[0] }, 1000) setTimeout(() =&gt; { this.sendRequestData(this.sendData, 0) //0代表app端 }, 1100) // #endif //----------------- // H5端 // #ifdef H5 window.addEventListener('message', e =&gt; { this.webV = e.source // window的对象 console.log(e.data, '接收h5页面发来的消息'); // 接收h5页面发来的消息(11) ====&gt;H5端 }, false) setTimeout(() =&gt; { this.sendRequestData(this.sendData, 1) //1代表h5端 }, 1000) // #endif }, 4-1-2.uniapp绑定sendRequestData事件发送数据 methods: { sendRequestData(res, plt) { //发送 let param = JSON.stringify(res) console.log(param); if (plt == 1) {//h5 this.webV.postMessage({ type: 'new', data: param }) } else {//app this.wv.evalJS(`requestData(${param})`); } } } 4-1-3.local.html页面接收数据 &lt;script type=&quot;text/javascript&quot;&gt; // HTML 接受APP发送过来的消息 (H5端) window.addEventListener('message', e =&gt; { console.log(e, 'HTML 接受APP发送过来的消息 (H5端)'); }, false) // HTML 接受APP发送过来的消息 (APP端) function requestData(data) { console.log(JSON.stringify(data), 'HTML 接受APP发送过来的消息 (APP端)'); } &lt;/script&gt; 4-2.通过url路径传递 4-2-1.uniapp页面添加路径参数 ... &lt;view&gt; &lt;web-view :src=&quot;url&quot; ref=&quot;webview&quot; @message=&quot;handleMessage&quot;&gt;&lt;/web-view&gt; &lt;!-- &lt;web-view src=&quot;https://www.baidu.com&quot;&gt;&lt;/web-view&gt; --&gt; &lt;/view&gt; ... data() { return { wv: null, // 定义(app)webview对象节点 webV: {}, // 定义(H5)webview对象节点 sendData: [{ msg: 'ok' }], url:`/hybrid/html/local.html` } }, onLoad() { //通过url传递 this.url=`/hybrid/html/local.html?data=${encodeURIComponent(JSON.stringify(this.sendData))}` }, 4-2-2.local.html页面接收 /hybrid/html/js/index.js //获取路径参数方法 function getQuery(name) { // 正则：[找寻'&amp;' + 'url参数名字' = '值' + '&amp;']（'&amp;'可以不存在） let reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); let r = window.location.search.substr(1).match(reg); console.log(r) if (r != null) { // 对参数值进行解码 return JSON.parse(decodeURIComponent(r[2])); } return null; } ... //获取参数 mounted() { //取url中的参数值 console.log(getQuery('data')); //获取 uni-app 传来的值 }, 5.相关代码 5-1. local.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;测试uniapp的webview和APP之间的通信&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;title&quot;&gt;{{textTip}}&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;!-- 引入uniapp的SDK (必须引用)--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;common/uni-webview.js&quot;&gt; &lt;/script&gt; &lt;!-- 引入vue方法--&gt; &lt;script src=&quot;common/vue@2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/index.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 在引用依赖的文件后，需要在 HTML 中监听 UniAppJSBridgeReady 事件触发后，才能安全调用 uni 的 API。 document.addEventListener('UniAppJSBridgeReady', function() { uni.getEnv(function(res) { console.log('获取当前环境：' + JSON.stringify(res)); }); // 向APP发送消息 （注意看这里 01） uni.postMessage({ data: { name: 'polly', age: '18' } }); }); // HTML 接受APP发送过来的消息 (H5端) window.addEventListener('message', e =&gt; { console.log(e, 'HTML 接受APP发送过来的消息 (H5端)'); }, false) // HTML 接受APP发送过来的消息 (APP端) function requestData(data) { console.log(JSON.stringify(data), 'HTML 接受APP发送过来的消息 (APP端)'); } &lt;/script&gt; &lt;/html&gt; 5-2. /hybrid/html/js/index.js var app = new Vue({ el: '#app', data: { textTip:&quot;提示信息&quot;, dataList:[] }, mounted() { }, onLoad() { }, onShow() { }, methods: { } }) 5-3. uniapp下的页面 &lt;template&gt; &lt;view&gt; &lt;web-view src=&quot;/hybrid/html/local.html&quot; ref=&quot;webview&quot; @message=&quot;handleMessage&quot;&gt;&lt;/web-view&gt; &lt;!-- &lt;web-view src=&quot;https://www.baidu.com&quot;&gt;&lt;/web-view&gt; --&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; var wv; //计划创建的webview export default { data() { return { wv: null, // 定义(app)webview对象节点 webV: {}, // 定义(H5)webview对象节点 sendData: [{ msg: 'ok' }] } }, onLoad() { // 1.web节点初始化---------- // App端 // #ifdef APP-PLUS // 页面栈最顶层就是当前webview let currentWebview = this.$scope.$getAppWebview(); setTimeout(() =&gt; { this.wv = currentWebview.children()[0] }, 1000) setTimeout(() =&gt; { this.sendRequestData(this.sendData, 0) //0代表app端 }, 1100) // #endif //----------------- // H5端 // #ifdef H5 window.addEventListener('message', e =&gt; { this.webV = e.source // window的对象 console.log(e.data, '接收h5页面发来的消息'); // 接收h5页面发来的消息(11) ====&gt;H5端 }, false) setTimeout(() =&gt; { this.sendRequestData(this.sendData, 1) //1代表h5端 }, 1000) // #endif }, onReady() { // #ifdef APP-PLUS var currentWebview = this.$scope .$getAppWebview() //此对象相当于html5plus里的plus.webview.currentWebview()。在uni-app里vue页面直接使用plus.webview.currentWebview()无效 setTimeout(function() { wv = currentWebview.children()[0] wv.setStyle({ top: 150, height: 300 }) }, 1000); //如果是页面初始化调用时，需要延时一下 // #endif }, methods: { // #ifdef APP-PLUS // 接收Html发送过来的消息 (APP端) 手机真机测试看打印结果 handleMessage(evt) { console.log(evt); console.log('接收Html发送过来的消息：' + JSON.stringify(evt.detail.data[0])); }, // #endif sendRequestData(res, plt) { //发送 let param = JSON.stringify(res) console.log(param); if (plt == 1) {//h5 this.webV.postMessage({ type: 'new', data: param }) } else {//app this.wv.evalJS(`requestData(${param})`); } } } }; &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 6. 一些技巧 6-1.使用window对象传递数据 在uniapp页面给webview页面传递数据时，可以使用webview层的window对象绑定一个函数，在uniapp页面通过触发这个函数来发送数据 uniapp页面拿到webview页面对象 onLoad(){ window.addEventListener('message', e =&gt; { this.webV = e.source // window的对象 }, false) }, methods:{ this.webV.updateLang() //ok 触发webview的window事件 } watch:{ webV:{ handler(newV, oldV) { if (oldV === null &amp;&amp; newV) { this.init() //做对webview页面 的初始化操作 } }, immediate: true } } 在webview页面中绑定事件 function updateLang(){ console.log('ok') } 7.学习链接 https://blog.csdn.net/qq_41556539/article/details/121695180 end","tags":[{"index":-1,"name":"uniapp&taro","slug":"aUWAN2tZz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/aUWAN2tZz/"}],"title":"uniapp中使用webView","feature":"","link":"https://qin_hu.gitee.io/blog/post/uniapp-zhong-shi-yong-webview/","stats":{"text":"11 min read","time":651000,"words":2153,"minutes":11},"date":"2024-01-15 13:40:50","dateFormat":"2024-01-15"},{"content":"1.概念 运行在视图层的js，只支持app-vue和h5（简单来说就是开了另外一条线程） 2.作用 大幅降低逻辑层和视图层的通讯损耗，提供高性能视图交互能力（减少通讯损耗提升性能，例如一些手势或canvas动画的场景） 大幅降低逻辑层和视图层的通讯损耗，提供高性能视图交互能力（减少通讯损耗提升性能，例如一些手势或canvas动画的场景） 3.基本使用 在原先的script标签的同级新增一个script，设置lang=renderjs，module=(值任意，相当于命名空间，之后会根据这个名字调用其中的方法) 在template中使用一开始给renderjs的命名加.的方式调用其中的方法 &lt;template&gt; &lt;view&gt; &lt;button @tap=&quot;test.handleClick&quot;&gt;点击&lt;/button&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { // 原先的script，这里被称为service层 } &lt;/script&gt; &lt;script lang=&quot;renderjs&quot; module=&quot;test&quot;&gt; export default { data() { return {} }, methods: { handleClick(event, ownerInstance) { // event是事件对象 // ownerInstance和this.$ownerInstance是一样的，用来调用service层的方法 console.log('点击了按钮') } }, created() { console.log('renderjs初始化完毕') } } &lt;/script&gt; 4.renderjs和service层的通信 从renderjs到service层：通过this.$ownerInstance.callMethod()方法可以调用service中的方法，第一个参数是方法名，第二个参数是传过去的参数 &lt;template&gt; &lt;view&gt; &lt;button @tap=&quot;test.onClick&quot;&gt;点击&lt;/button&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { acceptDataFromRenderjs(data) { console.log('从renderjs中接收到的数据', data) } } } &lt;/script&gt; &lt;script lang=&quot;renderjs&quot; module=&quot;test&quot;&gt; export default { data() { return {} }, methods: { onClick(event, ownerInstance) { ownerInstance.callMethod('acceptDataFromRenderjs', { content: '测试文字' }) // 或this.$ownerInstance.callMethod('acceptDataFromRenderjs', { content: '测试文字' }) // 需要注意的是：只有通过在template中用户手动操作触发renderjs的方法参数是这两个：event, ownerInstance； // 通过其他方法触发的函数参数不一样，后面会说 } } } &lt;/script&gt; 5.从service层到renderjs 首先在template中绑定一个service中定义的值，然后在同样的位置增加:change:(属性名)=(触发的方法)来实现通信。 &lt;template&gt; &lt;view&gt; // prop是个名字，可以随意改，注意:change:[name]这两个名字需要相同就行了 &lt;text :prop=&quot;options&quot; :change:prop=&quot;test.onChange&quot;&gt;无内容&lt;/text&gt; &lt;button @tap=&quot;changeOptionFn&quot;&gt;点击修改options&lt;/button&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { options: { // 这里存放准备传递给renderjs的数据 token: null, num: 1 } } }, methods: { changeOptionFn() { this.options = { // 这个地方我用时间戳来修改token，用于触发change，实际需要传递的数据是num token: Date.now(), num: Math.random() } } } } &lt;/script&gt; &lt;script lang=&quot;renderjs&quot; module=&quot;test&quot;&gt; export default { methods: { onChange(newValue, oldValue, ownerInstance, instance) { console.log('service层中的options发生变化') console.log('新值', newValue) console.log('旧值', oldValue) // ownerInstance和this.$ownerInstance一样，可用来向service层通信 // instance和ownerInstance的区别是： // instance.$el指向的是触发事件的那个节点；ownerInstance.$el指向当前vue文件中的根节点； // instance的作用目前尚不明确，官方没有给出用法 } } } &lt;/script&gt; 学习链接--稀土掘金--作者：小周小周万事无忧 ","tags":[{"index":-1,"name":"uniapp&taro","slug":"aUWAN2tZz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/aUWAN2tZz/"}],"title":"renderJs基本使用","feature":"","link":"https://qin_hu.gitee.io/blog/post/renderjs-ji-ben-shi-yong/","stats":{"text":"4 min read","time":208000,"words":806,"minutes":4},"date":"2024-01-15 13:38:43","dateFormat":"2024-01-15"},{"content":"1.截屏保存到本地 const toShare=()=&gt;{ var pages = getCurrentPages(); var page = pages[pages.length - 1]; var ws = page.$getAppWebview(); // console.log(currentWebview.id);//获得当前webview的id // console.log(currentWebview.isVisible());//查询当前webview是否可见 var bitmap = null; bitmap = new plus.nativeObj.Bitmap('test'); // 将webview内容绘制到Bitmap对象中 uni.showLoading({ // title: '加载中' }); ws.draw(bitmap, function() { var bitmaps = plus.nativeObj.Bitmap.getItems();; bitmap.save(&quot;_doc/a.jpg&quot;, {}, function(i) { uni.saveImageToPhotosAlbum({ filePath: i.target, success: function() { bitmap.clear(); setTimeout(() =&gt; { uni.hideLoading(); uni.showToast({ title: &quot;截屏成功&quot;, icon: &quot;none&quot; }); }, 2000) }, }) }, function(e) { console.log('保存图片失败：' + JSON.stringify(e)); }); }, function(e) { console.log('截屏绘制图片失败：' + JSON.stringify(e)); }, { check: true, // 设置为检测白屏 clip: { top: '0', left: '0', height: '100%', width: '100%' } //设置截屏区域 }); } 2.发送信息，打电话，发邮箱，兼容ios contact(obj) { let osName = '' uni.getSystemInfo({ success: function(res) { osName = res.osName } }) if (!obj.value.length) { return } if (obj.label == 'phone') { window.location.href = `tel://${obj.value}` } if (obj.label == 'sms') { if (osName == 'ios') { window.location.href = `sms:/open?addresses=${obj.value}` } else { window.location.href = `sms:${obj.value}` } } if (obj.label == 'msg') { window.location.href = `mailto:${obj.value}` } }, 3.点击复制 copy(text) { uni.setClipboardData({ data: String(text), success: function() { uni.showToast({ title: &quot;copy success&quot;, icon: &quot;none&quot; }) }, }); } 4.使用定时器 let timer=null ... onShow() { this.loadData() // clearInterval(timer) if (timer == null) { timer = setInterval(() =&gt; { ... }, 5000) console.log(&quot;onshow&quot;, timer) } }, onHide() { console.log(&quot;onhide&quot;, timer) if (timer) { clearInterval(timer) timer = null } }, ... 5.设置tabbar中间按钮 实现 在page.json找到tabBar配置项，使用tabBar的midButton属性配置。 &quot;tabBar&quot;: { &quot;color&quot;: &quot;#BBBBBB&quot;, &quot;selectedColor&quot;: &quot;#2F86F6&quot;, &quot;borderStyle&quot;: &quot;black&quot;, &quot;backgroundColor&quot;: &quot;#FFFFFF&quot;, &quot;midButton&quot;:{ //这里是配置项 &quot;iconPath&quot;: &quot;static/tabbar/mid.png&quot;, &quot;iconWidth&quot;: &quot;40px&quot;, &quot;iconHeight&quot;:&quot;75px&quot;, &quot;text&quot;: &quot;&quot; }, &quot;list&quot;: [ { &quot;pagePath&quot;: &quot;pages/wallet/wallet&quot;, &quot;iconPath&quot;: &quot;static/tabbar/tab_wallet.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tabbar/user_1.png&quot;, &quot;text&quot;: &quot;&quot; }, { &quot;pagePath&quot;: &quot;pages/information/information&quot;, &quot;iconPath&quot;: &quot;static/tabbar/tab_msg.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tabbar/user_1.png&quot;, &quot;text&quot;: &quot;&quot; } ] midButton属性有一个缺点，不能配置path路径。此时有一个问题，我们不能在初始化时就显示中间midButton对应的页面。 解决方案：在tabBar.list属性中配置好index页面路径，然后使用visible属性将 index 页面的tabbar隐藏，此时只需要配置好midButton的icon图标就好了。 &quot;tabBar&quot;: { &quot;color&quot;: &quot;#BBBBBB&quot;, &quot;selectedColor&quot;: &quot;#2F86F6&quot;, &quot;borderStyle&quot;: &quot;black&quot;, &quot;backgroundColor&quot;: &quot;#FFFFFF&quot;, &quot;midButton&quot;:{ &quot;iconPath&quot;: &quot;static/tabbar/mid.png&quot;, &quot;iconWidth&quot;: &quot;40px&quot;, &quot;iconHeight&quot;:&quot;75px&quot;, &quot;text&quot;: &quot;&quot; }, &quot;list&quot;: [ // @添加内容 { &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;iconPath&quot;: &quot;static/tabbar/ic_house.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tabbar/ic_house_active.png&quot;, &quot;text&quot;: &quot;&quot;, &quot;visible&quot;:false }, // { &quot;pagePath&quot;: &quot;pages/wallet/wallet&quot;, &quot;iconPath&quot;: &quot;static/tabbar/tab_wallet.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tabbar/user_1.png&quot;, &quot;text&quot;: &quot;&quot; }, { &quot;pagePath&quot;: &quot;pages/information/information&quot;, &quot;iconPath&quot;: &quot;static/tabbar/tab_msg.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tabbar/user_1.png&quot;, &quot;text&quot;: &quot;&quot; } ] }, 还需要配置一下初始页面，在app.vue中onLunch方法下配置 onLaunch: function() { ... //指定初始化页面 uni.switchTab({ url: `/pages/index/index` }) }, 最后在app.vue页面监听midButton按钮的点击事件，实现tabbar页面的切换 注意使用uni.switchTab()方法实现tabbar切换 mounted() { uni.onTabBarMidButtonTap(() =&gt; { uni.switchTab({ url: `/pages/index/index` }) }) }, 总结 配置midButton属性 在tabBar.list属性中配置midButton对应的页面，并将visible属性设置成false 配置初始页面（可选） 监听midButton按钮的点击事件 6. 动态修改tabbar onShow() { let tabBarOptions = { &quot;index&quot;: 1, //要修改的下标 &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;iconPath&quot;: &quot;static/tabbar/tab-minin.png&quot;, &quot;selectedIconPath&quot;: &quot;&quot;, &quot;text&quot;: &quot;&quot; }; //uniapp的api，传入上面写好的对象 uni.setTabBarItem(tabBarOptions); }, 7. 使用pages的visible属性动态修改pagePath pages.json 在tabBar中配置好要显示的页面，将动态隐藏的visible值设置成false ... &quot;tabBar&quot;: { &quot;color&quot;: &quot;#BBBBBB&quot;, &quot;selectedColor&quot;: &quot;#2F86F6&quot;, &quot;borderStyle&quot;: &quot;black&quot;, &quot;backgroundColor&quot;: &quot;#FFFFFF&quot;, &quot;midButton&quot;: { &quot;iconPath&quot;: &quot;static/tabbar/mid.png&quot;, &quot;iconWidth&quot;: &quot;79rpx&quot;, &quot;iconHeight&quot;: &quot;79rpx&quot;, &quot;text&quot;: &quot;&quot; }, &quot;list&quot;: [ { &quot;pagePath&quot;: &quot;pages/activity/mining&quot;,//跳转到矿机页面 &quot;iconPath&quot;: &quot;static/tabbar/ic-minin.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tabbar/ic_house_active.png&quot;, &quot;text&quot;: &quot;&quot;, &quot;visible&quot;: false }, { &quot;pagePath&quot;: &quot;pages/index/index&quot;, //跳转到首页 &quot;iconPath&quot;: &quot;static/tabbar/tab-minin.png&quot;,//ic_mine, &quot;selectedIconPath&quot;: &quot;&quot;, &quot;text&quot;: &quot;&quot;, &quot;visible&quot;: true }, { &quot;pagePath&quot;: &quot;pages/wallet/wallet&quot;, &quot;iconPath&quot;: &quot;static/tabbar/tab-car.png&quot;, &quot;selectedIconPath&quot;: &quot;&quot;, &quot;text&quot;: &quot;&quot; } ] }, ... 在onShow中动态修改visible uni.setTabBarItem({ &quot;index&quot;: 1, //要修改的下标 &quot;visible&quot;: false }); uni.setTabBarItem({ &quot;index&quot;: 0, //要修改的下标 &quot;visible&quot;: true }); 8. 获取当前页面route信息 let pages = getCurrentPages() let page = pages[pages.length - 1] console.log(page.route) 9. 给body添加动态属性，方便全局添加css if (window.tronLink &amp;&amp; this.$isMobile()) { //移动tabbar const bodyDom = document.querySelector('body') bodyDom.setAttribute(&quot;bottom-move&quot;,'') } 10. page.json基本配置 { &quot;easycom&quot;: { &quot;^u-(.*)&quot;: &quot;uview-ui/components/u-$1/u-$1.vue&quot; }, &quot;pages&quot;: [ { &quot;path&quot;: &quot;pages/home/index&quot;, &quot;style&quot;: { &quot;enablePullDownRefresh&quot;: false } }, { &quot;path&quot;: &quot;pages/ucenter/login-page/index/login-guidance&quot;, &quot;style&quot;: { &quot;navigationBarTitleText&quot;: &quot;&quot;, &quot;enablePullDownRefresh&quot;: false } }, { &quot;path&quot;: &quot;pages/uni-agree/uni-agree&quot;, &quot;style&quot;: { &quot;navigationStyle&quot;: &quot;custom&quot;, &quot;app-plus&quot;: { &quot;popGesture&quot;: &quot;none&quot; } } }, { &quot;path&quot;: &quot;uni_modules/uni-upgrade-center-app/pages/upgrade-popup&quot;, &quot;style&quot;: { &quot;disableScroll&quot;: true, &quot;app-plus&quot;: { &quot;backgroundColorTop&quot;: &quot;transparent&quot;, &quot;background&quot;: &quot;transparent&quot;, &quot;titleNView&quot;: false, &quot;scrollIndicator&quot;: false, &quot;popGesture&quot;: &quot;none&quot;, &quot;animationType&quot;: &quot;fade-in&quot;, &quot;animationDuration&quot;: 200 } } } ], &quot;globalStyle&quot;: { &quot;navigationBarTextStyle&quot;: &quot;white&quot;, &quot;navigationBarTitleText&quot;: &quot;IEARN BOT&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#02B2D6&quot;, // &quot;backgroundColor&quot;: &quot;#02B2D6&quot;, &quot;enablePullDownRefresh&quot;: false, //#ifdef H5 &quot;rpxCalcMaxDeviceWidth&quot;: 500, //#endif &quot;navigationStyle&quot;: &quot;custom&quot; }, &quot;tabBar&quot;: { &quot;color&quot;: &quot;#BBBBBB&quot;, &quot;selectedColor&quot;: &quot;#2F86F6&quot;, &quot;borderStyle&quot;: &quot;black&quot;, &quot;backgroundColor&quot;: &quot;#FFFFFF&quot;, &quot;list&quot;: [{ &quot;pagePath&quot;: &quot;pages/home/index&quot;, &quot;iconPath&quot;: &quot;static/tabbar/ic_house.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tabbar/ic_house_active.png&quot;, &quot;text&quot;: &quot;&quot; }, { &quot;pagePath&quot;: &quot;pages/data/robot-market&quot;, &quot;iconPath&quot;: &quot;static/tabbar/robot_2.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tabbar/robot_1.png&quot;, &quot;text&quot;: &quot;&quot; }, { // &quot;pagePath&quot;: &quot;pages/riseFall/index&quot;, &quot;pagePath&quot;: &quot;pages/game/blind-box&quot;, // &quot;iconPath&quot;: &quot;static/tabbar/ic_kline_2.png&quot;, // &quot;selectedIconPath&quot;: &quot;static/tabbar/ic_kline_1.png&quot;, &quot;iconPath&quot;: &quot;static/tabbar/blind-box2.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tabbar/blind-box1.png&quot;, &quot;text&quot;: &quot;&quot; }, { &quot;pagePath&quot;: &quot;pages/riseFall/index&quot;, &quot;iconPath&quot;: &quot;static/tabbar/ic_kline_2.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tabbar/ic_kline_1.png&quot;, &quot;text&quot;: &quot;&quot; }, { &quot;pagePath&quot;: &quot;pages/ucenter/ucenter&quot;, &quot;iconPath&quot;: &quot;static/tabbar/user_2.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tabbar/user_1.png&quot;, &quot;text&quot;: &quot;&quot; } ] }, &quot;condition&quot;: { &quot;list&quot;: [], &quot;current&quot;: 1 } } ","tags":[{"index":-1,"name":"uniapp&taro","slug":"aUWAN2tZz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/aUWAN2tZz/"}],"title":"开发经验 - uniapp方法，技巧，常用技巧","feature":"","link":"https://qin_hu.gitee.io/blog/post/kai-fa-jing-yan-uniapp-fang-fa-he-ji-qiao/","stats":{"text":"10 min read","time":540000,"words":1627,"minutes":10},"date":"2024-01-15 13:34:04","dateFormat":"2024-01-15"},{"content":" 查看binlog是否开启 show variables like '%log_bin%'; log_bin是ON则开启 查看binlog存放日志文件目录 查看第一条日志 show binlog events; 获取binlog文件列表 show binary logs; 查看正在写入的binlog文件 show master status； 切换到mysqlbinlog目录（当线上数据出现错误的时候首先可以询问具体操作人记录时间点，这个时候可以借助mysql自带的binlog解析工具mysqlbinlog，具体位置在mysql安装目录**/mysql/bin/下） 首先需要找到mysqlbinlog的安装目录， 通过 find / -name mysqlbinlog查找到mysqlbinlog的文件夹。 我的文件夹是/www/server/mysql/bin/mysqlbinlog。 通过mysqlbinlog查看 查看数据库名为test，开始时间2023-01-12 00:00:00到结束时间2024-01-13 22:43:00的www/server/data/mysql-bin.000009log，并输出到屏幕上。 /www/server/mysql/bin/mysqlbinlog --no-defaults --database=test --start-datetime=&quot;2024-01-12 00:00:00&quot; --stop-datetime=&quot;2024-01-13 22:43:00&quot; /www/server/data/mysql-bin.000009 |more 查看数据库名为test，开始时间2023-01-12 00:00:00到结束时间2024-01-13 22:43:00的www/server/data/mysql-bin.000009log，并输出到mysql-bin-000009.txt文件中。 /www/server/mysql/bin/mysqlbinlog --no-defaults --database=test --start-datetime=&quot;2024-01-12 00:00:00&quot; --stop-datetime=&quot;2024-01-13 22:43:00&quot; /www/server/data/mysql-bin.000009 &gt; mysql-bin-000009.txt 解析指定的binlog /www/server/mysql/bin/mysqlbinlog --no-defaults -database=test --start-datetime=&quot;2024-01-12 00:00:00&quot; --stop-datetime=&quot;2024-01-13 22:43:00&quot; -vv --base64-output=decode-row /www/server/data/mysql-bin.000009 将binlog转换sql语句执行，再执行恢复 ","tags":[{"index":-1,"name":"数据库","slug":"SWTlIAzfL","used":true,"link":"https://qin_hu.gitee.io/blog/tag/SWTlIAzfL/"}],"title":"数据恢复 - 数据库表误删","feature":"","link":"https://qin_hu.gitee.io/blog/post/shu-ju-hui-fu-shu-ju-ku-biao-wu-shan/","stats":{"text":"2 min read","time":109000,"words":384,"minutes":2},"date":"2024-01-13 21:36:33","dateFormat":"2024-01-13"},{"content":"思路 在前端项目写nodeJs脚本，连接服务器将项目发布到服务器指定文件夹。 实现 1. 在根目录下创建upload.mjs或者upload.js 区别：使用.mjs表示声明为es模块，使用.js需要在package.json文件中声明type:'module' 2. 安装依赖 npm i scp2 ora chalk 3. 在upload.mjs中写入脚本 // const client = require('scp2'); import client from 'scp2'; import ora from 'ora'; // const ora = require('ora'); import chalk from 'chalk'; // const chalk = require('chalk'); // @ts-ignore const spinner = ora(chalk.green('正在发布到测试服务器...')); spinner.start(); client.scp('./dist/', { // 本地打包文件的位置 &quot;host&quot;: 'xxx.xxx.xxx.xxx', // IP地址 &quot;port&quot;: '22', // 服务器端口 &quot;username&quot;: 'root', // 用户名 &quot;password&quot;: 'xxx', // 密码 &quot;path&quot;: '/web-server/simeng/dist' // 项目路径 }, err =&gt; { spinner.stop(); if (!err) { // @ts-ignore console.log(chalk.green(&quot;部署完毕。&quot;)) } else { console.log(&quot;err&quot;, err) } }) 4. 在package.json中配置运行命令 &quot;upload&quot;: &quot;打包命令 &amp; node 运行脚本命令&quot; { &quot;name&quot;: &quot;pure-admin-thin&quot;, &quot;version&quot;: &quot;4.5.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: { &quot;dev&quot;: &quot;NODE_OPTIONS=--max-old-space-size=4096 vite&quot;, &quot;serve&quot;: &quot;pnpm dev&quot;, &quot;upload&quot;: &quot;npm run build &amp; node upload.mjs&quot; }, ... 5. 运行脚本实现上传 npm run upload 服务器使用pm2模块运行项目 npm i pm2 例如我要执行一个使用nodejs运行前端打包好的项目 创建项目文件夹 --web-serve ---- web-serve/dist ---- web-serve/app.js 执行文件app.js const express=require('express') const app=express() app.use(express.static('./dist')) app.listen(8099,()=&gt;{ console.log('启动成功:localhost:8099') }) 执行pm2命令 pm2 start app.js ","tags":[{"index":-1,"name":"React","slug":"TL1T7hUz1","used":true,"link":"https://qin_hu.gitee.io/blog/tag/TL1T7hUz1/"},{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"},{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"部署 - 前端项目使用node脚本自动化部署","feature":"","link":"https://qin_hu.gitee.io/blog/post/bu-shu-qian-duan-xiang-mu-shi-yong-node-jiao-ben-zi-dong-hua-bu-shu/","stats":{"text":"2 min read","time":116000,"words":397,"minutes":2},"date":"2024-01-09 17:59:02","dateFormat":"2024-01-09"},{"content":"webdav+nodeJs+坚果云+electron实现本地远程云盘文件互联 1. 坚果云注册应用账号 2. 封装webdav类 myWebdav.ts import { createClient } from 'webdav'; import fs from 'fs'; export default class MyWebdav { // 用户名 username: string = 'xxx@qq.com'; // 密码 password: string = 'xxx'; // 实例 client; constructor() { this.init() }; /** * @desc 初始化服务 */ init() { this.client = createClient( &quot;https://dav.jianguoyun.com/dav/&quot;, { username: this.username, password: this.password } ); } /** * @desc 获取根路径文件夹 */ async getDirectory() { const directoryItems = await this.client.getDirectoryContents(&quot;/&quot;, { deep: true }); console.log('directoryItems', directoryItems) } /** * @desc 创建文件夹 * @param path 文件夹路径 */ async createDirectory(path) { let isHave = await this.client.exists(path) if (isHave) { console.log('文件夹已存在') return } await this.client.createDirectory(path); } /** * @desc 将本地文件写入远程 * @param option { * pushPath = 远程文件路径； * localPath = 本地文件路径 * overwrite = 如果存在是否覆盖远程文件 * } */ async putFileContents({ pushPath, localPath, overwrite = true }) { let isHave = await this.client.exists(pushPath) if (isHave) { console.log('文件已存在') return } if (!pushPath?.length || !localPath?.length) { return } fs.readFile(localPath, 'utf-8', async (err, data) =&gt; { if (err) { console.log('该路径不存在') return } console.log(data) await this.client.putFileContents(pushPath, this.stringify(data), { overwrite: overwrite }); console.log('写入成功！') }) } /** * @desc 删除远程文件 */ async deleteFile(path) { let isHave = await this.client.exists(path) if (isHave) { await this.client.deleteFile(path); console.log(`文件已删除${path}`) return } else { console.log('文件不存在') return } } /** * @desc 转换为json文件 * @param str * @returns */ parse(str: string) { let value try { value = JSON.parse(str) } catch { value = null } return value } /** * @desc 转换为json字符串文件 * @param data * @returns */ stringify(data: any) { let value try { value = JSON.stringify(data) } catch { value = null } return value } } /** * 插件地址： * https://github.com/perry-mitchell/webdav-client */ 3. nodeJs中测试 import MyWebdav from './class/myWebdav' // 初始化webdav const myWebdav = new MyWebdav() myWebdav.getDirectory() myWebdav.createDirectory('/留记') // 写入文件 function getPath(path) { return path.replaceAll('\\\\', '/') } myWebdav.putFileContents({ localPath: getPath(`${app.getAppPath()}\\\\hrary.json`),// ekectron中获取文件的方法 pushPath: '/留记/hrary.json' }) // 删除文件 myWebdav.deleteFile('/留记/hrary.json') ","tags":[{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"业务 - webdav+nodeJs+坚果云+electron实现本地远程云盘文件互联","feature":"","link":"https://qin_hu.gitee.io/blog/post/ye-wu-webdavnodejsjian-guo-yun-electron-shi-xian-ben-di-yuan-cheng-yun-pan-wen-jian-hu-lian/","stats":{"text":"3 min read","time":131000,"words":432,"minutes":3},"date":"2024-01-09 17:57:56","dateFormat":"2024-01-09"},{"content":"需求 服务器部署前端项目，可以使用nginx部署，我们前端自己也可以使用pm2来部署更简洁。 部署 初始化node项目，并将前端项目放在根目录 下载express依赖，并起一个服务。假设我的服务端口是8099，前端项目文件夹是dist： app.js const express=require('express') const app=express() app.use(express.static('./dist')) app.listen(8099,()=&gt;{ console.log('启动成功:localhost:8099') }) 执行pm2命令持久化运行项目 pm2 start app.js 假如需要暂停服务 // 查看服务列表 pm2 list // 查看某个服务详情 pm2 show &lt;id&gt; // 停止服务 pm2 stop &lt;id&gt; 基本命令 pm2 start &lt;script_file|config_file&gt; [options] 启动指定应用，如pm2 start index.js --name httpServer； pm2 stop &lt;appName&gt; [options] 停止指定应用，如pm2 stop httpServer； pm2 list 把所有pm2启动实例列举出来，注意：pm2 stop 某个项目后，该项目还会存在pm2 list 的列表里面， 只是状态是 stop, 要想去掉该项目，用pm2 delete pm2 reload|restart &lt;appName&gt; [options] 重启指定应用，如pm2 restart httpServer； pm2 show &lt;appName&gt; [options] 显示指定应用详情，如pm2 show httpServer； pm2 delete &lt;appName&gt; [options] 删除指定应用，如pm2 delete httpServer，如果修改应用配置行为，最好先删除应用后，重新启动方才生效，如修改脚本入口文件； pm2 kill 杀掉pm2管理的所有进程； pm2 logs &lt;appName&gt; 查看指定应用的日志，即标准输出和标准错误； pm2 monit 监控各个应用进程cpu和memory使用情况； pm2 startOrReload &lt;appName&gt; 如果项目没有启动就执行 start 如果项目正在运行 就执行relaod ","tags":[{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"pm2部署","feature":"","link":"https://qin_hu.gitee.io/blog/post/pm2-bu-shu/","stats":{"text":"2 min read","time":106000,"words":425,"minutes":2},"date":"2024-01-09 17:50:38","dateFormat":"2024-01-09"},{"content":"1.NestJS环境搭建和项目创建 1-1.简介 NestJS提供了一个开箱即用的应用程序架构，允许开发人员和团队创建高度可测试，可扩展，松散耦合且易于维护的应用程序。 官方网址：https://nestjs.com 中文文档：https://www.nestjs.com.cn/ 1-2.项目创建 1-2-1. 准备 安装Node 1-2-2. 创建项目 全局安装nestjs脚手架 npm i -g @nestjs/cli 脚手架生成并启动项目 nest new nestjs-demo cd nest-demo npm run start 1-2-3.启动项目 打开package.json 文件可以看的下面的代码 &quot;start&quot;: &quot;nest start&quot;, // 最常用的开始模式 &quot;start:dev&quot;: &quot;nest start --watch&quot;, // 开发模式的启动 有监视功能 &quot;start:debug&quot;: &quot;nest start --debug --watch&quot;, // 调试Bug时的启动 调试程序时使用 一般常用npm run start:dev启动项目。 2.项目目录简介和编写helloworld 2-1. 目录介绍 脚手架生成的目录结构 +-- dist[目录] // 编译后的目录，用于预览项目 +-- node_modules[目录] // 项目使用的包目录，开发使用和上线使用的都在里边 +-- src[目录] // 源文件/代码，程序员主要编写的目录 | +-- app.controller.spec.ts // 对于基本控制器的单元测试样例 | +-- app.controller.ts // 控制器文件，可以简单理解为路由文件 | +-- app.module.ts // 模块文件，在NestJS世界里主要操作的就是模块 | +-- app.service.ts // 服务文件，提供的服务文件，业务逻辑编写在这里 | +-- app.main.ts // 项目的入口文件，里边包括项目的主模块和监听端口号 +-- test[目录] // 测试文件目录，对项目测试时使用的目录，比如单元测试... | +-- app.e2e-spec.ts // e2e测试，端对端测试文件，测试流程和功能使用 | +-- jest-e2e.json // jest测试文件，jset是一款简介的JavaScript测试框架 +-- .eslintrc.js // ESlint的配置文件 +-- .gitignore // git的配置文件，用于控制哪些文件不受Git管理 +-- .prettierrc // prettier配置文件，用于美化/格式化代码的 +-- nest-cli.json // 整个项目的配置文件，这个需要根据项目进行不同的配置 +-- package-lock.json // 防止由于包不同，导致项目无法启动的配置文件，固定包版本 +-- package.json // 项目依赖包管理文件和Script文件，比如如何启动项目的命令 +-- README.md // 对项目的描述文件，markdown语法 +-- tsconfig.build.json // TypeScript语法构建时的配置文件 +-- tsconfig.json // TypeScript的配置文件，控制TypeScript编译器的一些行为 src目录，编写代码的目录 +-- src[目录] // 源文件/代码，程序员主要编写的目录 | +-- app.controller.spec.ts // 对于基本控制器的单元测试样例 | +-- app.controller.ts // 控制器文件，可以简单理解为路由文件 | +-- app.module.ts // 模块文件，在NestJS世界里主要操作的就是模块 | +-- app.service.ts // 服务文件，提供的服务文件，业务逻辑编写在这里 | +-- app.main.ts // 项目的入口文件，里边包括项目的主模块和监听端口号 2-2.编写helloworld 在main.ts中可以看的启动的端口是3000，启动项目后在浏览器输入localhost:3000可以看的输出的HelloWorld。 在/src/app.service.ts文件中修改getHello()的代码 import { Injectable } from '@nestjs/common'; //方法 @Injectable() export class AppService { getHello(): string { //return 'Hello World'; //原来代码 return 'Hello'; } } 此时可以看到浏览器新的输出Hello。 3.Controller控制器-路由和模块的创建 3-1. 创建路由 3-1-1. 新建路由 在app.controller.ts 文件中@Get()新建路由 import { Controller, Get } from '@nestjs/common'; import { AppService } from './app.service'; //顶层路径 默认是'/'； 传'api'即顶层路径是'/api' @Controller() export class AppController { constructor(private readonly appService: AppService) {} //底层路由 不传是'/' 传'hellotest'即路由是'/hellotest' 路径根据顶层路由决定 @Get('hellotest') getHello(): string { return this.appService.getHello(); } } 此时可以使用localhost:3000/hellotest访问getHello()的输出。 3-1-2. 添加顶层路径 在app.controller.ts 文件中的@Controller()装饰器中添加顶层路径 import { Controller, Get } from '@nestjs/common'; import { AppService } from './app.service'; @Controller('api')//修改内容 export class AppController { constructor(private readonly appService: AppService) {} @Get('hellotest') getHello(): string { return this.appService.getHello(); } } 此时使用localhost:3000/api/hellotest访问getHello()的输出。 ## 3-2.新建模块 3-2-1.初始化目录 删除脚手架自动生成的测试文件app.controller.spec.ts、控制文件app.controller.ts 和app.service.ts 删除app.module.ts文件中对刚刚删除文件的引入 //删除后的app.module.ts import { Module } from '@nestjs/common'; @Module({ imports: [], controllers: [], providers: [], }) export class AppModule {} 3-2-2.使用命令创建模块 nest g module 模块名 在命令行输入nest g module user会在src目录自动生成user/user.module.ts文件 import { Module } from '@nestjs/common'; @Module({}) export class UserModule {} 此时app.module.ts文件会自动引入当前模块 import { Module } from '@nestjs/common'; import { GirlModule } from './girl/girl.module'; @Module({ imports: [GirlModule], controllers: [], providers: [], }) export class AppModule {} 3-2-3. 使用命令创建一个controller控制器 nest g controller 模块名 --no-spec 在控制台输入nest g controller user --no-spec会自动生成一个user.controller.ts文件 import { Controller } from '@nestjs/common'; @Controller('user') export class UserController {} 此时user.module.ts文件会自动引入当前控制器模块 import { Module } from '@nestjs/common'; import { UserController } from './user.controller'; @Module({ controllers: [UserController], }) export class UserModule {} 创建完成之后可以在user.controller.ts文件中写一个路由测试模块。 import { Controller, Get } from '@nestjs/common'; @Controller('user') export class UserController { @Get() getUserInfo(): any { return{ code:0, data:[&quot;小明&quot;,&quot;小方&quot;], } }; } 测试localhost:3000/user返回内容 { &quot;code&quot;: 0, &quot;data&quot;: [ &quot;小明&quot;, &quot;小方&quot; ] } 3-3.创建全局路由前缀 在main.ts中添加app.setGlobalPrefix('api'); 此时访问user模块的路由localhost:3000/api/user 所有模块的路由都会默认添加配置的api前缀 4.Controller控制器-业务逻辑相结合 4-1. 使用命令创建一个service nest g service 模块名 --no-spec 在控制台输入nest g service user --no-spec在src目录会自动生成一个user.service.ts文件。 service属于逻辑层，主要写业务逻辑。 4-2.Controller（控制器）引入service（逻辑） user.controller.ts import { Controller, Get } from '@nestjs/common'; import { UserService } from './user.service';//引入service @Controller('user') export class UserController { constructor(private userService: UserService) { } //构造userService函数，private归定属性只能在内部使用 } 4-3.在service里编写业务逻辑 user.service.ts import { Injectable } from '@nestjs/common'; @Injectable() export class UserService { getInfos(){//类方法 return { msg:'ok' } } } 4-4.在Controller中得到service的类方法 import { Controller, Get } from '@nestjs/common'; import { UserService } from './user.service';//引入service @Controller('user') export class UserController { constructor(private userService: UserService) { } //构造userService函数，private归定属性只能在内部使用 @Get('getInfos') //路由 getInfos():any{ //any表示任意类型 return this.userService.getInfos() } } 5.Get和Post请求 5-1.Get请求 在service里写一个带参数的方法，根据参数指定返回值。 user.service.ts import { Injectable } from '@nestjs/common'; @Injectable() export class UserService { //带参数的方法 searchUser(userid: string) { let obj: Object = {} switch (userid) { case '1': obj = { name: 'user1' } break; case '2': obj = { name: 'user2' } break; default: break; } return obj } } 在Controller中使用Query装饰器接收参数 user.controller.ts import { Controller, Get,Query } from '@nestjs/common';//引入Query装饰器 import { UserService } from './user.service';//引入service @Controller('user') export class UserController { constructor(private userService: UserService) { } //构造userService函数，private归定属性只能在内部使用 //带参数的get请求 @Get(&quot;/searchUser&quot;) searchUser(@Query() query):any{//使用Query装饰器，相当于req.query.userid return this.userService.searchUser(query.userid) } } 5-2.Post请求 在service里写一个带参数的方法 user.service.ts import { Injectable } from '@nestjs/common'; @Injectable() export class UserService { //post接收对象的方法 addUser(obj: any): any { interface User { //定义接口 name: string, age: number, readonly id: number } let userid = 1 let xm: User = { name: obj.name, age: parseInt(obj.age), id: userid }; return xm } } 在Controller中使用Body装饰器接收参数 import { Body,Controller, Get,Post } from '@nestjs/common'; import { UserService } from './user.service';//引入service @Controller('user') export class UserController { constructor(private userService: UserService) { } //带请求的post @Post(&quot;/addUser&quot;) addUser(@Body() body):any{ return this.userService.addUser(body) } } 5-3.使用Request装饰器接收请求 Request装饰器相当于req的简写，Query装饰器相当于req.query的简写，Body装饰器相当于req.body的简写。所以Request装饰器的使用与其他两个使用大同小异。 user.controller.ts import { Controller, Get,,Post,Request } from '@nestjs/common'; import { UserService } from './user.service';//引入service @Controller('user') export class UserController { constructor(private userService: UserService) { } //构造userService函数，private归定属性只能在内部使用 //带参数的get请求 @Get(&quot;/searchUser&quot;) searchUser(@Request() req):any{ return this.userService.searchUser(req.query.userid) } } 先引入Request装饰器,然后在类方法中使用。 6.创建动态路由 6-1.介绍 普通的路由传参方法，显示传递 http://localhost:3000/user/searchUser?id=1 动态路由传参方法，隐式传递 http://localhost:3000/user/searchUser/1 动态路由使用/info/:userid的方式创建路由，使用req.params接收参数 6-2.使用Request装饰器接收动态路由参数 user.controller.ts ... //@动态路由 @Get(&quot;getByIdList/:userid&quot;) getByIdList(@Request() req): any { console.log(req.params) let userid:string=req.params.userid return this.userService.getByIdList(userid) } ... 6-3.使用Param装饰器 Param装饰器相当于req.params的简写 先引入 import { Param } from '@nestjs/common'; 使用 user.controller.ts: ... getByIdList(@Param() params): any { let userid: string = params.userid return this.userService.getByIdList(userid) } ... 6-4.动态路由多个参数传递 请求 getByIdList/1/18/xm 接收 getByIdList/:userid/:age/:name 7. 常用装饰器总结 7-1. @Get 7-2. @Post 7-3. @Request 7-4. @Param 7-5. @Query 7-6. @Body 7-7. @Headers 介绍 读取请求头里边的信息 使用 引入 import {Headers } from '@nestjs/common'; 示例 @Get(&quot;getByIdList/:userid&quot;) //使用params装饰器 getByIdList(@Param() params,@Headers() header): any { console.log(header) //打印header信息 let userid: string = params.userid return this.userService.getByIdList(userid) } 8.使用ORM工具 介绍 ORM 是 Object Relational Mapping 的缩写，译为“对象关系映射”，它解决了对象和关系型数据库之间的数据交互问题。ORM的作用就是：定义一个对象，这个对象就对应着一张表，这个对象的一个实例，就对应着表中的一条记录。 这样作的好处，就是我们可以通过对象的形式，来操作数据库。 常见的ORM工具 TypeOrm https://typeorm.bootcss.com/ 9.nestJs中使用TypeOrm 9-1.安装TypeOrm和mysql2 npm install --save @nestjs/typeorm typeorm mysql2 9-2.引入 在/src/app.module.ts中引入typeorm import { TypeOrmModule } from '@nestjs/typeorm'; @Module({ imports:[ TypeOrmModule.forRoot({ type:'mysql', // 数据库类型 host:'localhost', // 数据库的连接地址host port:3306, // 数据库的端口 3306 username:'root', // 连接账号 password:'root123', // 连接密码 database:'test_db', // 连接的表名 retryDelay:500, // 重试连接数据库间隔 retryAttempts:10, // 允许重连次数 })] }) 10.数据库操作-TypeORM的实体操作 概念--TypeORM中的实体Entities ORM中的实体其实就是把数据库映射成对象的那个类。这个类可以模拟数据库表，定义其中的字段。 我们需要定义实体类操作数据库。 增加配置项 想让TypeORM自动工作，为我们创建对应的数据库结构，我们需要先在配置数据库连接的地方增加两个配置项 允许实体同步到数据库 自动加载实体。 import { Module } from '@nestjs/common'; import { UserModule } from './user/user.module'; import { TypeOrmModule } from &quot;@nestjs/typeorm&quot;; @Module({ imports: [UserModule, //连接数据库 TypeOrmModule.forRoot({ type: 'mysql', // 数据库类型 host: 'localhost', // 数据库的连接地址host port: 3306, // 数据库的端口 3306 username: 'root', // 连接账号 password: 'root', // 连接密码 database: 'nest-test', // 连接的库名 retryDelay: 500, // 重试连接数据库间隔 retryAttempts: 10, // 允许重连次数 synchronize:true, // 是否将实体同步到数据库 autoLoadEntities:true, // 自动加载实体配置，forFeature()注册的每个实体都自己动加载 }) ], controllers: [], providers: [], }) export class AppModule { } 编写Entities实体 创建文件 进入模块文件夹，新建entities文件夹，新建modulename.entities.ts文件 编写实体类 //引入entity,Column装饰器定义列对应表头，PrimaryGeneratedColumn装饰器对应主键 import { Entity,Column,PrimaryGeneratedColumn } from &quot;typeorm&quot;; @Entity() export class User{ @PrimaryGeneratedColumn() id:number //id,主键 @Column() username:string @Column() age:number @Column() skill:string } 3.模块中引入 在@Module( )装饰器中用forFeature( )方法，把User的实体引入。 import { Module } from '@nestjs/common'; import { UserController } from './user.controller'; import { UserService } from './user.service'; import { TypeOrmModule } from '@nestjs/typeorm'; import { User } from &quot;./entities/user.entities&quot; @Module({ imports: [TypeOrmModule.forFeature([User])], controllers: [UserController], providers: [UserService] }) export class UserModule { } 重新启动npm run start:dev此时数据库新建了user表 11.数据库操作-ORM对数据库的增删改查 创建实体后，可以进行增删改查 在service中引入装饰器和工具 ... // 依赖注入 import { Like, Repository } from 'typeorm' import { InjectRepository } from '@nestjs/typeorm' import { User } from &quot;./entities/user.entities&quot;//引入实体 @Injectable() export class UserService { //注入依赖后可以进行增删改查操作 user是当前的模块 constructor(@InjectRepository(User) private readonly user: Repository&lt;User&gt;) { } ... } 实现新增 使用save方法 先new出一个模块的对象，然后用这个对象的save( )保存数据 service逻辑层文件 addTest(){ const data=new User() data.username=&quot;test&quot; data.age=16 data.skill=&quot;篮球&quot; return this.user.save(data)//使用save方法保存到数据库 } 在控制器中配置路由并且引入路由 controller路由文件 @Post(&quot;addTest&quot;) addTest(){ return this.userService.addTest() } 在postman中测试user/addtest接口，将会新增一条数据 { &quot;username&quot;: &quot;test&quot;, &quot;age&quot;: 16, &quot;skill&quot;: &quot;篮球&quot;, &quot;id&quot;: 1 } 实现删除 删除方法使用delete( ) service逻辑层文件 deleteTest(id: number) { //删除 return this.user.delete(id) //使用delete方法执行删除 } controller路由文件 @Get(&quot;deleteTest/:id&quot;) deleteTest(@Param() params){ return this.userService.deleteTest(params.id) } 实现修改数据 修改数据接收两个数据，一个id和要修改的数据 service逻辑层文件 updateTest({ id }) { let data = new User() data.username = &quot;qwereqw&quot; data.age =14 data.skill = &quot;0000kioi&quot; return this.user.update(id,data) } controller路由文件 @Post(&quot;updataTest&quot;) updateTest(@Body() body){ return this.userService.updateTest({ id:body.id, }) } 实现查询数据 查询所有 find( )方法查询所有 service逻辑层文件 findAll():any{ return this.user.find() } controller路由文件 //查询所有 @Get('findAll') findTest(){ return this.userService.findAll() } 模糊查询 service逻辑层文件 // 模糊查询 使用like //根据username查询list findUsername(username:string):any{ return this.user.find({ where:{ username:Like(`%${username}`) } }) } controller路由文件 //模糊查询 使用like @Get('findUsername/:username') findUsername(@Param() params){ return this.userService.findUsername(params.username) } 详细选项 12. Providers(提供者)实现依赖注入 参考学习链接： https://jspang.com/article/87#toc2 相关文档 https://typeorm.bootcss.com/ https://www.nestjs.com.cn/ 可以参考的开发项目结构 prisam // 数据库相关 src ├─ auth // 授权登陆模块 │ ├─ auth.controller.ts │ ├─ auth.guard.ts // 守卫 │ ├─ auth.interface.ts // 存放局部的该模块的类型声明 │ ├─ auth.module.ts │ ├─ auth.service.ts │ ├─ dto │ │ ├─ sign-in.dto.ts │ ├─ entities │ │ └─ refresh-token.entity.ts ├─ common // 全局通用模块 | ├─ configs // 全局配置 | ├─ constants // 定义一些常量 | ├─ decorators // 全局装饰器 | ├─ filters // 全局过滤器 | ├─ interceptors // 全局拦截器 | ├─ interfaces // 全局类型声明 | ├─ services // 全局公共服务 | ├─ * // 其他 ├─ utils // 工具函数, 尽量存放纯函数 ├─ app.*.ts // app 模块, 其他 module 需要引用到 app module ├─ main.ts // 应用入口 ","tags":[{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"nestJs入门","feature":"","link":"https://qin_hu.gitee.io/blog/post/nestjs-ru-men/","stats":{"text":"17 min read","time":986000,"words":3726,"minutes":17},"date":"2024-01-09 17:49:21","dateFormat":"2024-01-09"},{"content":"1.官网 https://nodemailer.com/ 2.安装 npm i nodemailer 3.使用 i. 使用nodemailer.createTransport 方法创建当前发送邮箱用户信息 ii. 发送邮箱需要先获取smtp授权码，在邮箱客户端设置获取 iii. 使用transporter.sendMail(邮箱内容实例,回调)方法发送邮箱 3-1.封装sendEmail.js文件 const nodemailer = require('nodemailer'); const sendEmail=()=&gt;{ let transporter = nodemailer.createTransport({ // host: 'smtp.ethereal.email', service: 'qq', // 使用了内置传输发送邮件 查看支持列表：https://nodemailer.com/smtp/well-known/ port: 465, // SMTP 端口 secureConnection: true, // 使用了 SSL auth: { user: '3409575546@qq.com', // 这里密码不是qq密码，是你设置的smtp授权码 pass: '**********', } }); let mailOptions = { from: '&quot;禾耳&quot; &lt;3409575546@qq.com&gt;', // sender address to: '20115***558@qq.com', // 接收地址,list of receivers subject: '嘿嘿嘿', // Subject line // 发送text或者html格式 // text: 'Hello world?', // plain text body html: '&lt;b&gt;嘿嘿嘿&lt;/b&gt;' // html body }; // send mail with defined transport object transporter.sendMail(mailOptions, (error, info) =&gt; { if (error) { return console.log(error); } console.log('Message sent: %s', info.messageId); // Message sent: &lt;04ec7731-cc68-1ef6-303c-61b0f796b78f@qq.com&gt; }); } module.exports={sendEmail} 3-1.在app.js中使用 接口依赖express const express = require('express') const { sendEmail } = require(&quot;./untils/sendEmail&quot;) const app = express() app.get('/sendEmail', (req, res) =&gt; { let resul=sendEmail() console.log(resul)//Message sent: &lt;4114ce1c-5532-cda0-e8bc-acf12f63bb34@qq.com&gt; res.send('ok') }) app.listen(3003, () =&gt; { console.log(':3003') }) ","tags":[{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"业务 - 发送邮件（nodemailer）","feature":"","link":"https://qin_hu.gitee.io/blog/post/ye-wu-fa-song-you-jian-nodemailer/","stats":{"text":"2 min read","time":96000,"words":316,"minutes":2},"date":"2024-01-09 17:48:08","dateFormat":"2024-01-09"},{"content":"1.介绍 如果要实现服务端主动给客户端发送消息，可以使用轮询的方法，axios隔一段时间请求一次接口，该方法效率低。解决这种问题的最好方法是使用websocket服务端主动给客户端发送消息 。 2.技术向 node,express-ws,express，socket.io 3.express-ws实现一对一聊天思路 3-1.下载依赖 创建项目文件，app.js入口文件,websocket.js文件;使用npm下载依赖 npm i express-ws 3-2.入口文件引入依赖 app.js //入口文件 const express = require('express') //引入express-ws const expressWs=require('express-ws') const websocket=require(&quot;./websocket/websocket&quot;) //引入依赖文件 const app = express() expressWs(app) //实例化 app.use('/ws',websocket) //配置websocket,客户端连接时按照 &quot;/ws&quot;规则匹配路径 app.use(express.static('public')) //配置静态文件 //创建视图文件链接数据库 app.use(&quot;/index&quot;,express.static('public/index.html')) app.use(&quot;/page2&quot;,express.static('public/index-1.html')) app.listen(2001, () =&gt; { console.log('localhost:2001') }) 3-3.websocket.js建立连接 注意点： 一个客户端对应一个 websocket连接 创建数组存储客户端发送来的消息，一个websocket连接对应一个数组 创建定时器监听websocket发送的消息实现广播发送 //引入模块 const express = require(&quot;express&quot;) const expressWs = require(&quot;express-ws&quot;) const router = express.Router() expressWs(router) var arr1 = [] var arr2 = [] //websocket1 router.ws(&quot;/test-1&quot;, ws =&gt; { //send发数据 ws.send(&quot;---连接成功!---&quot;) let interval interval = setInterval(() =&gt; { if (ws.readyState === ws.OPEN) { if (arr2.length &gt; 0) { let msg = arr2[0] arr2.shift() ws.send(msg) } // ws.send(Math.random().toFixed(2)) } else { clearInterval(interval) } }, 1000) //接受客户端发来的数据 ws.on(&quot;message&quot;, (msg) =&gt; { arr1.push(msg) }) // close 事件表示客户端断开连接时执行的回调函数 ws.on('close', (e) =&gt; { if(interval){ clearInterval(interval) } console.log('close connection') }) }) //websocket2 router.ws(&quot;/test-2&quot;, ws =&gt; { //send发数据 ws.send(&quot;---连接成功!---&quot;) let interval interval = setInterval(() =&gt; { if (ws.readyState === ws.OPEN) { if (arr1.length &gt; 0) { let msg = arr1[0] arr1.shift() ws.send(msg) } // ws.send(Math.random().toFixed(2)) } else { clearInterval(interval) } }, 1000) //接受客户端发来的数据 ws.on(&quot;message&quot;, (msg) =&gt; { //把数据返回给客户端 arr2.push(msg) // ws.send(msg) }) // close 事件表示客户端断开连接时执行的回调函数 ws.on('close', (e) =&gt; { if(interval){ clearInterval(interval) } console.log('close connection') }) }) module.exports = router 3-4.视图文件连接服务端 客户端连接时使用ws协议；&quot;/ws&quot;规则匹配路径。 页面1.index.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; --page1-- &lt;button class=&quot;btn&quot;&gt; 发送 &lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; const startSocket = () =&gt; { // Create WebSocket connection. const socket = new WebSocket('ws://localhost:2001/ws/test-1'); // // Connection opened //建立连接 socket.addEventListener('open', function (event) { console.log(`WebSocket 连接状态`, JSON.stringify(event)) }); // Listen for messages //接收消息 socket.addEventListener('message', function (event) { console.log('Message from server ', event.data); }); socket.addEventListener('close', function (event) { console.log('WebSocket连接已关闭') startSocket() }); //客户端发送消息 const btn = document.querySelector('.btn') btn.onclick = () =&gt; { socket.send('page1发送了一条消息！') } } startSocket() &lt;/script&gt; &lt;/html&gt; 页面2.index-1.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; page2 &lt;button class=&quot;btn&quot;&gt; 发送 &lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; const startSocket = () =&gt; { // Create WebSocket connection. const socket = new WebSocket('ws://localhost:2001/ws/test-2'); // // Connection opened //建立连接 socket.addEventListener('open', function (event) { console.log(`WebSocket 连接状态`, JSON.stringify(event)) }); // Listen for messages //接收消息 socket.addEventListener('message', function (event) { console.log('Message from server ', event.data); }); socket.addEventListener('close', function (event) { console.log('WebSocket连接已关闭') startSocket() }); //客户端发送消息 const btn = document.querySelector('.btn') btn.onclick = () =&gt; { socket.send('page2发送了一条消息！') } } startSocket() &lt;/script&gt; &lt;/html&gt; 3-5.效果 页面一发送消息页面二可以接收到消息 4.socket.io实现多人聊天 Socket.IO 是一个库，可以在客户端和服务器之间实现 低延迟, 双向 和 基于事件的 通信。建立在 WebSocket 协议之上，并提供额外的保证，例如回退到 HTTP 长轮询或自动重新连接。 4-1.安装 服务端 npm install socket.io 客户端 &lt;script src=&quot;https://cdn.socket.io/4.4.1/socket.io.min.js&quot; integrity=&quot;sha384-fKnu0iswBIqkjxrhQCTZ7qlLHOFEgNkRmK2vaO/LbTZSXdJfAu6ewRBdwHPhBo/H&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;/script&gt; 4-2.服务端建立socket socket监听当前http服务器，创建socket服务器 const io = require('socket.io')(server); io.emit('事件名',值) 服务器向所有客户端推送消息 io.on('connection',function(socket){...}) 服务器监听当前连接成功的客户端 socket.emit('事件名',值) 服务器向客户端推送消息 socket.on('事件名',function(res){...}) 服务器接收客户端发送的消息 //入口文件 const express = require('express') const app = express() //配置静态文件 app.use(express.static('public')) app.use(&quot;/index-1&quot;,express.static('public/index-1.html')) app.use(&quot;/index-2&quot;,express.static('public/index-2.html')) //创建http服务器 var server = require('http').createServer(app); //监听端口3000，如果被占用可以选择其他的端口 server.listen(3001,function(){ console.log(&quot;3001端口已经被启动.....&quot;); }) //创建socket服务器 io const io = require('socket.io')(server); var count=0;//统计正在连接的客户端人数 //监听客户端连接， io.on('connection',function(socket){//sokcet表示当前连接成功的客户端 //监听客户端登录成功 socket.on('login',function(res){ //记录当前用户的匿名 socket.username = res; console.log('名字:',socket.username) //进入连接count++ count++; //向所有客户端推送当前连接人数 io.emit('count',count) //服务器向当前客户端推送消息，连接成功, socket.emit('message',{name:socket.username,msg:'连接成功'+(new Date())}); }) //监听客户端的发送的消息 socket.on('send',function(res){ // console.log('客户端有发来消息'); //服务器向所有连接的客户端推向消息 io.emit('message',{name:socket.username,msg:res}); }); //监听客户端断开连接 socket.on('disconnect',function(){ //断开连接count--; count--; //向所有客户端发送当前连接人数 io.emit('count',count); }) }) 4-5.封装socket.js文件 4-5-1.添加socket.js文件 /* socketio.js封装文件 */ const { Server } = require('socket.io'); let socketio = {}; //获取io //执行socket socketio.getSocketio = function (server) { let io = new Server(server, { cors: true }); //编写代码 io.sockets.on('connection', function (socket) { console.log('连接成功'); }); }; module.exports = socketio; 4-5-2.引入封装 首先:引入上面封装好的socket.js文件,在const http = require('http')后面加入const io = require('…/socketio');然后在const server = http.createServer(app);后面加入io.getSocketio(server); 4-5.客户端连接socket 1.创建socket实例 const socket = io.connect('http://localhost:3001'); 2. socket.emit('事件名',值) 客户端向服务器推送消息 3. socket.on('事件名',function(res){...}) 客户端接收服务器发送的消息 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;script src=&quot;https://cdn.socket.io/4.4.1/socket.io.min.js&quot; integrity=&quot;sha384-fKnu0iswBIqkjxrhQCTZ7qlLHOFEgNkRmK2vaO/LbTZSXdJfAu6ewRBdwHPhBo/H&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button class=&quot;btn&quot;&gt; &lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; //模拟id const generateId = () =&gt; { //获取随机id const s = []; const hexDigits = '0123456789abcdef'; for (let i = 0; i &lt; 36; i++) { s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1); } // bits 12-15 of the time_hi_and_version field to 0010 s[14] = '4'; // bits 6-7 of the clock_seq_hi_and_reserved to 01 s[19] = hexDigits.substr((s[19] &amp; 0x3) | 0x8, 1); s[8] = s[13] = s[18] = s[23] = '-'; const uuid = s.join(''); return uuid; } let userid = generateId() //连接socket const socket = io.connect('http://localhost:3001'); //@1.接受服务端消息 socket.on('count', (res) =&gt; { console.log('count', res) }) //连接成功时触发 socket.on('connect', function () { console.log('连接成功'); }); //连接断开时触发 socket.on('disconnect', function () { console.log('连接断开'); }); //收到消息时触发 socket.on('message', (res) =&gt; { console.log('message', res) }) //@2.向服务端发送消息 //用户登陆 socket.emit('login', userid) let btn = document.querySelector('.btn') btn.innerText = `用户${userid}` btn.onclick = () =&gt; { socket.emit('send', `${userid}发送一条消息`) } &lt;/script&gt; &lt;/html&gt; 4-4.效果： 同一个服务器下客户端发送消息其他客户端可以收到消息 ","tags":[{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"业务 - 实现即时通讯(websocket与socket）","feature":"","link":"https://qin_hu.gitee.io/blog/post/ye-wu-shi-xian-ji-shi-tong-xun-websocket-yu-socket/","stats":{"text":"11 min read","time":625000,"words":2115,"minutes":11},"date":"2024-01-09 17:46:55","dateFormat":"2024-01-09"},{"content":" operation.js const { rejects } = require('assert') const fs = require('fs') const { resolve } = require('path') /* 查询数据 */ const queryData = ({ path }) =&gt; { return new Promise((resolve, rejects) =&gt; { fs.readFile(path, (err, data) =&gt; { if (err) { rejects(err) } resolve(JSON.parse(data)) }) }) } /* 写入数据 path,数据,插入方式 */ const addData = async ({ path, data, way = &quot;push&quot; }) =&gt; { let queryDataRes = await queryData({ path }) if (queryDataRes) { queryDataRes = JSON.parse(queryDataRes) } if (way == &quot;push&quot;) { //末尾 queryDataRes.push(data) } if (way == &quot;unshift&quot;) { //开头 queryDataRes.unshift(data) } return new Promise((resolve, rejects) =&gt; { fs.writeFile(path, JSON.stringify(queryDataRes), (err, data) =&gt; { if (err) { rejects(err) } resolve({ status: &quot;success&quot; }) }) }) } /* 删除数据 */ const deleteData = async ({ path, id }) =&gt; { // //1.查询数据 let queryDataRes = await queryData({ path }) let checkIdRes = await checkId({ path, id }) if (checkIdRes === 0) { return 'id不存在!!' } //2.根据id删除数据 queryDataRes = queryDataRes.filter(el =&gt; { return el.id !== id }) return new Promise((resolve, rejects) =&gt; { fs.writeFile(path, JSON.stringify(queryDataRes), (err, data) =&gt; { if (err) { rejects(err) } resolve({ status: &quot;success&quot; }) }) }) } /* 编辑数据 */ const editData = async ({ path, id, data }) =&gt; { //1.查询数据 let queryDataRes = await queryData({ path }) let checkIdRes = await checkId({ path, id }) if (checkIdRes === 0) { return 'id不存在!!' } //2.根据id更新 let index = queryDataRes.findIndex(el =&gt; { return el.id == id }) if(!data.hasOwnProperty(&quot;id&quot;)){ data.id=id } if(!data.hasOwnProperty(&quot;col&quot;)){ data.col=queryDataRes[index].col } queryDataRes[index]=data return new Promise((resolve, rejects) =&gt; { fs.writeFile(path, JSON.stringify(queryDataRes), (err, data) =&gt; { if (err) { rejects(err) } resolve({ status: &quot;success&quot; }) }) }) } /* 校验id */ const checkId = async ({ path, id, }) =&gt; { //1.查询数据是否存在id -- (1)不存在自动生成 且返回id不存在 (2)接受id与id不匹配 let queryDataRes = await queryData({ path }) //数据不存在id的情况 let isHasId = queryDataRes.every(el =&gt; { return el.hasOwnProperty(&quot;id&quot;) }) if (!isHasId) { queryDataRes.forEach((el, index) =&gt; { el.col = index el.id = generateId() }) fs.writeFile(path, JSON.stringify(queryDataRes), (err, data) =&gt; { if (err) { rejects(err) } resolve({ status: &quot;success&quot; }) }) return 0 } //id不匹配的情况 let idList = queryDataRes.filter(el =&gt; { return el.id == id }) if (!idList.length) { return 0 } } /* util函数 */ const generateId = () =&gt; { //获取随机id const s = []; const hexDigits = '0123456789abcdef'; for (let i = 0; i &lt; 36; i++) { s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1); } // bits 12-15 of the time_hi_and_version field to 0010 s[14] = '4'; // bits 6-7 of the clock_seq_hi_and_reserved to 01 s[19] = hexDigits.substr((s[19] &amp; 0x3) | 0x8, 1); s[8] = s[13] = s[18] = s[23] = '-'; const uuid = s.join(''); return uuid; } module.exports = { queryData, addData, deleteData, editData } app.js const fs = require('fs') const express = require('express') const { queryData, addData, deleteData, editData } = require('./operation') const app = express() app.use(express.static('./data/')) /* end */ //得到数据 app.get('/getData', async (req, res) =&gt; { let queryDataRes = await queryData({ path: &quot;./data/af.json&quot; }) if (queryDataRes) { res.send(queryDataRes) } }) //新增数据 app.get('/addData', async (req, res) =&gt; { let obj = { &quot;name&quot;: &quot;3&quot;, &quot;age&quot;: &quot;3&quot;, &quot;asd&quot;: &quot;3&quot; } let addDataRes = await addData({ path: &quot;./data/data.json&quot;, data: obj, way: &quot;unshift&quot; }) if (addDataRes) { res.send(&quot;添加成功！&quot;) } }) //删除数据 app.get('/deleteData', async (req, res) =&gt; { let deleteDataRes = await deleteData({ path: &quot;./data/data.json&quot;, id: &quot;17a05538-623c-465c-805c-3f506da858d0&quot; }) if (deleteDataRes) { res.send(deleteDataRes) } }) //编辑数据 app.get('/editData', async (req, res) =&gt; { let data= { &quot;name&quot;: &quot;睡觉&quot;, &quot;age&quot;: &quot;150&quot;, &quot;asd&quot;: &quot;84794393-8cf7-462c-86f7-52de9f54caf3&quot;, &quot;id&quot;: &quot;d64c1753-4c8e-4145-8c8c-28846fd37239&quot;, &quot;col&quot;: 4 } let id=&quot;d64c1753-4c8e-4145-8c8c-28846fd37239&quot; let editDataRes = await editData({ path:&quot;./data/data.json&quot;, id, data }) if(editDataRes){ res.send(&quot;success!!&quot;) } }) app.listen(8090, () =&gt; console.log('localhost:8090')) data.json [{ &quot;name&quot;: &quot;吃饭&quot;, &quot;age&quot;: &quot;15&quot;, &quot;asd&quot;: &quot;324234&quot;, &quot;id&quot;: &quot;98570e4b-2b7d-4396-8602-eda23d6f7162&quot;, &quot;col&quot;: 1 }, { &quot;name&quot;: &quot;吃饭&quot;, &quot;age&quot;: &quot;15&quot;, &quot;asd&quot;: &quot;324234&quot;, &quot;id&quot;: &quot;b1240772-db0a-42e4-8d14-6ba0a24aa2b1&quot;, &quot;col&quot;: 2 }, { &quot;name&quot;: &quot;吃饭&quot;, &quot;age&quot;: &quot;15&quot;, &quot;asd&quot;: &quot;324234&quot;, &quot;id&quot;: &quot;51e9a972-766c-4dd2-bd10-7cf4808b85b7&quot;, &quot;col&quot;: 3 }, { &quot;name&quot;: &quot;睡觉&quot;, &quot;age&quot;: &quot;150&quot;, &quot;asd&quot;: &quot;84794393-8cf7-462c-86f7-52de9f54caf3&quot;, &quot;id&quot;: &quot;d64c1753-4c8e-4145-8c8c-28846fd37239&quot;, &quot;col&quot;: 4 }] ","tags":[{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"封装方法 - json模拟数据，实现json文件的增删改查","feature":"","link":"https://qin_hu.gitee.io/blog/post/feng-zhuang-fang-fa-json-mo-ni-shu-ju-shi-xian-json-wen-jian-de-zeng-shan-gai-cha/","stats":{"text":"6 min read","time":301000,"words":865,"minutes":6},"date":"2024-01-09 17:45:45","dateFormat":"2024-01-09"},{"content":"multer上传图片 1.后台安装 multer模块，同时引入fs模块 2.router.js入口文件导入模块 const fs=require('fs') const multer=require('multer') 3.创建uploads文件夹存储图片 4.配置静态资源 实现代码 // 1-1.设置上传路径 var multer = require('multer'); var storage = multer.diskStorage({ //设置上传后文件路径，uploads文件夹会自动创建。 destination: function (req, file, cb) { if (String(file.mimetype).slice(0, 5) == &quot;image&quot;) { //如果是图片 cb(null, './public/image') return false } cb(null, './public') }, //给上传文件重命名，获取添加后缀名 filename: function (req, file, cb) { var fileFormat = (file.originalname).split(&quot;.&quot;); cb(null, file.fieldname + '-' + Date.now() + &quot;.&quot; + fileFormat[fileFormat.length - 1]); } }); var fileFilter = function (req, file, cb) { cb(null, true); //这里设置为false则直接拒绝上传了，实际使用应为true } //1-2.添加配置文件到muler对象。 var upload = multer({ storage: storage, fileFilter: fileFilter }); app.use(upload.any()); //任意文件 // 响应静态文件 app.use('/public/', express.static('./public/')) ","tags":[{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"业务 - 上传","feature":"","link":"https://qin_hu.gitee.io/blog/post/ye-wu-shang-chuan/","stats":{"text":"2 min read","time":65000,"words":232,"minutes":2},"date":"2024-01-09 17:44:51","dateFormat":"2024-01-09"},{"content":"准备 技术栈 node,express, nodemon,bcrypt,joi 1.注册 (1)添加注册路由及注册页面展示 //用户注册页面 router.get('/admin/register', (req, res) =&gt; { const { message } = req.query res.render(&quot;admin/user-edit.html&quot;, { message }) }) (2)视图层设置form提交数据,服务端得到数据 &lt;form class=&quot;form-container&quot; method=&quot;post&quot; action=&quot;/admin/register&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;用户名&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;请输入用户名&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;邮箱&lt;/label&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;请输入邮箱地址&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;请输入密码&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;角色&lt;/label&gt; &lt;select class=&quot;form-control&quot; name=&quot;role&quot;&gt; &lt;option value=&quot;normal&quot;&gt;普通用户&lt;/option&gt; &lt;option value=&quot;admin&quot;&gt;超级管理员&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;状态&lt;/label&gt; &lt;select class=&quot;form-control&quot; name=&quot;state&quot;&gt; &lt;option value=&quot;0&quot;&gt;启用&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;禁用&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;input type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt; &lt;/div&gt; &lt;/form&gt; (3)视图层验证。 视图层验证表单内容是否填写 //1.表单序列化 function serializeToJson(form) { var result={} var f = form.serializeArray() f.forEach(function (item) { result[item.name] = item.value }) return result } //2.判断表单字段 var result = serializeToJson(Form)//序列化获取表单 if (result.email.trim().length == 0) { alert(&quot;请输入邮箱&quot;) // 阻止表单默认提交 return false } (4)服务端验证。 验证表单内容是否符合格式 使用第三方模块 joi const schema = joi.object({ username: joi.string().min(3).max(20).required().error(new Error(&quot;用户名设置错误&quot;)), password: joi.string().pattern(new RegExp('^[a-zA-Z0-9]{3,30}$')).required().error(new Error(&quot;密码设置错误&quot;)), email: joi.string().required().email({ minDomainSegments: 2, tlds: { allow: ['com', 'net'] } }), role: joi.string().valid('normal', 'admin').required().error(new Error(&quot;角色值设置错误&quot;)), state: joi.number().valid(0, 1).required().error(new Error(&quot;状态值设置错误&quot;)), }) try { //验证通过执行 // 实现验证 await schema.validateAsync(req.body) } catch (e) { // 验证错误执行 //重定向到编辑页，并将错误信息传过去 return res.redirect(`/admin/register?message=${e.message}`) } 验证注册的邮箱地址是否注册过,使用mongoose查询方法 // 2.验证用户（使用邮箱）是否被注册.如果找得到email说明数据库存在，否则不存在，不存在就实行添加 let user = await User.findOne({ email: req.body.email }) if (user) { //查询到了，则不能注册，重定向到注册页面 return res.redirect(`/admin/register?message=邮箱已被注册`) } (5)密码加密技术bcrypt // 3.对密码加密 // 3.1生成随机字符串 const salt = await bcrypt.genSalt(10) // 3.2 加密替换代码 req.body.password = await bcrypt.hash(req.body.password, salt) (6)将信息添加到数据库 await new User(req.body).save() //或者 //await User.create(req.body) (7)重定向到用户页面 res.redirect('/admin/user') 2.登录 （1）创建用户集合，登录用户 连接数据库 创建用户集合 初始化用户 user.js // 创建用户集合 var mongoose = require('mongoose') //2.连接并创建数据库 mongoose.connect(&quot;mongodb://localhost/blog&quot;).then(() =&gt; { console.log('连接成功'); }).catch(() =&gt; { console.log('连接失败'); }) const Schema = mongoose.Schema var userSchema = new Schema({ username: { type: String, required: true, //用户必须 minlength: 2, maxlength: 20 }, email: { type: String, unique: true, //保证唯一性（不重复） }, password: { type: String, required: true }, role: { //admin超级管理员 type: String, required: true }, state: { //0为启用，1为禁用 type: Number, default: 0 } }) // 插入数据检测（初始化用户） // User.create({ // username:'admin', // email:'333@qq.com', // password:'admin', // role:'admin', // state:0 // }).then(()=&gt;{ // console.log('创建成功'); // }).catch(()=&gt;{ // console.log('创建失败'); // }) //将用户集合作为模块成员导出 // 实例化文档结构（将文档结构发布为模型） module.exports = mongoose.model('User', userSchema) （2）视图层设置form提交数据 login.html &lt;form id=&quot;loginForm&quot; action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;邮件&lt;/label&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;请输入邮件地址&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;请输入密码&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary loginForm&quot;&gt;登录&lt;/button&gt; &lt;/form&gt; (3)视图层验证。 视图层验证表单内容是否填写，如果没填写完整则阻止登录 视图层js文件 //1.表单序列化 function serializeToJson(form) { var result={} var f = form.serializeArray() f.forEach(function (item) { result[item.name] = item.value }) return result } //2.判断表单字段 var result = serializeToJson(Form)//序列化获取表单 if (result.email.trim().length == 0) { alert(&quot;请输入邮箱&quot;) // 阻止表单默认提交 return false } (4)服务端验证。 验证邮箱和密码是否输入（错误状态码400） 服务器接收数据，验证表单内容是否填写，如果没填写完整则阻止登录 （4.1）创建登录路由页面 router.get('/login', function (req, res) { // res.status(200).send(&quot;后台管理页面&quot;) // res.send(&quot;后台管理页面&quot;) res.render(&quot;admin/login.html&quot;) }) （4.2）登录功能操作 router.post('/login', async (req, res) =&gt; { const { email, password } = req.body //解构语法，把对象中的req.body.email的值赋值给了email，把对象中的req.body.password的值赋值给了password // res.send('ok') // 1.验证用户是否输入了邮箱和密码（验证form表单传过来的数据是否存在） if (email.trim().length == 0 || password.trim().length == 0) return res.status(400).render(&quot;admin/err.html&quot;, { msg: '邮箱或者密码错误' }) //状态码400 请求信息有问题 // 2.根据邮箱地址查询用户信息是否存在 // 查询到用户，则user表中有对象，否则为空 let user = await User.findOne({ email }) if (user) { //查询到了 // 将form传递的密码和数据库中的进行比对 let isValid = await bcrypt.compare(password, user.password) if (isValid) { req.session.username=user.username //将用户名存储到session对象 // res.send('登录成功') req.app.locals.userInfo=user;//将用户信息存放到模板 req.app.locals.名称=变量 res.redirect('/user') } else { res.status(400).render(&quot;admin/err.html&quot;, { msg: '邮箱或者密码错误' }) //状态码400 请求信息有问题 } } else { //没查询到 res.status(400).render(&quot;admin/err.html&quot;, { msg: '邮箱或者密码错误' }) //状态码400 请求信息有问题 } }) 此处注意：需要另外希望一个err.html文件来显示错误页面 (5)密码比对成功才能登录(密码加密技术bcrypt) let isValid = await bcrypt.compare(password, user.password) (6)cookie与session 设置session app.js const session = require('express-session') //导入express-session //配置session app.use(session({ secret: 'secret:key', saveUninitialized:false,//退出登录不会存储cookie cookie:{ maxAge:24*60*60*1000 //设置cookie过期时间为一天，如果不设置浏览器关闭则登录状态失效 } })) 使用session req.session.username = user.username //将用户名存储到session对象 (7)用户退出 点击用户退出按钮删除cookie,重定向到登录页面 //3.用户登录退出 router.get(&quot;/admin/logout&quot;, (req, res) =&gt; { //删除cookie req.session.destroy(function () { //删除Cookie res.clearCookie('connect.sid') // res.clearCookie(cookie名称) //重定向到登录 res.redirect('/admin/login') }) //删除session //重定向到登录页面 }) (8)登录拦截 1.判断是否为登录页面 当页面不是登录的页面，使用拦截器将页面重定向到登录页面 2.判断是否为登录状态 判断session是否存在来判断是否为登录状态 //拦截器,拦截登录状态 router.use('/admin', (req, res, next) =&gt; { //1.判断用户是否是登录页面 // 2.判断用户登录状态 //如果登录，将请求放行 //如果未登录，重定向到登录 if (req.url != &quot;/login&quot; &amp;&amp; !req.session.username) { //如果未登录，重定向到登录 res.redirect(&quot;/admin/login&quot;) } else { //如果登录，将请求放行 next() } }) 代码 register.js const express = require('express') const User = require('../../model/user') //user数据表 const joi = require('joi') const bcrypt = require('bcrypt') let router = express.Router() //创建router //用户首页 router.get('/admin/user', (req, res) =&gt; { res.render(&quot;admin/user.html&quot;, { msg: req.session.username }) }) //用户注册页面 router.get('/admin/register', (req, res) =&gt; { const { message } = req.query res.render(&quot;admin/user-edit.html&quot;, { message }) }) // 用户注册处理 router.post('/admin/register', async (req, res) =&gt; { // 1.验证表单内容是否符合格式 //创建验证规则 const schema = joi.object({ username: joi.string().min(3).max(20).required().error(new Error(&quot;用户名设置错误&quot;)), password: joi.string().pattern(new RegExp('^[a-zA-Z0-9]{3,30}$')).required().error(new Error(&quot;密码设置错误&quot;)), email: joi.string().required().email({ minDomainSegments: 2, tlds: { allow: ['com', 'net'] } }), role: joi.string().valid('normal', 'admin').required().error(new Error(&quot;角色值设置错误&quot;)), state: joi.number().valid(0, 1).required().error(new Error(&quot;状态值设置错误&quot;)), }) try { //验证通过执行 // 实现验证 await schema.validateAsync(req.body) } catch (e) { // 验证错误执行 //重定向到编辑页，并将错误信息传过去 return res.redirect(`/admin/register?message=${e.message}`) } // 2.验证用户（使用邮箱）是否被注册.如果找得到email说明数据库存在，否则不存在，不存在就实行添加 let user = await User.findOne({ email: req.body.email }) if (user) { //查询到了，则不能注册，重定向到注册页面 return res.redirect(`/admin/register?message=邮箱已被注册`) } // 3.对密码加密 // 3.1生成随机字符串 const salt = await bcrypt.genSalt(10) // 3.2 加密替换代码 req.body.password = await bcrypt.hash(req.body.password, salt) // 3.3 // req.body.password=password //4.增加信息 await new User(req.body).save() // await User.create(req.body) res.redirect('/admin/user') }) //404页面 router.use('/', (req, res, next) =&gt; { res.send('404') }) module.exports = router //导出模块 login.js const express = require('express') const User = require('../../model/user') //user数据表 const bcrypt = require('bcrypt') let router = express.Router() //创建router //路由 //拦截器,拦截登录状态 router.use('/admin', (req, res, next) =&gt; { //1.判断用户是否是登录页面 // 2.判断用户登录状态 //如果登录，将请求放行 //如果未登录，重定向到登录 if (req.url != &quot;/login&quot; &amp;&amp; !req.session.username) { //如果未登录，重定向到登录 res.redirect(&quot;/admin/login&quot;) } else { //如果登录，将请求放行 next() } }) // 1.登录页面 router.get('/admin/login', function (req, res) { // res.status(200).send(&quot;后台管理页面&quot;) // res.send(&quot;后台管理页面&quot;) res.render(&quot;admin/login.html&quot;) }) // 2.登录功能实现 router.post('/admin/login', async (req, res) =&gt; { const { email, password } = req.body //解构语法，把对象中的req.body.email的值赋值给了email，把对象中的req.body.password的值赋值给了password // res.send('ok') // 1.验证用户是否输入了邮箱和密码（验证form表单传过来的数据是否存在） if (email.trim().length == 0 || password.trim().length == 0) return res.status(400).render(&quot;admin/err.html&quot;, { msg: '邮箱或者密码错误' }) //状态码400 请求信息有问题 // 2.根据邮箱地址查询用户信息是否存在 // 查询到用户，则user表中有对象，否则为空 let user = await User.findOne({ email }) if (user) { //查询到了 // 将form传递的密码和数据库中的进行比对 let isValid = await bcrypt.compare(password, user.password) if (isValid) { req.session.username = user.username //将用户名存储到session对象 // res.send('登录成功') req.app.locals.userInfo = user; //将用户信息存放到模板 req.app.locals.名称=变量 res.redirect('/admin/user') } else { res.status(400).render(&quot;admin/err.html&quot;, { msg: '邮箱或者密码错误' }) //状态码400 请求信息有问题 } } else { //没查询到 res.status(400).render(&quot;admin/err.html&quot;, { msg: '邮箱或者密码错误' }) //状态码400 请求信息有问题 } }) //3.用户登录退出 router.get(&quot;/admin/logout&quot;, (req, res) =&gt; { //删除cookie req.session.destroy(function () { //删除Cookie res.clearCookie('connect.sid') // res.clearCookie(cookie名称) //重定向到登录 res.redirect('/admin/login') }) //删除session //重定向到登录页面 }) module.exports = router //导出模块 ","tags":[{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"业务 - 注册和登录","feature":"","link":"https://qin_hu.gitee.io/blog/post/zhu-ce-he-deng-lu-ye-wu/","stats":{"text":"15 min read","time":848000,"words":3008,"minutes":15},"date":"2024-01-09 17:42:59","dateFormat":"2024-01-09"},{"content":"安装mysql npm i mysql //or npm install mysql 连接数据库 //引入模块 const mysql = require('mysql') // 连接mysql const connection = mysql.createConnection({ host: 'localhost', //本地 user: 'root', password: 'root', database: 'hero' }) // 建立连接 connection.connect(); //---------- //数据库操作 // let querySql = 'select * from user' // connection.query(querySql, function (err, results, fields) { // if (err) throw err // console.log(results) // }) //------------ // 结束连接 connection.end() 数据库操作 1.查询操作 查询表内容 let querySql = 'select * from user'//user为表名 connection.query(querySql, function (err, results, fields) { if (err) throw err console.log(results) }) 查询一行 let querySqlByid = 'select * from user where uid=123461' connection.query(querySqlByid, function (err, results, fields) { if (err) throw err console.log(results) }) 2.增加操作 let addSql='INSERT INTO user (id,username,pwd,name,nameimg,tel,permissions,address) VALUES (0,?,?,?,?,?,?,?)'//语句 let addSqlParams=['111','小明','111','小明','小明','111','111','111']//内容 connection.query(addSql, addSqlParams, (err, result) =&gt; { if (err) { console.log('[增加失败] - ', err.message); return; } console.log('--------------INSERT-------------'); console.log('增加成功 ID:',result.insertId); console.log('增加成功:', result); console.log('--------------------------------\\n\\n'); }); 3.更新操作 let updataSql = 'UPDATE user SET username = ?,pwd = ? WHERE id = ?' let updataSqlParams = ['222', '222', 1] connection.query(updataSql, updataSqlParams, (err, result) =&gt; { if (err) { console.log('[更新失败] - ', err.message); return; } console.log('----------UPDATE---------------'); console.log('更新成功', result.affectedRows); console.log('-------------------------------\\n\\n'); }); 4.删除操作 let delSql = 'DELETE FROM user where id=1'; connection.query(delSql, (err, result) =&gt; { if (err) { console.log('[删除失败] - ', err.message); return; } console.log('--------DELETE---------------'); console.log('删除成功', result.affectedRows); console.log('------------------------\\n\\n'); }); ","tags":[{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"数据库交互 - nodeJs使用mysql","feature":"","link":"https://qin_hu.gitee.io/blog/post/nodejs-shi-yong-mysql/","stats":{"text":"2 min read","time":100000,"words":315,"minutes":2},"date":"2024-01-09 17:41:49","dateFormat":"2024-01-09"},{"content":"1.介绍与安装 介绍 MongoDB是非关系型数据库，基于分布式文件存储的开源数据库系统 理解关系型数据库与非关系型数据库（表就是关系） 关系型数据库（mysql） 关系型数据库需要数据库操作 关系型数据库在操作之前需要设计表结构 数据支持约束（唯一性,主键,默认值,非空） 非关系型数据库（MongoDB） 非关系数据库非常灵活 大多是 key-value 在MongoDB中 数据库=&gt;数据库 数据表=&gt;集合（数组） 表记录-&gt;（文档对象） 不需要设计表结构 可以任意存数据，无结构性 组成：数据库，集合，文档 { 数据库名称：{ 表名称：[ 字段 ] } } 安装 下载地址 https://www.mongodb.com/try/download/community 配置环境变量 复制mongoDB下载的bin地址：C:\\Program Files\\MongoDB\\Server\\5.0\\bin 打开环境变量-&gt;找到path 检测安装是否成功 命令行输入mongod --version 2.开始 启动数据库 ： mongod 默认使用执行 mongod 命令所处盘符根目录下的/data/db 作为自己的数据存储目录，第一次执行该命令需要手动新建data/db目录，用于存储数据 如果想修改默认的数据存储目录 ：mongod --dbpath =数据存储目录路径 关闭数据库 控制台ctrl+c 连接数据库 mongo 退出连接 exit 3.基本命令 查看显示所有数据库 show dbs 切换到指定的数据库 use 数据库名 查看当前操作的数据库 db 插入数据 mongo.表名.insert 查看表内容 db.表名.find() 查看更多表数据（数据太多加载不出来时） it+ 回车 4.在node中操作MongoDB数据库（mongoose模块） 4-1.下载第三方模块mongoose npm i mongoose 4-2.基本步骤 4-2-1. 引入模块 const mongoose = require('mongoose') 4-2-2. 创建模型（设计一个数据库） mongoose.connect(&quot;mongodb://localhost/test1&quot;);//test1为数据库名称 4-2-3. 设置文档结构（表结构） Scheme方法 设置字段必须有 required：true const Schema = mongoose.Schema //引入Schema方法 var userSchema = new Schema({//userSchema数据库结构方法名 username: { type: String, required: true//设置字段为必须 }, pwd: { type: String, required: true } }) 4-2-4. 实例化文档结构（将文档结构发布为模型） const User = mongoose.model('User', userSchema) 4-2-5. 对数据表增删改查操作(增删改查) 4-2-6. 持久化保存kitty实例 5.对数据表增删改查操作 代码运行一次就会往数据库执行一次操作 表名.findByIdAndRemove(('id名'),{字段内容},callback) 表名.find/remove/updateByIdAndRemove(('id名'),{字段内容},callback) 5.1增加（插入） const admin = new User({ username: 'admin', pwd: '123456', email: '123456@qq.com' }) admin.save(function (err, ret) { if (err) { console.log('保存失败') } else { console.log('保存成功') console.log(ret)//打印结果 } }) 5.2查询 查询所有 User.find(function (err, ret) { if (err) { console.log(err) } else { console.log('查询成功'); console.log(ret) } }) 条件查询：查询所有username是admin的数据 User.find({username:'admin'},function(err,ret){ if(err){ console.log(err) }else{ console.log('查询成功'); console.log(ret) } }) 查询单个 User.findOne({username:'admin'},function(err,ret){ if(err){ console.log(err) }else{ console.log('查询成功'); console.log(ret) } }) 根据id查询单个 User.findById('61b373ab90b40560339ded85',function(err,ret){ if(err){ console.log('更新失败'); }else{ console.log('更新成功'); console.log(ret); } }) 查询固定键值 //只会查询到'first', 'last'字段 Model.find({}, ['first', 'last'], function (err, docs) {}) 模糊查询 var text = 'Nodejs';//动态传入的变量 Article.find({ content: { $regex: text, $options: 'i' }}, function (err, docs) {}); /*$options选项值： i 大小写不敏感 m $regex包含正则^,$符号的表达式 x 忽略空格 s 允许逗点匹配所有字符串*/ 5.3删除 根据条件删除所有 User.remove({ username:'admin' },function(err,ret){ if(err){ console.log('删除失败'); }else{ console.log('删除成功'); console.log(ret); } }) 根据条件删除一个 User.findByOneAndRemove({ username:'admin'},{password:'123456'},function(err,ret){ if(err){ console.log('删除失败'); }else{ console.log('删除成功'); } }) 根据id删除一个 User.findByIdAndRemove('61b373ab90b40560339ded85',{password:'123456'},function(err,ret){ if(err){ console.log('删除失败'); }else{ console.log('删除成功'); } }) 5.4更新数据 根据条件更新所有 User.update({username:'admin'},{pwd:'123'},function(err,ret){ if(err){ console.log('更新失败'); }else{ console.log('更新成功'); console.log(ret); } }) 根据条件更新一个 User.findOneAndupdate({username:'admin'},{pwd:'123'},function(err,ret){ if(err){ console.log('更新失败'); }else{ console.log('更新成功'); console.log(ret); } }) 根据id更新一个 User.findByIdAndUpdate('61b373ab90b40560339ded85',{pwd:'123'},function(err,ret){ if(err){ console.log('更新失败'); }else{ console.log('更新成功'); console.log(ret); } }) 6.mongodb版本的curd 操作文件文档中操作 1.引入mongoose数据库框架 2.连接数据库 3.设计文档结构 引入Schema 创建文档结构对象 4.导出模型构造函数 // -------------使用mongodb获取到数据 // 引入mongoose数据库框架 const mongoose=require('mongoose') // 连接数据库 mongoose.connect(&quot;mongodb://localhost/test1&quot;) // 创建文档结构变量 const Schema=mongoose.Schema // var studentSchame=new Schema({ name:{ type:String, required:true }, tel:{ type:Number, required:true, // enum:[0,1],// 枚举0/1 default:0//默认为0 }, state:{ type:String, required:true }, cttime:{ type:Date, // required:true } }) // 导出模型构造函数 module.exports=mongoose.model('student',studentSchame) 路由器操作 在路由中进行增删改查 使用mongodb的增删改查语法 //渲染主页 router.get('/', (req, res) =&gt; { //主页 // 数据操作模块的find方法 student.find((err, studentList) =&gt; { if (err) { res.status(500).send(&quot;server error&quot;) } else { res.render(&quot;index.html&quot;, { studentList }) } }) //使用模板引擎渲染 }) //增加处理 router.post('/add', (req, res) =&gt; { // 1.获取表单提交数据 // 2.操作处理 //将数据保存到db.json // 3.发送响应 // /mongdb中添加必须要new一个对象 let d=new Date() req.body.cttime=d.toLocaleDateString(); new student(req.body).save((err) =&gt; { if (err) { console.log(err) res.status(500).send(&quot;server error&quot;) } res.redirect('/') //重定向到首页 }) }) // 7.运算符匹配符 1.$in根据条件查询或者删除多个/单个 根据id查询后执行删除 //4.根据id删除单个 .get('/api/commodityDelOne',async (req, res) =&gt; { // 删除单个 // let res1=await Commodity.remove({ // _id: { // $in: ['61f90558f8cdfdceff1c394d'] // } // }) // 删除多个 let res1=await Commodity.remove({ _id: { //$in字符选择查询_id字段带有61f91818353f2b794afef792，61f9190d6a50f6c0160e40a8的条件行 $in: ['61f91818353f2b794afef792', '61f9190d6a50f6c0160e40a8'] } }) if(res1){ res.send('删除成功') } }) ","tags":[{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"数据库交互 - MongoDB数据库","feature":"","link":"https://qin_hu.gitee.io/blog/post/mongodb-shu-ju-ku/","stats":{"text":"7 min read","time":405000,"words":1550,"minutes":7},"date":"2024-01-09 17:41:03","dateFormat":"2024-01-09"},{"content":"1. 认识NodeJs 认识 是什么？ node.js是Javascript的运行环境 能干嘛？前端脱离后端，直接通过Js写项目 去哪下？node.js官网 初体验(REPL) read 阅读（读取js代码） exec 执行（执行输出代码） print 打印 （打印输出代码） loop 循环（循环以上命令） 常用命令 切换文件 cd 文件名 运行js文件 node 文件名 退出(按两下ctrl+c) 清除 （cls） 运行代码 (node 文件名) 练习 输出Hello World 2. node模块系统 2-1.简介 使用nodejs编写应用程序主要使用: 2-1-1. ECMAscript语法：变量,判断,循环等。 JS三大组成部分（ECMA/DOM（document）/BOM（window,location等）） 2-1-2. 内置核心模块：HTTP模块,fs文件操作,url路径,path路径模块,os操作系统 内置模块api体验 2-1-3. 自定义模块（自己创建的js） CommonJS模块规范: (1)一个文件就是一个模块 (2)通过export和modul.exports来导出模块中的成员 (3)通过require来加载模块 1-3-1.自定义模块步骤 步骤1.导出成员（声明哪些方法可以被外部使用） //写法1 exports.属性/方法=功能 //写法2 module.exports.属性/方法=变量名： 步骤2.外部引入使用 //使用 先引入再调用 var 对象=require('路径文件名'); //对象.属性或方法名 2-1-4. 第三方模块 练习 创建a.js和b.js文件，在a.js引入b.js模块 3.常用内置模块 OS path 输出文件名 path.basename(path[, ext]) console.log(path.basename(&quot;/node/base/path/xx/js/index.js&quot;)); // 最后输出 index.js 如果只想获取文件名，不要后缀 const path = require('path'); console.log(path.basename(&quot;/node/base/path/xx/js/index.js&quot;, '.js')); 返回一个path的目录名 path.dirname(path) const path = require('path'); const filepath = '/node/base/path/index.js'; console.log(path.dirname(filepath)); // 输出 /node/base/path 返回一个对象，对象的属性表示path的元素 path.parse(path) const path = require('path'); const filepath = '/node/base/path/index.js'; console.log(path.parse(filepath)); // 输出如下： /* { root: '/', dir: '/node/base/path', base: 'index.js', ext: '.js', name: 'index' } */ file 读写文件操作 1.读 fs.readFile() fs.readFile('',function(err,data){ if(err){ }else{ } }) 2.写 fs.write() fs.write('文件路径',&quot;内容&quot;,funtion(err){ console.log('ok'); }) http 创建serve服务器 var http=require('http') // 创建serve var server=http.createServer() // 添加请求 server.on('request',(req,res)=&gt;{ console.log(&quot;请求路径是:&quot;,req.url) //res.end(&quot;内容&quot;)方法表示写入并关闭，是res.write和res.end()的缩写; res.end()中的内容只能是字符串或者二进制数据 res.end(&quot;server is ok!&quot;) }) // 启动监听端口 server.listen(80,()=&gt;{ console.log(&quot;当前端口号：localhost:80&quot;) }) url 解析URL地址 url.parse() var http = require(&quot;http&quot;); var url = require(&quot;url&quot;); var server = http.createServer(function(req,res){ var pathname = url.parse(req.url).pathname; var query = url.parse(req.url).query; console.log(&quot;patname:&quot;+ pathname); console.log(query); res.end(); }); server.listen(3000,&quot;127.0.0.1&quot;); 4.请求与响应的一些方法 1. request 1-1. request.method 获取视图请求方法 if(req.method==&quot;get&quot;){...} 1-2. request.url 获取当前url地址 1-3. request.body 获取post请求数据（依赖模板引擎） 1-4. request.query 获取get请求数据（依赖模板引擎） 2. response 2-1. response.end(&quot;text&quot;); 响应内容为text，响应并终止; 注意，request.end只能响应二进制数据或者字符串; request.end()与request.write()的缩写; 2-2. response.write(&quot;内容&quot;) 写响应内容 2-3. response.writeHead（&quot;200&quot;） 写响应头 res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/html&quot; }); 2-4.response.setHeader('Location','/') 设置响应头跳转 2-5. res.statusCode=320 设置响应码 2-6.三种&quot;响应字符串&quot;方法 //意：响应并关闭 res.end(&quot;响应成功&quot;) //会乱码 res.send(&quot;响应成功&quot;); //自动识别 直接响应 res.render(&quot;响应成功&quot;) //自动识别，只能打开指定文件字符串并响应，必须配合模板引擎使用 2-7.重定向 res.redirect(&quot;/&quot;) 重定向到根路径 5. npm的基本使用 1.简介 npm，全名 node package manger。 npm 是Node的开放式模块登记和管理系统，是Node.js包的标准发布平台，用于Node.js包的发布、传播、依赖控制，网址：https://www.npmjs.com/ npm 提供了命令行工具，可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包 下载node所需的第三方模块 2.安装 安装好nodejs后就安装好了npm，这时系统自带npm命令 检测是否安装成功 npm -v npm 在按照 Node.js 时会连带被安装。但有可能不是最新版本，需要 npm install npm@latest -g 升级到最新版本 3.使用 初始化 新建一个文件夹然后运行 npm init //或者 npm init -y //不填写相关信息，默认初始化 初始化后会生成package.json文件（package.json就是记录所有安装的包的信息的文件。） 安装模块 npm insatll 模块 [安装可选参数] //或者 npm install 模块@版本号 [安装可选参数] 安装参数 --save 记录生产环境所需模块（默认） --save-dev 记录开发环境所需模块 --g 该模块可在命令行运行(global) 都安装: npm install 只安装生产环境：npm install -production 安装模块后会出现一个node_modules文件夹，node_modules文件夹就是所有包安装的位置。 卸载模块 npm uninstall 模块 查看模块 npm list 4.常用第三方模块安装命令 1. nodemon 可以随时监听文件的变更，自动重启服务 npm install -g nodemon 2.momentJs 日期时间类 npm install moment 6. Express Express简介 是什么：基于nodeJs开发的一个框架 好 处：加快项目开发，便于团队协作 使用 创建项目文件夹 安装express框架 安装命令 npm install express 创建server服务 创建app.js入口文件 引入模块 创建web服务器 创建路由（http创建时：是创建监听并请求事件，这里框架引出路由概念） 启动服务 // 1.引入模块 const express=require('express') // 2.创建web服务器 const app=express() //3.创建路由（http创建时：创建监听并请求事件） app.get('/',function(req,res){ //响应字符串 res.send(&quot;响应成功&quot;); //自动识别 直接响应,意：响应并关闭 }) // 4.启动服务 app.listen('2002',function(){ console.log(&quot;ok: http://localhost:2002 &quot;); }) Express路由 路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等） 基本语法 发送get请求app.get() 发送post请求app.post() 发送任意请求app.all() 非完全匹配url路径发送任意请求app.use() //app.HTTP请求类型(请求路径,回调函数) //1.发送get请求 app.get('/',function(req,res){}) //2.发送post请求 app.post('/',function(req,res){}) //3.发送任意请求 app.all('/',function(req,res){}) //4.非完全匹配url路径发送任意请求 app.use('/',function(req,res){}) Express 定义了如下HTTP 请求类型方法： get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, 和 connect。 7.模板引擎 1.简介 模版引擎是第三方模块。可以让开发着以更友好的方式拼接字符串，使项目代码更加清晰，更加易于维护。常见的模板引擎有ejs jade，这里使用art-template 2.安装 npm install art-template //简写： npm i art-template 在express中使用： npm install express-art-template 3.使用 在node中使用的标准语法 const template = require('art-template');//引入模块 const html = template(__dirname + '/tpl-user.art', { user: { name: 'aui' } }); //const html = template('模版路径'， '数据') //参数一： 模版引擎的路径（绝对路径，需要path.join 拼接） //参数二：要传递给模版引擎的数据 在express中使用的标准语法 （1）声明所使用的模板引擎 app.engine('html', require('express-art-template')); //第一个参数告诉模板引擎要渲染文件的后缀是什么，这里是‘html’ （2）设置模板引擎渲染指定文件夹（可选） app.set('views','./views') ; // app.set('文件名','文件所在路径') ; (3)使用res.render语法得到数据 res.render(模板文件,模板数据) 4.常用的语法 1.将信息存放到模板 locals let n={a:12,b:23} //在app.js中 app.locals.numInfo=n //在其他文件中 req.app.locals.numInfo=n 视图中声明 {{numInfo.a}} 渲染结果 12 8.发送基本请求（POST，GET） 1.创建服务器 2.渲染html页面 向服务器发送请求获取到要渲染的网页（html文件） 渲染html文件的几种方法 fs读取文件发送 fs.readFile(&quot;./view/add.html&quot;, { encoding: 'utf-8' }, function (err, data) { if (err) { res.writeHead(404, { &quot;Content-Type&quot;: &quot;text/html&quot; }); res.end(&quot;404&quot;); } else { res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/html&quot; }); res.end(data) } }) res.sendFile() 响应发送文件的方式 res.sendFile(__dirname+'/index.html') res.render('index.html') 模板引擎响应方法 需要先配置模板引擎 res.render('index.html') 3.将视图数据提交到后端 输入数据，点击提交，将html数据提交到后端 使用form时,将action设置为后端要处理的路由,input设置name属性接收输入的数据 //提交路径为&quot;/myLogin&quot;,方法为post &lt;form action=&quot;/myLogin&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;user&quot; name=&quot;user&quot;&gt; &lt;input type=&quot;password&quot; id=&quot;pwd&quot; name=&quot;pwd&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt; post请求数据在响应头，get请求数据会拼接在url路径之后 4.创建路由处理视图提交的数据 路由文件与视图提交的路径相同 创建路由 //post请求使用app.post() app.post('/mylogin',function(req,res){ }) //get请求用app.get() 获取视图提交的数据 由于post请求数据在响应头，get请求数据会拼接在url路径之后 如果是get请求 通过url内置模块获取到get发送的请求，并通过url.parse方法将数据转化为对象 //引入模块 const url=require('url') //url.parse方法将数据转化为对象 var paramobj = url.parse(req.url, true).query; 如果是post请求 方法1.Node原生的http模块中 通过一个事件：监听是否有数据 req.on(&quot;data&quot;,(chunk)=&gt;{ console.log(chunk.toString());//chunk就是传过来的数据,格式为Buffer,通过toString()转化为字符串 let obj=querystring.parse(chunk.toString())//将数据转化为对象 } 方法2.Express中间件body-parserlosspm 引入bodyParser模块 解析 application/json 解析 application/x-www-form-urlencoded 打印结果 //引入bodyParser模块 const bodyParser=require('body-parser'); //解析 application/json app.use(bodyParser.json()); //解析 application/x-www-form-urlencoded app.use(bodyParser.urlencoded({extended:false})) //在路由中打印结果 console.log(req.body); 9.响应静态文件 由于发送请求时，文件中的css,img,js文件也会发送请求,故需要以下方法响应资源。 方法1.使用express 当以/public/开头的时候,去./public/目录中找到对应的资源，这种方式更容易辨识，使用app.use()方法，express.static()方法解析 1. 直接响应public下的目录 app.use('/public/',express.static('./public/')) 2. 必须是参数1为名的目录的资源具体路径 app.use('/a/',express.static('./public/')) //此时访问public下的静态资源,必须使用/a/public访问 3. 当省略第一个参数的时候,则可以通过/public的方式来访问 app.use(express.static('./public/')) 方法2.使用内置模块path const path=require('path') app.use(express.static(path.join(_dirname,'public'))) 10.创建Router路由（路由优化） 1.路由器中处理 1-1.创建routes文件夹 express中的Router（创建route文件夹）作用就是为了方便我们更好的根据路由去分模块。避免将所有路由都写在入口文件中。 1-2.在routes文件夹里创建路由器 假设创建一个user.js路由器 1-3.路由器中的基本步骤 引入express模块 const express=require('express'); 创建路由器对象 let router=express.Router(); 往路由器中挂载路由 app.get() , app.post() , app.use() , app.all() 在此处写登录，注册等路由方法 router.get('/login',(res,req)=&gt;{ res.send('登录') }) 导出路由器对象 module.exports=router; 2.服务器中处理(app.js入口文件) 2-1.引入user路由器 const userRouter=require('./routes/user.js') console.log(userRouter)//打印路由验证是否正确 2-2.使用路由器 app.use()方法 给每个路由器下的路由添加了前缀 app.use('/user',userRouter); &gt;参数一给每个路由器下的路由添加了前缀,访问时由/login变成/user/login &gt;userRouter是引入的路由器变量名称 注意，创建index首页路由器时，使用路由器不需要添加前缀名称 app.use('/',indexRouter); 方法2：引入user路由器 const router=require('./routes') 使用路由器 app.use(router) 11.中间件 一.概念 http请求中的过滤层（http请求交给方法处理前，先交给另一个方法过滤）。 中间件是在获取请求和发送响应之间在服务器上运行的代码 应用场景：判断登录状态,检测RBSAC权限，错误捕获等 中间件代码从上往下执行 二.next方法 可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配。调用next方法&quot; next（）&quot;将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。 //app.use('/')中的'/'表示请求时请求的初始中间件，写在最上面 app.use('/',(req,res,next)=&gt;{ next() //会进入下一个中间件app.get() }) app.get('/', (req, res) =&gt; { fs.readFile('./views/index.html', 'utf8', (err, data) =&gt; { if (err) { res.send(err) } else { res.send(data) //遇到结束请求的中间件停止 } }) }) 可以在next()方法中传入一个参数err,即next(err)。next传递err则匹配第一个含有err的中间件.（可以在fs渲染html页面时使用） app.use('/',(req,res,next)=&gt;{ fs.readFile('./views/index.html', 'utf8', (err, data) =&gt; { if (err) { next(err) //会进入含有err的中间件 } else { res.send(data) //遇到结束请求的中间件停止 } }) }) app.use((err,req, res, next) =&gt; { res.status(404).send(&quot;404页面&quot;) // //html页面 // fs.readFile(&quot;./views/404.html&quot;,'utf8', (err, data) =&gt; { // if (err) { // res.send(err) // }else{ // res.status(404).send(data) // } // }) }) 三.主要作用 中间件就是一堆方法，主要由中间件方法以及请求处理函数组成。可以接收客户端发来的请求、可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。 1. 错误处理中间件 1）自定义404页面（由于中间件从上往下执行,故在代码中要放到最后写） 当找不到地址栏的地址时使用该中间件 app.use((req, res, next) =&gt; { res.status(404).send(&quot;404页面&quot;) // //html页面 // fs.readFile(&quot;./views/404.html&quot;,'utf8', (err, data) =&gt; { // if (err) { // res.send(err) // }else{ // res.status(404).send(data) // } // }) }) 2).错误统一处理(在fs读文件时，在出现err时使用next(err)传入另外一个中间件统一处理) 错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。 错误处理中间件和其他中间件定义类似，只是要使用 4 个参数，而不是 3 个，其签名如下： (err, req, res, next)。 router.get('/', (req, res,next) =&gt; { fs.readFile('./views/index.html', 'utf8', (err, data) =&gt; { if (err) { next(err) // res.send(err) } else { res.send(data) } }) }) // 错误统一处理 router.use((err,req,res,next)=&gt;{ res.send('网络错误/文件错误') console.log(err); }) 总结：错误处理的中间件,一个是设置404页面,一个是错误统一处理。 next() next不传参数时：匹配下一个url next(err) next传递err则匹配含有第一个含有err的中间件 2.内置中间件（配置响应静态文件） 语法： express.static(root, [options]) //例，简单响应public静态资源方法 app.use(express.static('./public/')) 精心设计的响应静态资源方法(推荐) var options = { dotfiles: 'ignore', etag: false, extensions: ['htm', 'html'], index: false, maxAge: '1d', redirect: false, setHeaders: function (res, path, stat) { res.set('x-timestamp', Date.now()); } } app.use(express.static('public', options)); 3.常用中间件body-parser的使用 可用于解析post请求体 body-parser是一个HTTP请求体解析中间件，使用这个模块可以解析不同格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件，提供方法如下： bodyParser.json(options) 解析JSON格式数据 bodyParser.raw(options) 解析二进制格式数据（Buffer流数据） bodyParser.text(options) 解析文本格式数据 bodyParser.urlencoded(options) 解析UTF-8的编码数据 4.第三方中间件 express内置了很多第三方中间件。 5.应用级中间件 应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写。 6.路由级中间件 路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router()。 路由级使用 router.use() 或 router.VERB() 加载 ","tags":[{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"nodeJs入门","feature":"","link":"https://qin_hu.gitee.io/blog/post/nodejs-ru-men/","stats":{"text":"19 min read","time":1117000,"words":4412,"minutes":19},"date":"2024-01-08 13:21:10","dateFormat":"2024-01-08"},{"content":"1. 了解商业模式 成功可能性：聪明，行业深耕，有钱 卖货赚钱 网上，线下 打算卖啥？ 自己生产或者代理？ 资金？ 怎么卖？ 提供服务 a. 体力服务（自己做或者组织做） b. 技能和专业服务 c. 脑力服务（个人专业咨询） 销售工具赚钱 开店的服务，提供别人赚钱的工具 培训赚钱 才艺赚钱，技能赚钱，认知培训。 短视频培训。 分销（销售） 直销：邀请人使用产品 内容赚钱 短视频 提供行业信息，提供专业信息，教别人 投资赚钱 寻找投资项目 低成本创业： 你想解决什么问题？ 研究会购买人的特点 做产品（实物类型，服务产品，虚拟产品）。解决问题 营销策略。 赚钱方案 开发一个App，在附近推广自己的技能服务，然后去培训。 或者是收集推销的信息，推广赚差价。 基本思路： 要创业，你需要的不仅仅是梦想。要让轮子运转起来，您需要： 利用您的可用时间：在雄心和现实与您的商业抱负之间取得平衡是件好事。 确定一个新的商业想法：这可能来自您的个人兴趣、市场机会、经验——实际上，任何地方。 验证您的商业想法：这是您确定您的想法是否可行的地方。人们愿意为此花钱吗？ 寻找一个企业名称：一个响亮的名称应该简短、易记、具有原创性。如果您需要帮助，请查看我们的企业名称生成器。 制定计划：您的商业计划对于让您的业务步入正轨以及确保合作伙伴、投资者、贷方等的安全至关重要。 了解企业财务：开设企业银行账户，确保资金安全，并建立强大的簿记和会计流程。在商业计划模板中制定您的目标可能是一个好主意，以帮助获得资金。 开发您的产品或服务：有趣的部分！这是您将产品或服务理念变为现实的地方。 选择业务结构：您的业务结构会影响税收、运营、个人责任等。选择正确的业务结构就是在您所需的法律和财务保护与不同选择提供的灵活性之间取得平衡。 研究许可和法规：您的企业须遵守您所在地区的企业法律以及您所在行业的特定法律和法规。了解这一点很重要，可以避免日后出现更大的问题。 选择您的软件系统：会计、电子邮件、广告、项目管理——您需要一整套技术堆栈来运营您的业务。 寻找营业地点：根据空间、零售需求和履行需求确定可以在哪里开设商店。 计划工作量和团队规模：如果您计划自己完成所有工作，那么您可投入的时间就会受到限制。如果您计划雇用帮助，则需要考虑这些成本以及寻找和入职自由职业者或员工所需的时间。 开展您的业务：利用您的网络，通过促销引起轰动，并测试付费广告以宣传您新推出的业务。 ","tags":[{"index":-1,"name":"日常","slug":"DgWk1dLxg","used":true,"link":"https://qin_hu.gitee.io/blog/tag/DgWk1dLxg/"}],"title":"随笔","feature":"","link":"https://qin_hu.gitee.io/blog/post/chuang-ye/","stats":{"text":"3 min read","time":173000,"words":865,"minutes":3},"date":"2024-01-06 21:47:58","dateFormat":"2024-01-06"},{"content":"参考链接 1. 布局 线性布局 Column容器内子元素按照垂直方向排列，Row容器内子元素按照水平方向排列。 示例 Column @Entry @Component struct Layout { build() { Column() { } .width('100%') .height(100) .backgroundColor(Color.Yellow) } } Row @Entry @Component struct Layout { build() { Row() { } .width('100%') .height(100) .backgroundColor(Color.Yellow) } } 设置间距 space Column @Entry @Component struct Layout { build() { Column({ space:50 }){ Column() { } .width('100%') .height(100) .backgroundColor(Color.Yellow); Column() { } .width('100%') .height(100) .backgroundColor(Color.Red); } } } Row @Entry @Component struct Layout { build() { Row({ space:50 }){ Row() { } .width('150px') .height(300) .backgroundColor(Color.Yellow); Row() { } .width('150px') .height(300) .backgroundColor(Color.Red); } } } alignItems属性设置交叉轴 交叉轴为垂直方向时，取值为VerticalAlign类型，水平方向取值为HorizontalAlign。 设置Column容器内水平方向的排列 条件：Column设置宽度，子元素根据宽度排列。使用HorizontalAlign @Component struct ColumnComponent { build(){ Column({ space:10 }){ Column(){ }.width('50%') .height(50) .backgroundColor('#222'); Column(){ }.width('50%') .height(50) .backgroundColor('#ff4c9951') } .height(&quot;100%&quot;) .width(&quot;100%&quot;) .alignItems(HorizontalAlign.Center) // .alignItems(HorizontalAlign.End) // .alignItems(HorizontalAlign.Start) } } 设置Row容器内垂直方向的排列 条件：给Row设置高度，使子组件能够有空间垂直排列 @Component struct RowComponent { build(){ Row(){ Column(){ } .width(&quot;20%&quot;) .height(30) .backgroundColor(&quot;#222&quot;); Column(){ } .width(&quot;20%&quot;) .height(30) .backgroundColor(&quot;#ff257031&quot;); Column(){ } .width(&quot;20%&quot;) .height(30) .backgroundColor(&quot;#222&quot;); } .height(&quot;100%&quot;) .alignItems(VerticalAlign.Center) // .alignItems(VerticalAlign.Bottom) // .alignItems(VerticalAlign.Top) } } justifyContent属性设置子元素在容器主轴上的排列方式 Column容器内子元素在垂直方向上的排列 @Component struct ColumnComponent { build(){ Column(){ Column(){ }.width(150) .height(180) .backgroundColor('#222') Column(){ }.width(150) .height(180) .backgroundColor('#ffcb4040') } .height('100%') // .justifyContent(FlexAlign.Center) // .justifyContent(FlexAlign.Start) .justifyContent(FlexAlign.End) } } Row容器内子元素在水平方向上的排列 @Component struct RowComponent{ build(){ Row(){ Column(){ }.width(50) .height(50) .backgroundColor('#222') Column(){ }.width(50) .height(50) .backgroundColor('#ffca1313'); }.width('100%') // .justifyContent(FlexAlign.Center) // .justifyContent(FlexAlign.End) // .justifyContent(FlexAlign.SpaceBetween) // .justifyContent(FlexAlign.SpaceEvenly) .justifyContent(FlexAlign.SpaceAround) } } 层叠布局 Stack 层叠布局通过Stack容器组件实现位置的固定定位与层叠，容器中的子元素（子组件）依次入栈，后一个子元素覆盖前一个子元素，子元素可以叠加，也可以设置位置。 Stack元素的子元素默认居中排列。 默认层叠布局 Column(){ Stack({ }) { Column(){}.width('90%').height('100%').backgroundColor('#ff58b87c') Text('text').width('60%').height('60%').backgroundColor('#ffc3f6aa') Button('button').width('30%').height('30%').backgroundColor('#ff8ff3eb').fontColor('#000') }.width('100%').height(150).margin({ top: 50 }) } 通过alignContent参数实现位置的相对移动 设置子容器的默认位置,有9种对齐方式： @Component struct StackComponent{ build(){ Stack(){ // ... } .width('100%') .height(200) .backgroundColor('#ff66bbe2') .alignContent(Alignment.TopStart) } } 设置层叠顺序（zIndex） @Component struct StackComponent{ build(){ Stack(){ Column(){ } .width(150) .height(150) .backgroundColor(&quot;#ffeeb9b9&quot;) .zIndex(1); Column(){ } .width(100) .height(100) .backgroundColor(&quot;#ffca4b4b&quot;) .zIndex(2); } .width(200) .height(200) .backgroundColor('#ff66bbe2') } } 弹性布局(Flex) 基本示例： @Component struct FlexPage { build() { Flex({justifyContent:FlexAlign.SpaceAround,wrap:FlexWrap.Wrap}){ Column(){ } .width(60) .height(60) .backgroundColor('#222'); Column(){ } .width(60) .height(60) .backgroundColor('#ffa21212'); Column(){ } .width(60) .height(60) .backgroundColor('#ffcf9a9a') } } } 详细参考官网: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-layout-development-flex-layout-0000001504525013-V2#section6594921192714 相对布局（RelativeContainer） 支持容器内部的子元素设置相对位置关系,子元素支持指定兄弟元素作为锚点，也支持指定父容器作为锚点，基于锚点做相对位置布局。 锚点：通过锚点设置当前元素基于哪个元素确定位置。 对齐方式：通过对齐方式，设置当前元素是基于锚点的上中下对齐，还是基于锚点的左中右对齐。 使用：使用anchor属性先指定锚点，再设置对齐方式。 ID默认为“container”，其余子元素的ID通过id属性设置。未设置ID的子元素在RelativeContainer中不会显示。 @Entry @Component struct RelativePage { build(){ Row(){ RelativeContainer(){ Row(){ } .width(50) .height(50) .backgroundColor(&quot;#ffc48686&quot;) .id(&quot;boxOne&quot;) .alignRules({ top:{ anchor:&quot;__container__&quot;, align:VerticalAlign.Top }, right:{ anchor:&quot;__container__&quot;, align:HorizontalAlign.End } }) Row(){ } .width(50) .height(50) .backgroundColor(&quot;#ff3fab7c&quot;) .id(&quot;boxTwo&quot;) .alignRules({ top:{ // 关联父组件 anchor:&quot;__container__&quot;, align:VerticalAlign.Top }, left:{ anchor:&quot;__container__&quot;, align:HorizontalAlign.Start } }) } .width(200) .height(200) .border({ width:2, color:&quot;#fff51515&quot;, }) } .height(&quot;100%&quot;) } } 栅格布局（GridRow/GridCol） 设置断点 栅格系统默认断点将设备宽度分为xs、sm、md、lg四类，尺寸范围如下 xs - [0, 320）- 最小宽度类型设备。 sm - [320, 520) - 小宽度类型设备。 md - [520, 840) - 中等宽度类型设备。 lg - [840, +∞) - 大宽度类型设备。 在GridRow栅格组件中，允许开发者使用breakpoints自定义修改断点的取值范围，最多支持6个断点，除了默认的四个断点外，还可以启用xl，xxl两个断点，支持六种不同尺寸（xs, sm, md, lg, xl, xxl）设备的布局设置。 GridRow({ breakpoints: { value: ['200vp', '300vp', '400vp', '500vp', '600vp'], reference: BreakpointsReference.WindowSize } }) { ForEach(this.bgColors, (color, index) =&gt; { GridCol({ span: { xs: 2, // 在最小宽度类型设备上，栅格子组件占据的栅格容器2列。 sm: 3, // 在小宽度类型设备上，栅格子组件占据的栅格容器3列。 md: 4, // 在中等宽度类型设备上，栅格子组件占据的栅格容器4列。 lg: 6, // 在大宽度类型设备上，栅格子组件占据的栅格容器6列。 xl: 8, // 在特大宽度类型设备上，栅格子组件占据的栅格容器8列。 xxl: 12 // 在超大宽度类型设备上，栅格子组件占据的栅格容器12列。 } }) { Row() { Text(`${index}`) }.width(&quot;100%&quot;).height('50vp') }.backgroundColor(color) }) } 设置布局总列数 columns默认值为12，即在未设置columns时，任何断点下，栅格布局被分成12列。 ... // 使用columns设置默认列数 GridRow({ columns: 4 }) { ForEach(this.bgColors, (item, index) =&gt; { GridCol() { Row() { Text(`${index + 1}`) }.width('100%').height('50') }.backgroundColor(item) }) } 设置排列方向 从左到右 GridRow({ direction: GridRowDirection.Row }){} 从右往左 GridRow({ direction: GridRowDirection.RowReverse }){} 设置间距 GridRow({ gutter: 10 }){} 设置水平或者垂直方向： GridRow({ gutter: { x: 20, y: 50 } }){} 子组件GridCol的属性 span (占用的列数) GridCol({ span: 2 }){} GridCol({ span: { xs: 1, sm: 2, md: 3, lg: 4 } }){} GridCol(){}.span(2) GridCol(){}.span({ xs: 1, sm: 2, md: 3, lg: 4 }) offset （偏移的列数） GridCol({ offset: 2 }){} GridCol({ offset: { xs: 2, sm: 2, md: 2, lg: 2 } }){} GridCol(){}.offset(2) GridCol(){}.offset({ xs: 1, sm: 2, md: 3, lg: 4 }) order （排序） GridCol({ order: 2 }){} GridCol({ order: { xs: 1, sm: 2, md: 3, lg: 4 } }){} GridCol(){}.order(2) GridCol(){}.order({ xs: 1, sm: 2, md: 3, lg: 4 }) 参考官方教程： https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-layout-development-grid-layout-0000001454765270-V2 媒体查询（mediaquery） 使用场景: 针对设备和应用的属性信息（比如显示区域、深浅色、分辨率），设计出相匹配的布局。 当屏幕发生动态改变时（比如分屏、横竖屏切换），同步更新应用的页面布局。 使用： 引入媒体查询模块 import mediaquery from '@ohos.mediaquery'; 创建媒体查询条件监听 let listener = mediaquery.matchMediaSync('(orientation: landscape)'); 在组件创建时的生命周期监听回调 onPortrait(mediaQueryResult) { if (mediaQueryResult.matches) { // do something here } else { // do something here } } aboutToAppear(){ listener.on('change', onPortrait); } 根据以上的使用规则，以下是一个基本的基本查询使用demo // @ts-nocheck import mediaquery from '@ohos.mediaquery'; @Entry @Component struct MediaPage { /** * @description 当设备横屏时条件成立 */ mediaLandscape = mediaquery.matchMediaSync('(orientation: landscape)'); onMediaLandscape(mediaQueryResult) { console.info(JSON.stringify(mediaQueryResult)) if (mediaQueryResult.matches) { // 若设备为横屏状态，更改相应的页面布局 console.info('横屏') } else { console.info('竖屏') } } /** * @description xs 最小宽度类型设备。 */ mediaXs = mediaquery.matchMediaSync('screen and (max-width : 320)') onMediaXs(midiaQueryResult){ if(midiaQueryResult.matches){ console.info(&quot;min-width:320&quot;) } } /** * @description sm 小宽度类型设备。[320,520) */ mediaSm = mediaquery.matchMediaSync('screen and (width &gt;= 320) and (width &lt; 520)') onMediaSm(midiaQueryResult){ if(midiaQueryResult.matches){ console.info(&quot;(width &gt;= 320) or (width &lt; 520)&quot;) } } /** * @description md 中等宽度类型设备。[520,840) */ mediaMd = mediaquery.matchMediaSync('screen and (width &gt;= 520) and (width &lt; 840)') onMediaMd(midiaQueryResult){ if(midiaQueryResult.matches){ console.info(&quot;(width &gt;= 520) and (width &lt; 840)&quot;) } } /** * @description lg 大宽度类型设备。[840,+∞) */ mediaLg = mediaquery.matchMediaSync('screen and (width&gt;=840)') onMediaLg(midiaQueryResult){ if(midiaQueryResult.matches){ console.info(&quot;width&gt;=840&quot;) } } // 组件创建监听 aboutToAppear(){ this.mediaLandscape.on('change',this.onMediaLandscape.bind(this)) this.mediaXs.on('change',this.onMediaXs.bind(this)) this.mediaSm.on('change',this.onMediaSm.bind(this)) this.mediaMd.on('change',this.onMediaMd.bind(this)) this.mediaLg.on('change',this.onMediaLg.bind(this)) } build() { Row() { Column() { } .width('100%') } .height('100%') } } 轮播（Swiper） Swiper组件提供滑动轮播显示的能力。 @Entry @Component struct SwiperPage { // 定义swiper构造器 private swiperController: SwiperController = new SwiperController() build() { Column() { Swiper(this.swiperController){ Text(&quot;1&quot;) .width(&quot;100%&quot;) .height(&quot;100%&quot;) .backgroundColor(&quot;#ffde3a3a&quot;) .fontSize(150) .fontWeight(FontWeight.Bold) ; Text(&quot;2&quot;) .width(&quot;100%&quot;) .height(&quot;100%&quot;) .backgroundColor(&quot;#ff66de3a&quot;) .fontSize(150) .fontWeight(FontWeight.Bold) Text(&quot;3&quot;) .width(&quot;100%&quot;) .height(&quot;100%&quot;) .backgroundColor(&quot;#ff3aded0&quot;) .fontSize(150) .fontWeight(FontWeight.Bold) } // 循环播放 .loop(true) // 自动播放 .autoPlay(true) // 过渡时间 .duration(50) // 滑动元素间距 .itemSpace(20) .indicator(true) // 垂直滚动 .vertical(true) // 设置每页显示的页数 .displayCount(2) .width(&quot;100%&quot;) .height(350) // 自定义滚动方向 Button(&quot;下一页&quot;) .onClick(()=&gt;{ this.swiperController.showNext() }) Button(&quot;上一页&quot;) .onClick(()=&gt;{ this.swiperController.showPrevious() }) } .width('100%') .height(&quot;100%&quot;) } } 创建列表（List） 创建网格（Grid/GridItem） 2. 组件 记录常见的组件，在工作中还是直接查看文档更方便。 按钮（Button） 单选框（Radio） 切换按钮（Toggle） 进度条（Progress） 文本显示（Text/Span） 文本输入（TextInput/TextArea） @Entry @Component struct ComponentPage { @State message: string = 'Hello World' build() { Row() { Column() { //----按钮 Button(&quot;我是按钮&quot;) .type(ButtonType.Normal) .onClick(()=&gt;{ console.info(&quot;点击了&quot;) }) //----单选框 Radio({value:'xm',group:'radioGroup'}).checked(true) .onChange((isChecked:Boolean)=&gt;{ console.info(`xm:${isChecked}`) }) Radio({value:'xh',group:'radioGroup'}) // 监听radio .onChange((isChecked:Boolean)=&gt;{ console.info(`xh:${isChecked}`) }) // --切换按钮 Toggle({type:ToggleType.Checkbox,isOn:true}) Toggle({type:ToggleType.Switch,isOn:false}) Toggle({type:ToggleType.Button}){ Text(&quot;这是一个可选的按钮&quot;) } // --进度条 Progress({value:10,total:100,type:ProgressType.Capsule}) Progress({value:10,total:100,type:ProgressType.Ring}) Progress({value:10,total:100,type:ProgressType.Linear}) // -- 文本显示 Text / Span Text(&quot;你好啊&quot;){ Span(&quot;你好啊~&quot;) } // -- 文本输入框 TextInput({text:&quot;&quot;,placeholder:&quot;单行文本框&quot;}) .type(InputType.Password) .margin({bottom:10}) TextArea({text:&quot;&quot;,placeholder:&quot;多行文本框&quot;}) } .width('100%') } .height('100%') } } 自定义弹窗（CustomDialog) 视频播放（Video） video组件不能在pc端上部署预览，只能在模拟器上面预览。 加载本地视频播放 引入 Video实体 设置预览图片 src/main/resources/base/media文件夹下导入图片。 通过$r引入文件。 从本地加载视频 src/main/resources/rawfile文件夹下导入视频文件 通过$rawfile导入文件。 @Component export struct VideoPlayer{ private controller:VideoController; private previewUris: Resource = $r ('app.media.icon'); private innerResource: Resource = $rawfile('trailer.mp4'); build(){ Column() { Video({ src: this.innerResource, previewUri: this.previewUris, controller: this.controller }) } } } 加载视频播放链接 XComponent绘制组件 气泡提示（Popup） @Entry @Component struct PopupPage { @State showPop:boolean=false @Builder customPopup(){ Text(&quot;这是气泡按钮的内容&quot;) } build() { Button(&quot;这是一个气泡&quot;) .bindPopup(this.showPop,{ // 气泡文字 message:&quot;这是一个气泡&quot;, // 或者自定义气泡内容 // builder:this.customPopup, // 气泡弹出位置 placement:Placement.Right, // 气泡背景色 popupColor:Color.Pink, // 设置确定或者取消选项 primaryButton:{ value:'确定', action: () =&gt; { this.showPop = !this.showPop console.info('confirm Button click') } }, secondaryButton: { value: '取消', action: () =&gt; { this.showPop = !this.showPop } }, }) .onClick(()=&gt;{ this.showPop=!this.showPop }) } } 菜单（Menu） https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-popup-and-menu-components-menu-0000001451074026-V3#section3901113910512 图片 (Image) 加载网络图片 @Component struct PreviewImage { build(){ Image(&quot;https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-popup-and-menu-components-menu-0000001451074026-V3#section3901113910512&quot;) .width(200) .height(200) } } 加载本地图片 可以在ets文件夹下新建一个image文件夹，在项目中直接通过Image(&quot;images/imgname.png&quot;)来访问图片资源。 ","tags":[{"index":-1,"name":"HarmonyOS","slug":"sjEwf3qeE","used":true,"link":"https://qin_hu.gitee.io/blog/tag/sjEwf3qeE/"}],"title":"UI开发","feature":"","link":"https://qin_hu.gitee.io/blog/post/ui-kai-fa/","stats":{"text":"14 min read","time":783000,"words":2750,"minutes":14},"date":"2024-01-03 14:59:10","dateFormat":"2024-01-03"},{"content":"查看进程和端口 netstat -ano 查询指定端口 netstat -tunpl|grep 8899 杀死指定端口 kill -9 8899 查询所有端口 netstat -nultp 查看当前目录 pwd 编辑文件 vi 文件名 //打开需要编辑的文件 --进入后，操作界面有三种模式：命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode） 命令模式 -刚进入文件就是命令模式，通过方向键控制光标位置， -使用命令&quot;dd&quot;删除当前整行 -使用命令&quot;/字段&quot;进行查找 -按&quot;i&quot;在光标所在字符前开始插入 -按&quot;a&quot;在光标所在字符后开始插入 -按&quot;o&quot;在光标所在行的下面另起一新行插入 -按&quot;：&quot;进入底行模式 插入模式 -此时可以对文件内容进行编辑，左下角会显示 &quot;-- 插入 --&quot;&quot; -按&quot;ESC&quot;进入底行模式 底行模式 -退出编辑： :q -强制退出： :q! -保存并退出： :wq ## 操作步骤示例 ## 1.保存文件：按&quot;ESC&quot; -&gt; 输入&quot;:&quot; -&gt; 输入&quot;wq&quot;,回车 //保存并退出编辑 2.取消操作：按&quot;ESC&quot; -&gt; 输入&quot;:&quot; -&gt; 输入&quot;q!&quot;,回车 //撤销本次修改并退出编辑 ## 补充 ## vim +10 filename.txt //打开文件并跳到第10行 vim -R /etc/passwd //以只读模式打开文件 删除文件 rm 文件名 //删除当前目录下的文件 rm -f 文件名 //删除当前目录的的文件（不询问） 根据名称查询某个文件路径 find / -name filename ","tags":[{"index":-1,"name":"工具","slug":"tLqooY_hn","used":true,"link":"https://qin_hu.gitee.io/blog/tag/tLqooY_hn/"}],"title":"linux - 命令","feature":"","link":"https://qin_hu.gitee.io/blog/post/linux-ming-ling-gong-ju/","stats":{"text":"2 min read","time":96000,"words":410,"minutes":2},"date":"2023-12-28 14:08:30","dateFormat":"2023-12-28"},{"content":"查看所有进程 netstat -ano ","tags":[{"index":-1,"name":"工具","slug":"tLqooY_hn","used":true,"link":"https://qin_hu.gitee.io/blog/tag/tLqooY_hn/"}],"title":"windows - 命令提示符(Cmd),PowerShell","feature":"","link":"https://qin_hu.gitee.io/blog/post/window-zhi-ling/","stats":{"text":"1 min read","time":1000,"words":8,"minutes":1},"date":"2023-12-28 14:01:52","dateFormat":"2023-12-28"},{"content":"1. react中ts声明类型 如何优雅地在 React 中使用TypeScript，看这一篇就够了！ 2. react-router实现重定向 2-1. 方法1.在Route中使用Navigate app.tsx import { Root } from '@/pages/Root' import { Route, Routes,Navigate } from &quot;react-router-dom&quot; import './App.css' function App() { return ( &lt;div className=&quot;App&quot;&gt; &lt;Routes&gt; &lt;Route path={'/'} element={&lt;Navigate replace to=&quot;/home&quot; /&gt;} /&gt; &lt;/Routes&gt; &lt;Root&gt;&lt;/Root&gt; &lt;/div&gt; ) } export default App 2-2. 方法2. 嵌套路由时，在createBrowserRouter中使用Navigate * // 1. 引入 import { createBrowserRouter,Navigate } from &quot;react-router-dom&quot;; //配置路由 import App from &quot;@/App&quot;; import Home from '@/pages/Home'; import Article from '@/pages/Article'; import Notepad from '@/pages/Notepad'; import Personal from '@/pages/Personal'; const router = createBrowserRouter([ { path: '/', element: &lt;Navigate to='/home' /&gt; //这里配置重定向 }, { path: &quot;/&quot;, element: &lt;App /&gt;, children: [ { path: &quot;/home&quot;, element: &lt;Home /&gt; }, { path: &quot;/article&quot;, element: &lt;article /&gt; }, { path: &quot;/notepad&quot;, element: &lt;Notepad /&gt; }, { path: &quot;/personal&quot;, element: &lt;Personal /&gt; } ] } ]); export default router 3. 路由懒加载 import React, { Suspense } from 'react'; const OtherComponent = React.lazy(() =&gt; import('./OtherComponent')); const AnotherComponent = React.lazy(() =&gt; import('./AnotherComponent')); function MyComponent() { return ( &lt;div&gt; &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; &lt;section&gt; &lt;OtherComponent /&gt; &lt;AnotherComponent /&gt; &lt;/section&gt; &lt;/Suspense&gt; &lt;/div&gt; ); } 4. 解决useEffect运行了两次的bug main.ts中删除StrictMode ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render( &lt;React.StrictMode&gt; {/* 指定UI 的根布局 */} &lt;RouterProvider router={router} /&gt; {/* &lt;App /&gt; */} &lt;/React.StrictMode&gt; ) 修改为 =&gt; ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render( &lt;RouterProvider router={router} /&gt;) 5. vite中引入图片资源 使用new URL()l方法 const imageSrc = [ '/src/assets/images/lunb_1.png', '/src/assets/images/lunb_2.png', '/src/assets/images/lunb_3.png', '/src/assets/images/lunb_4.png', '/src/assets/images/lunb_5.png', '/src/assets/images/lunb_6.png', ]; const getImageUrl = (name:string):string =&gt; { return new URL(name, import.meta.url).href } ... &lt;Carousel style={{ width: &quot;100%&quot;, height: 240 }} autoPlay={true} indicatorType='dot' showArrow='hover' &gt; {imageSrc.map((src, index) =&gt; ( &lt;div key={index}&gt; &lt;img src={getImageUrl(src)} //使用 style={{ width: '100%' }} /&gt; &lt;/div&gt; ))} &lt;/Carousel&gt; 6. ts项目中axios请求和响应都要进行类型规范 7. 在函数式组件中批量更新state 使用unstable_batchedUpdates const [articleData,setArticleData]=useState&lt;articleDataType&gt;({ dataList:[] }) import {unstable_batchedUpdates} from 'react-dom' unstable_batchedUpdates(()=&gt;{ setArticleData({ dataList:dataList }) }) 8.ts中声明react高阶组件类型 //React.ComponentType类型 import React, { useState, useEffect,ComponentType } from 'react'; import { redirect } from 'react-router-dom'; const withAuth = (Component:ComponentType) =&gt; { const AuthenticatedComponent = (props:any) =&gt; { const [isAuthenticated, setIsAuthenticated] = useState(false); useEffect(() =&gt; { // 进行权限验证的逻辑，例如从后端 API 获取用户登录状态 // 如果用户已登录，则设置 isAuthenticated 状态为 true }, []); if (!isAuthenticated) { return redirect(&quot;/login&quot;); } return &lt;Component {...props} /&gt;; }; return AuthenticatedComponent; }; export default withAuth; 9. 点击事件时传参使用箭头函数 // &lt;button onClick={handleClick(1)}&gt;编辑&lt;/button&gt; //会有延迟，dom更新后点击事件才会生效 &lt;button onClick={() =&gt; handleClick(1)}&gt;编辑&lt;/button&gt; 10. 表单不是只读的控件要绑定onChage事件或者设置只读 &lt;input onKeyUp={handleEnter} value={keyWord} onChange={(e) =&gt; { return setkeyWord(e.target.value); }} type=&quot;text&quot; placeholder=&quot;请输入&quot; /&gt; 11. redux在reducers中获取state需要深拷贝 reducer中方法是返回一个新的state对象 ... reducer:{ addTodoList: (state, action) =&gt; { //添加的方法 let newState = JSON.parse(JSON.stringify(state)); // console.log(newState); //#执行操作 newState.list.push({ id: guid(), content: action.payload }); newState.allList = newState.list; newState.count = newState.list.length; //执行操作 return { //返回新的state ...newState }; }, } ","tags":[{"index":-1,"name":"React","slug":"TL1T7hUz1","used":true,"link":"https://qin_hu.gitee.io/blog/tag/TL1T7hUz1/"}],"title":"react开发经验","feature":"","link":"https://qin_hu.gitee.io/blog/post/react-kai-fa-jing-yan/","stats":{"text":"5 min read","time":245000,"words":777,"minutes":5},"date":"2023-12-26 14:11:33","dateFormat":"2023-12-26"},{"content":" Next.js是一个 React 开发框架。 Nextjs是一个使用react作为前端框架底层的支持SSR(请求时渲染)、SSG(构建时渲染)等技术的全栈框架 1. 创建页面 例: 新增一个about页面 在app目录下新建about/page.tsx文件 - app - - about - - - page.tsx 在page.tsx文件中导出一个函数式组件 export default function About() { return ( &lt;main className=&quot;about&quot;&gt; 关于 &lt;/main&gt; ) } 在标签栏中访问 http://localhost:3000/about 2. 使用组件 新建一个按钮组件 新建components/CtnButton.tsx文件 在CtnButton.tsx文件中导出一个函数式组件 export default function CtnButton(props: { text: string }) { return ( &lt;button&gt; {props.text} &lt;/button&gt; ) } 在页面中引入使用 about/page.tsx import CtnButton from &quot;@/src/components/CtnButton/CtnButton&quot; export default function About() { return ( &lt;main className=&quot;about&quot;&gt; 关于 &lt;CtnButton text=&quot;测试&quot;&gt;&lt;/CtnButton&gt; &lt;/main&gt; ) } 3. 创建layout布局 nextJs创建了一个根布局组件layout.tsx，默认使用全局 import './globals.css' import type { Metadata } from 'next' import { Inter } from 'next/font/google' const inter = Inter({ subsets: ['latin'] }) export const metadata: Metadata = { title: '我的nextJs应用', description: 'Generated by create next app', } export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( &lt;html lang=&quot;en&quot;&gt; &lt;body className={inter.className}&gt;{children}&lt;/body&gt; &lt;/html&gt; ) } 4. 使用css样式 4-1. css模块 参考链接：https://nextjs.org/docs/app/building-your-application/styling/css-modules 4-2. 使用scss 参考链接：https://nextjs.org/docs/app/building-your-application/styling/sass 安装scss npm install --save-dev sass 创建style目录存储css样式文件，新建一个style.scss .myscss{ color: red; } 在layout.tsx布局组件中导入 import './globals.css' import '@/src/style/style.scss' //在此导入 import type { Metadata } from 'next' import { Inter } from 'next/font/google' const inter = Inter({ subsets: ['latin'] }) export const metadata: Metadata = { title: '测试nextJsDemo', description: 'Generated by create next app', } export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( &lt;html lang=&quot;en&quot;&gt; &lt;body className={inter.className}&gt;{children}&lt;/body&gt; &lt;/html&gt; ) } 在页面中使用 about/page.tsx import CtnButton from &quot;@/src/components/CtnButton/CtnButton&quot; export default function About() { return ( &lt;main className=&quot;about&quot;&gt; &lt;!--在此处使用--&gt; &lt;p className=&quot;myscss&quot;&gt; 关于 &lt;/p&gt; &lt;CtnButton text=&quot;测试&quot;&gt;&lt;/CtnButton&gt; &lt;/main&gt; ) } 5. 使用ui插件 使用ant.design https://ant.design/docs/react/use-with-next-cn nextui https://nextui.org/ 6. 接口请求封装 7. 页面跳转 7-1. 使用useRouter钩子 'use client' import { useRouter } from 'next/navigation' export default function Page() { const router = useRouter() return ( &lt;button type=&quot;button&quot; onClick={() =&gt; router.push('/dashboard')}&gt; Dashboard &lt;/button&gt; ) } 7-2. 使用Link组件 import Link from 'next/link' export default function Page() { return &lt;Link href=&quot;/dashboard&quot;&gt;Dashboard&lt;/Link&gt; } 使用usePathname()检查用户当前活动的路由 'use client' import { usePathname } from 'next/navigation' import Link from 'next/link' export function Navigation({ navLinks }) { const pathname = usePathname() return ( &lt;&gt; {navLinks.map((link) =&gt; { const isActive = pathname === link.href return ( &lt;Link className={isActive ? 'text-blue' : 'text-black'} href={link.href} key={link.name} &gt; {link.name} &lt;/Link&gt; ) })} &lt;/&gt; ) } 8. 状态分享 9. 其他 9-1. 使用src目录 若要使用该目录，请将“路由器”文件夹或“路由器”文件夹分别移动到 或。srcapppagessrc/appsrc/pages 10. 参考文档 中文官网 英文官网 开发经验 1. 项目中使用tailwindcss https://v2.tailwindcss.tw/docs/guides/nextjs 在Css中引入 @tailwind base; @tailwind components; @tailwind utilities; 或者在入口文件中使用 layout.tsx import 'tailwindcss/tailwind.css' 2. 设置首次跳转的根路径 nextConfig.ts中设置source /** * @type {import('next').NextConfig} */ const nextConfig = { async redirects() { return [{ source: '/', destination: '/welcome', permanent: true, }] }, } module.exports = nextConfig ","tags":[{"index":-1,"name":"React","slug":"TL1T7hUz1","used":true,"link":"https://qin_hu.gitee.io/blog/tag/TL1T7hUz1/"}],"title":"react生态 - nextJs","feature":"","link":"https://qin_hu.gitee.io/blog/post/react-sheng-tai-nextjs/","stats":{"text":"5 min read","time":252000,"words":827,"minutes":5},"date":"2023-12-26 14:10:00","dateFormat":"2023-12-26"},{"content":" 项目vite+react+ts开发 1. nginx配置 当前项目配置在服务器端口号89 nginx.conf #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' # '$status $body_bytes_sent &quot;$http_referer&quot; ' # '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 89; server_name www.heerblog.top heerblog.top; root html/heerblog-admin/dist; #设置index.html所在位置 #charset koi8-r; #access_log logs/host.access.log main; location / { try_files $uri $uri/ /index.html; } location ^~ /assets/ { gzip_static on; expires max; add_header Cache-Control public; } location /api/ { rewrite ^/api/(.*) /$1 break; proxy_pass http://xxx:3001/; #接口反向代理 } #error_page 404 /404.html; } } 2. 配置生产环境中的地址域名为89 由于在nginx中配置了反向代理，在生产环境中接口请求89端口，反向代理到线上域名端口地址 .env.production # 本地环境 ENV = production # 本地环境接口地址 VITE_API_URL = http://xx:89/ 在项目中使用地址： import.meta.env.VITE_API_URL 3. 处理项目中图片引入 vite+react项目中使用图片需要先使用import引入并且赋值变量才能使用 引入 import articlePng from &quot;@/assets/images/article.png&quot; 组件中使用 &lt;img src={articlePng} alt=&quot;&quot; /&gt; 4. 项目打包后的文件放置在html目录下 在监听端口时通过root指定index.html所在文件夹的位置 server { listen 89; server_name www.heerblog.top heerblog.top; root html/heerblog-admin/dist; #设置index.html所在位置 ... } ","tags":[{"index":-1,"name":"React","slug":"TL1T7hUz1","used":true,"link":"https://qin_hu.gitee.io/blog/tag/TL1T7hUz1/"}],"title":"部署 - nginx部署react项目","feature":"","link":"https://qin_hu.gitee.io/blog/post/bu-shu-nginx-bu-shu-react-xiang-mu/","stats":{"text":"2 min read","time":105000,"words":364,"minutes":2},"date":"2023-12-26 14:09:09","dateFormat":"2023-12-26"},{"content":"1. 安装依赖 封装请求需要用到Axios和ahooks两个依赖库。 Axios 是一个基于 promise 网络请求库,ahooks是一个React Hooks库,在这里使用到库中的useRequest Hook，用于请求数据时的状态。 axios : https://www.axios-http.cn/docs/intro npm install axios ahooks : https://ahooks.js.org/zh-CN/guide npm install --save ahooks 2. 封装request.ts文件 在项目中的src/utils下目录新建request.ts文件。 这里与js项目中不同的是需要引入AxiosInstance,axios提供的实例类型。 import axios, { AxiosInstance } from 'axios'; // 配置新建一个 axios 实例 const service: AxiosInstance = axios.create({ baseURL: import.meta.env.VITE_API_URL, timeout: 50000, headers: { 'Content-Type': 'application/json' }, }); /*1.添加请求拦截器*/ service.interceptors.request.use(config =&gt; { // 在发送请求前做什么 return config }, error =&gt; { // 对请求错误做些什么 console.log('请求错误') return Promise.reject(error); }); /*2.添加响应拦截器*/ service.interceptors.response.use(response =&gt; { // 对响应数据做处理 return response; }, error =&gt; { // 对响应错误做处理 let message = &quot;&quot;; return Promise.reject(message); }); export default service;// 导出 axios 实例 3. 对接口进行分类 在src目录下新建一个network目录，将接口模块建在当前文件夹下。 假如我有一个文章模块，我可以在network目录下新建一个article目录，然后在此目录下进一步封装接口的调用： 在article目录下新建一个index.ts文件 article/index.ts import request from &quot;@/utils/request&quot;; export const getArticle = () =&gt; { //获取所有文章 return request({ url: &quot;/api/queryArticle&quot;, method: &quot;get&quot;, }); }; 然后可以在页面中调用了。 4. 组件中调接口 在react中可以在useEffect Hook中调用接口，但是我们还需要在请求拦截器去封装loading。这里使用ahooks提供的useRequest Hook来获取loading的状态更加方便。 pages/Article/index.tsx import styles from './article.module.scss' import { getArticle } from '@/network/article'; import { useRequest } from 'ahooks'; export default function Article() { const { data, error, loading } = useRequest(getArticle); //当获取到data值时loading为true if(loading) return &lt;div&gt;loading...&lt;/div&gt; return &lt;div className={styles.article}&gt; 内容 &lt;/div&gt; } ","tags":[{"index":-1,"name":"React","slug":"TL1T7hUz1","used":true,"link":"https://qin_hu.gitee.io/blog/tag/TL1T7hUz1/"},{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"}],"title":"封装axios，获取请求数据","feature":"","link":"https://qin_hu.gitee.io/blog/post/axios-feng-zhuang-axioshuo-qu-qing-qiu-shu-ju/","stats":{"text":"3 min read","time":131000,"words":495,"minutes":3},"date":"2023-12-26 14:07:43","dateFormat":"2023-12-26"},{"content":"高阶组件接收一个组件并且返回一个组件，可以利用这个特性实现路由拦截 1. 创建权限校验高阶组件 将路由组件传人高阶组件中，在useEffect hook中进行获取是否登陆的状态。 import { useEffect, ComponentType,PropsWithChildren } from 'react'; function WithAuth&lt;T&gt;(Component: ComponentType&lt;T&gt;) { const AuthenticatedComponent = (props: PropsWithChildren&lt;T&gt;) =&gt; { useEffect(() =&gt; { // 进行权限验证的逻辑，例如从后端 API 获取用户登录状态 console.log('start auth') }, []); return &lt;Component {...props} /&gt; } return AuthenticatedComponent } export default WithAuth; 2. 在自定义的路由组件中使用 使用WithAuth包裹： import WithAuth from '@/hoc/WithAuth'; function Home() { const element = ( &lt;div className=&quot;gutter-20&quot;&gt; ... &lt;/div&gt; ) return element } export default WithAuth(Home) ","tags":[{"index":-1,"name":"React","slug":"TL1T7hUz1","used":true,"link":"https://qin_hu.gitee.io/blog/tag/TL1T7hUz1/"}],"title":"组件 - 使用高阶组件实现路由守卫","feature":"","link":"https://qin_hu.gitee.io/blog/post/zu-jian-shi-yong-gao-jie-zu-jian-shi-xian-lu-you-shou-wei/","stats":{"text":"1 min read","time":48000,"words":177,"minutes":1},"date":"2023-12-26 14:06:20","dateFormat":"2023-12-26"},{"content":" 如果项目是单页面应用，可以创建复用的头部Header组件，底部footer组件，页面开发的主要内容部分使用jsx组合组件的方式动态指定，可以提高开发效率。 文档结构： - public - src ---- components -------- layout-header.jsx -------- layout-footer.jsx -------- layout-main.jsx -------- layout.jsx ---- pages -------- Home ------------ Home.jsx layout-header.jsx import React,{Component } from &quot;react&quot;; export default class LayoutHeader extends Component { render() { return ( &lt;div className=&quot;layout-header&quot;&gt; 头部 &lt;/div&gt; ); } } layout-footer.jsx import React,{Component} from &quot;react&quot;; export default class LayoutFooter extends Component { render() { return ( &lt;div className=&quot;layout-footer&quot;&gt; 底部 &lt;/div&gt; ); } } layout-main.jsx import React,{Component } from &quot;react&quot;; export default class LayoutMain extends Component { render() { return ( &lt;div className=&quot;layout-main&quot;&gt; 内容部分 &lt;/div&gt; ); } } layout.jsx import React, { Component } from &quot;react&quot;; import LayoutHeader from &quot;./layout-header&quot;; import LayoutFooter from &quot;./layout-footer&quot;; export default class Layout extends Component { constructor(props) { super(props); } render() { return ( //从layout传props决定是否showHeader ，showFooter &lt;div className=&quot;layout&quot;&gt; &lt;header&gt;{this.props.showHeader ? &lt;LayoutHeader /&gt; : &quot;&quot;}&lt;/header&gt; &lt;main&gt;{this.props.main}&lt;/main&gt; //此处动态渲染 &lt;footer&gt;{this.props.showFooter ? &lt;LayoutFooter /&gt; : &quot;&quot;}&lt;/footer&gt; &lt;/div&gt; ); } } 在页面中使用 import React from &quot;react&quot;; import Layout from &quot;../../components/layout&quot;; import LayoutMain from &quot;../../components/layout-main&quot;; export default class Home extends React.Component { render() { return ( &lt;div className=&quot;home&quot;&gt; &lt;Layout showFooter={true} showHeader={true} main={&lt;LayoutMain /&gt;} /&gt; &lt;/div&gt; ); } } ","tags":[{"index":-1,"name":"React","slug":"TL1T7hUz1","used":true,"link":"https://qin_hu.gitee.io/blog/tag/TL1T7hUz1/"}],"title":"组件 - 自定义Layout布局组件","feature":"","link":"https://qin_hu.gitee.io/blog/post/zu-jian-zi-ding-yi-layout-bu-ju-zu-jian/","stats":{"text":"2 min read","time":108000,"words":330,"minutes":2},"date":"2023-12-26 14:02:35","dateFormat":"2023-12-26"},{"content":"1. 理解 redux作用 管理state 使用redux过程 使用state(普通对象)来创建数据，使用Action对象来描述更新state数据发送的过程，最终reducer接收 state 和 action，并返回新的 state 函数。 redux三大基本原则 单一数据源 State 是只读的 使用纯函数来执行修改 2. 一些术语 State 驱动应用的真实数据源头, 当多个组件需要共享和使用相同 state时，可能会变得很复杂，所以使用集中式的全局状态来管理 单向数据流（one-way data flow） 用 state 来描述应用程序在特定时间点的状况 基于 state 来渲染出 View 当发生某些事情时（例如用户单击按钮），state 会根据发生的事情进行更新，生成新的 state 基于新的 state 重新渲染 View Actions-&gt;View-&gt;State-&gt;Actions Action action 视为描述应用程序中发生了什么的事件. 基本action语法: const addTodoAction = { type: 'todos/todoAdded', //类型 payload: 'Buy milk' //信息 } Action Creator 创建并返回一个 action 对象的函数 const addTodo = text =&gt; { return { type: 'todos/todoAdded', payload: text } } Reducer reducer 是一个函数，接收当前的 state 和一个 action 对象。 (state, action) =&gt; newState 规则： 仅使用 state 和 action 参数计算新的状态值 禁止直接修改 state。必须通过复制现有的 state 并对复制的值进行更改的方式。 例子 const initialState = { value: 0 } function counterReducer(state = initialState, action) { // 检查 reducer 是否关心这个 action if (action.type === 'counter/increment') { // 如果是，复制 `state` return { ...state, // 使用新值更新 state 副本 value: state.value + 1 } } // 返回原来的 state 不变 return state } Store Redux 应用的 state 存在于一个名为 store 的对象中。 store 是通过传入一个 reducer 来创建的,并且有一个名为 getState 的方法，它返回当前状态值： import { configureStore } from '@reduxjs/toolkit' const store = configureStore({ reducer: counterReducer }) console.log(store.getState()) // {value: 0} Dispatch Redux store 有一个方法叫 dispatch,作用是触发一个事件。 更新 state 的唯一方法是调用 store.dispatch() 并传入一个 action 对象: store.dispatch({ type: 'counter/increment' }) console.log(store.getState()) 或者是调用 action creator 来调用 action: const increment = () =&gt; { return { type: 'counter/increment' } } store.dispatch(increment()) console.log(store.getState()) Selector Selector 函数可以从 store 状态树中提取指定的片段。随着应用变得越来越大，会遇到应用程序的不同部分需要读取相同的数据，selector 可以避免重复这样的读取逻辑： const selectCounterValue = state =&gt; state.value const currentValue = selectCounterValue(store.getState()) console.log(currentValue) // 2 Redux数据流 初始启动： 使用最顶层的 root reducer 函数创建 Redux store store 调用一次 root reducer，并将返回值保存为它的初始 state 当视图 首次渲染时，视图组件访问 Redux store 的当前 state，并使用该数据来决定要呈现的内容。同时监听 store 的更新，以便他们可以知道 state 是否已更改。 更新环节： 应用程序中发生了某些事情，例如用户单击按钮 dispatch 一个 action 到 Redux store，例如 dispatch({type: 'counter/increment'}) store 用之前的 state 和当前的 action 再次运行 reducer 函数，并将返回值保存为新的 state store 通知所有订阅过的视图，通知它们 store 发生更新 每个订阅过 store 数据的视图 组件都会检查它们需要的 state 部分是否被更新。 发现数据被更新的每个组件都强制使用新数据重新渲染，紧接着更新网页 3. 基本使用 1. 安装 # NPM npm install @reduxjs/toolkit npm install redux # Yarn yarn add @reduxjs/toolkit yarn add redux // 配套工具 npm install react-redux npm install --save-dev redux-devtools 官方推荐的创建 React Redux 新应用的方式 # Redux + Plain JS template npx create-react-app my-app --template redux # Redux + TypeScript template npx create-react-app my-app --template redux-typescript 2. 在最顶层root配置 Redux store 在src目录创建app/store.js文件 import { configureStore } from &quot;@reduxjs/toolkit&quot;; export default configureStore({ reducer: { //这里注册创建的slice } }); 在入口文件使用react-redux的Provider注入store 入口文件index.js ... //引入依赖项 import store from './app/store'; //自定义store import { Provider } from 'react-redux'; ... createRoot(document.getElementById(&quot;root&quot;)).render( &lt;StrictMode&gt; &lt;Provider store={store}&gt; //在此处注入store {/* 指定UI 的根布局 */} &lt;RouterProvider router={router} /&gt; &lt;/Provider&gt; &lt;/StrictMode&gt; ); ... 3. 初始化state 1.在src目录下创建features/counter/counterSlice.js 文件（counter为state模块名） 2.创建slice &quot;slice&quot; 是应用中单个功能的 Redux reducer 逻辑和 action 的集合。 counterSlice.js import { createSlice } from '@reduxjs/toolkit' export const counterSlice = createSlice({ name: 'counter', initialState: { value: 0 }, reducers: { increment: state =&gt; { // Redux Toolkit 允许我们在 reducers 写 &quot;可变&quot; 逻辑。 // 并不是真正的改变 state 因为它使用了 immer 库 // 当 immer 检测到 &quot;draft state&quot; 改变时，会基于这些改变去创建一个新的 // 不可变的 state state.value += 1 }, decrement: state =&gt; { state.value -= 1 }, incrementByAmount: (state, action) =&gt; { state.value += action.payload } } }) export const { increment, decrement, incrementByAmount } = counterSlice.actions export default counterSlice.reducer 在app/store.js 中注册创建的slice import { configureStore } from '@reduxjs/toolkit' import counterReducer from '../features/counter/counterSlice' export default configureStore({ reducer: { counter: counterReducer } }) 4. 使用state 使用useSelector获取更新后的state值 在slice中返回创建selector函数 export const selectAllPosts = state =&gt; state.posts export const selectPostById = (state, postId) =&gt; state.posts.find(post =&gt; post.id === postId) 使用useSelector Hook来获取state值 //引入useSelector // omit imports import { selectAllPosts } from './postsSlice' export const PostsList = () =&gt; { const posts = useSelector(selectAllPosts) // omit component contents } // omit imports import { selectPostById } from './postsSlice' export const SinglePostPage = ({ match }) =&gt; { const { postId } = match.params const post = useSelector(state =&gt; selectPostById(state, postId)) // omit component logic } 5. 调用dispatch slice中准备一个reducers方法 export const counterSlice = createSlice({ name: 'counter', initialState: { value: 0, }, reducers: { decrement: (state) =&gt; { state.value -= 1 }, incrementByAmount: (state, action) =&gt; { // 使用action.payload接收dispatch传来的值 state.value += action.payload }, }, }) 调用reducers //引入 import { useDispatch } from 'react-redux'; import { decrement, incrementByAmount, } from './counterSlice'; .... {dispatch(decrement())} ... {dispatch(incrementByAmount(Number(incrementAmount) || 0))} .... 在组件外的文件中调用dispatch修改state值 在封装axios时，想封装一个全局的loading，需要通过state全局状态管理。 在组件外的文件可以直接引入封装好的全局state，通过state来调用dispatch import store from '@/store'; // 调用，setLoading是自定义的reducer方法 store.dispatch(setLoading(true)) axios封装全局loading的demo import axios, { AxiosInstance } from 'axios'; import baseURL from './baseUrl'; import { setLoading } from '@/features/setting/settingSlice'; import store from '@/store'; const service: AxiosInstance = axios.create({ baseURL: baseURL, timeout: 50000, headers: { 'Content-Type': 'application/json' }, }); service.interceptors.request.use(config =&gt; { store.dispatch(setLoading(true)) return config }, error =&gt; { store.dispatch(setLoading(false)) console.log('请求错误') return Promise.reject(error); }); service.interceptors.response.use(response =&gt; { store.dispatch(setLoading(false)) return response; }, error =&gt; { let message = &quot;&quot;; store.dispatch(setLoading(false)) return Promise.reject(message); }); export default service; 学习文档 https://cn.redux.js.org/tutorials/essentials/part-1-overview-concepts https://www.redux.org.cn/ ","tags":[{"index":-1,"name":"React","slug":"TL1T7hUz1","used":true,"link":"https://qin_hu.gitee.io/blog/tag/TL1T7hUz1/"}],"title":"react生态 - redux","feature":"","link":"https://qin_hu.gitee.io/blog/post/react-sheng-tai-redux/","stats":{"text":"8 min read","time":439000,"words":1625,"minutes":8},"date":"2023-12-26 14:01:12","dateFormat":"2023-12-26"},{"content":"1. 理解 基于react的路由库，可以向应用中快速地添加视图和数据流，同时保持页面与 URL 间的同步 React Router以三个不同的包发布到npm上，他们分别是 react-router：路由的核心库， 提供了很多的：组件、钩子。 react-router-dom：包含react-router所有内容，并添加了一些专门用于DOM的组件，例如等。 react-router-native: 包括react-router所有内容，并添加一些专门用于ReactNative的API，例如：等。 如果在 web 上的话，你需要的是 react-router-dom 而不是 react-router 这个包。它们的区别是，后者包含了 react-native 中需要的一些组件，如果你只需要做网页应用的话，用前者就可以了 2. 安装 npm npm install react-router-dom@6 yarn yarn add react-router-dom@6 3. 基本使用 1. 在react项目中安装react-router 2. 创建根路由 创建路由文件夹routes mkdir src/routes //路由文件夹 touch src/routes/root.jsx //根布局组件 在根路由root.jsx写一个nav src/routes/root.jsx import ContainerHeader from &quot;../components/ContainerHeader&quot;; export default function Root() { return ( &lt;&gt; &lt;div className=&quot;container&quot;&gt; &lt;ContainerHeader /&gt; &lt;/div&gt; &lt;/&gt; ); } src/components/ContainerHeader/index import &quot;./ContainerHeader.css&quot;; export default function ContainerHeader() { const element = ( &lt;header className=&quot;container-header&quot;&gt; &lt;ul&gt; &lt;li&gt;home&lt;/li&gt; &lt;li&gt;news&lt;/li&gt; &lt;li&gt;about&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; ); return element; } src/components/ContainerHeader/ContainerHeader.css .container-header { width: 80%; margin: auto; height: 60px; background-color: #eee; } .container-header &gt; ul { display: flex; list-style: none; align-items: center; } .container-header &gt; ul li { margin-left: 30px; cursor: pointer; } 在index.js入口文件中导入根路由 import React from &quot;react&quot;; import { StrictMode } from &quot;react&quot;; import { createRoot } from &quot;react-dom/client&quot;; // 1. 引入 import { createBrowserRouter, RouterProvider, } from &quot;react-router-dom&quot;; import Root from &quot;./routes/root&quot;; //根路由 //end //2. 初始化router，并绑定根组件 const router = createBrowserRouter([ { path: &quot;/&quot;, element: &lt;Root/&gt;, }, ]); // end createRoot(document.getElementById(&quot;root&quot;)).render( &lt;StrictMode&gt; {/* 指定UI 的根布局 */} &lt;RouterProvider router={router} /&gt; &lt;/StrictMode&gt; ); 3. 创建页面 在这里我创建news和about两个页面组件，通过点击nav的选项显示不同的页面组件 src/routes/news.js export default function News() { return &lt;div&gt;news page&lt;/div&gt;; } src/routes/about.js export default function About() { return &lt;div&gt;about page&lt;/div&gt;; } 在入口文件中将页面组件绑定到createBrowserRouter实例 create-react-app创建的项目：index.js ，vite创建的项目：main.js import React from &quot;react&quot;; import { StrictMode } from &quot;react&quot;; import { createRoot } from &quot;react-dom/client&quot;; // 1. 引入 import { createBrowserRouter, RouterProvider } from &quot;react-router-dom&quot;; import About from &quot;./routes/about&quot;; import Root from &quot;./routes/root&quot;; //根路由 import News from &quot;./routes/news&quot;; //end //2. 初始化router，并绑定根组件 const router = createBrowserRouter([ { path: &quot;/&quot;, element: &lt;Root /&gt; }, { path: &quot;/about&quot;, element: &lt;About /&gt; }, { path: &quot;/news&quot;, element: &lt;News /&gt; } ]); // end createRoot(document.getElementById(&quot;root&quot;)).render( &lt;StrictMode&gt; {/* 指定UI 的根布局 */} &lt;RouterProvider router={router} /&gt; &lt;/StrictMode&gt; ); 4. 使用Link指定跳转的路径 src/components/ContainerHeader/index import &quot;./ContainerHeader.css&quot;; import { Link } from &quot;react-router-dom&quot;; export default function ContainerHeader() { const element = ( &lt;header className=&quot;container-header&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to={`/`}&gt;home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to={`/news`}&gt;news&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to={`/about`}&gt;about&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; ); return element; } 5. 使用嵌套路由和Outlet 单页路由点击时组件会跳转，当我们想点击Link将页面路由组件显示在当前页面时，需要使用到嵌套路由 使用Outlet指定页面子组件渲染的位置 src/routes/Root.js import ContainerHeader from &quot;../components/ContainerHeader&quot;; import { Outlet } from &quot;react-router-dom&quot;; export default function Root() { return ( &lt;&gt; &lt;div className=&quot;container&quot;&gt; &lt;ContainerHeader /&gt; &lt;main&gt; &lt;Outlet /&gt; &lt;/main&gt; &lt;/div&gt; &lt;/&gt; ); } 使用children参数指定子组件 入口文件index.js import React from &quot;react&quot;; import { StrictMode } from &quot;react&quot;; import { createRoot } from &quot;react-dom/client&quot;; // 1. 引入 import { createBrowserRouter, RouterProvider } from &quot;react-router-dom&quot;; import About from &quot;./routes/about&quot;; import Root from &quot;./routes/root&quot;; //根路由 import News from &quot;./routes/news&quot;; //end //2. 初始化router，并绑定根组件 const router = createBrowserRouter([ { path: &quot;/&quot;, element: &lt;Root /&gt;, children: [ { path: &quot;/about&quot;, element: &lt;About /&gt; }, { path: &quot;/news&quot;, element: &lt;News /&gt; } ] } ]); // end createRoot(document.getElementById(&quot;root&quot;)).render( &lt;StrictMode&gt; {/* 指定UI 的根布局 */} &lt;RouterProvider router={router} /&gt; &lt;/StrictMode&gt; ); 6. 处理错误页面 使用errorElement参数处理当访问的路由不存在时渲染的默认页面 创建错误路由组件 src/routes/errpage.js export default function ErrPage() { return &lt;div className=&quot;err-page&quot;&gt;err page&lt;/div&gt;; } 在路由配置中绑定 入口文件index.js ... const router = createBrowserRouter([ { path: &quot;/&quot;, element: &lt;Root /&gt;, errorElement: &lt;ErrPage /&gt;, //在此处绑定加载错误时渲染的组件 children: [ { path: &quot;/about&quot;, element: &lt;About /&gt; }, { path: &quot;/news&quot;, element: &lt;News /&gt; } ] } ]); ... 7. 重定向 import { redirect } from &quot;react-router-dom&quot;; const loader = async () =&gt; { const user = await getUser(); if (!user) { return redirect(&quot;/login&quot;); } return null; }; 4. 路由导航和传参 1. 声明式导航 (1) Link &lt;Link to=&quot;/search&quot;&gt;搜索&lt;/Link&gt; (2) NavLink 活动链接样式，可以定义点击后的class //to属性，用于指定地址，会渲染成a标签的href属性 {/* style 写法 */} &lt;NavLink to=&quot;about&quot; style={({isActive}) =&gt; { return { color: isActive ? &quot;red&quot; : &quot;&quot; } }} &gt;About&lt;/NavLink&gt; (3) Routes组件包裹多个Route组件。 v6 提供了功能更强大的 Routes 组件来代替 Switch 组件，Routes 不再按顺序匹配路径，而是采用了一种自动匹配最佳路径的方法； // v6 写法 import { Route, Routes } from 'react-router-dom'; function App() { return ( // Routes 替换 Switch &lt;Routes&gt; {/* 路由配置 */} &lt;/Routes&gt; ); } 2. 声明式路由导航传参 （1） query传参 发送 &lt;Link to={`/news?id=wqeqw`}&gt;news&lt;/Link&gt; 接收 使用useLocation import { useLocation } from &quot;react-router-dom&quot;; export default function News() { const location = useLocation(); console.log(location.search);//?id=wqeqw return &lt;div&gt;news page&lt;/div&gt;; } 使用props props.location.query.id (2) 使用params动态路由 1. 使用createBrowserRouter中声明路由传参规则 const router = createBrowserRouter([ { path: &quot;/&quot;, element: &lt;Root /&gt;, errorElement: &lt;ErrPage /&gt;, children: [ { path: &quot;/about&quot;, element: &lt;About /&gt; }, { path: &quot;/news/:id&quot;, //在这里声明 element: &lt;News /&gt; } ] } ]); // end createRoot(document.getElementById(&quot;root&quot;)).render( &lt;StrictMode&gt; {/* 指定UI 的根布局 */} &lt;RouterProvider router={router} /&gt; &lt;/StrictMode&gt; ); 发送 &lt;Link to={`/news/qweqweq`}&gt;news&lt;/Link&gt; 使用useParams()接收 import { useParams} from &quot;react-router-dom&quot;; export default function News(props) { let params=useParams() console.log(params) // { id: &quot;qweqweq&quot;} return &lt;div&gt;news page&lt;/div&gt;; } 2. 使用Routes中配置路由传参规则 3. 编程式路由导航 5. Hook 名称 作用 说明 useParams 返回当前参数 根据路径读取参数 useNavigate 返回当前路由 代替原有V5中的 useHistory useOutlet 返回根据路由生成的element - useLocation 返回当前的location 对象 - useRoutes 同Routers组件一样，只不过是在js中使用 - useSearchParams 用来匹配URL中?后面的搜索参数 - 参考学习文档 官网 中文文档 React Router6学习(包括组件和Hooks) ——博客文章 React router 使用及路由传参总结 ---掘金文章 https://www.cnblogs.com/operate/p/16082907.html https://cloud.tencent.com/developer/article/1965740 ","tags":[{"index":-1,"name":"React","slug":"TL1T7hUz1","used":true,"link":"https://qin_hu.gitee.io/blog/tag/TL1T7hUz1/"}],"title":"react生态 - react-router","feature":"","link":"https://qin_hu.gitee.io/blog/post/react-sheng-tai-shi-yong-react-router/","stats":{"text":"9 min read","time":524000,"words":1759,"minutes":9},"date":"2023-12-26 13:59:01","dateFormat":"2023-12-26"},{"content":"1. 认识React和搭建环境 1. 搭建环境 1-1. 使用cdn链接 开发环境 &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; 生产环境 &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.production.min.js&quot;&gt;&lt;/script&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt; 1-2.使用npm //下载淘宝镜像 $ npm install -g cnpm --registry=https://registry.npmmirror.com $ npm config set registry https://registry.npmmirror.com $ cnpm i react https://www.npmjs.com/package/react 1-3.使用create-react-app快速搭建环境 本地安装 Node &gt;= 14 和 npm &gt;= 5.6 npx create-react-app my-app cd my-app npm start 2. jsx简介 1. 简介 React 使用 JSX 来替代常规的 JavaScript。 JSX 是一个看起来很像 XML 的 JavaScript 语法扩展 一种 JavaScript 的语法扩展 React DOM 在渲染所有输入内容之前，默认会进行转义。可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。 React 中使用 JSX 来描述用户界面 JSX 是在 JavaScript 内部实现的 React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致 要将 React 元素渲染到根 DOM 节点中，我们通过把它们都传递给 ReactDOM.render()的方法来将其渲染到页面上 2. 写一个hello world！ html &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; react const word='world!' const element = &lt;h1&gt;hello, {word}&lt;/h1&gt;; //{ }中存放表达式 ReactDOM.render( element, //jsx document.getElementById('root') //元素 ); 3.jsx基本使用 3-1. jsx中使用{}嵌入表达式 在大括号内可以放置任何有效的 JavaScript 表达式 const msg=&quot;你好&quot; ReactDOM.render( // &lt;h1&gt;{msg}&lt;/h1&gt;, //变量 //&lt;h1&gt;{getName(&quot;小明&quot;)}&lt;/h1&gt;, //函数 小明 //&lt;h1&gt;{1+1}&lt;/h1&gt;, /计算表达式 2 &lt;h1&gt;{typeof false}&lt;/h1&gt;, //类型判断 boolean document.getElementById('root') ); 3-2. jsx定义属性 基本使用 例如一个src属性 const element = &lt;img src=&quot;./a.png&quot;&gt;&lt;/img&gt;; 或者使用表达式 const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt; 注意点 嵌入 JavaScript 表达式时，不要在大括号外面加上引号; React DOM 使用 camelCase（小驼峰命名）来定义属性的名称; JSX 里的 class 变成了 className，而 tabindex 则变为 tabIndex 3-3. 指定子元素 没有子元素时 const element = &lt;img src={user.avatarUrl} /&gt;; 存在子元素时，使用() const element = ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;h2&gt;Good to see you here.&lt;/h2&gt; &lt;/div&gt; ); 3-4. jsx表示对象 Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用,最终转换为对象。 jsx const element = ( &lt;h1 className=&quot;greeting&quot;&gt; Hello, world! &lt;/h1&gt; ); React.createElement() 函数调用 const element = React.createElement( 'h1', //标签名 {className: 'greeting'}, //属性 'Hello, world!' //内容 ); 创建了一个这样的对象 // 注意：这是简化过的结构 const element = { type: 'h1', props: { className: 'greeting', children: 'Hello, world!' } }; 这些对象被称为 “React 元素”。React 通过读取这些对象，然后使用它们来构建 DOM 以及保持随时更新。 3. 元素渲染 将一个元素渲染为 DOM html中的根节点，该节点内的所有内容都将由 React DOM 管理 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.render() const element = &lt;h1&gt;Hello, world&lt;/h1&gt;; ReactDOM.render(element, document.getElementById('root')); 使用函数动态更新jsx中的值 function changeTime(){ const element=(&lt;div className=&quot;b&quot;&gt; &lt;p&gt;{new Date().toLocaleTimeString()}&lt;/p&gt; &lt;/div&gt;) ReactDOM.render( element, document.getElementById('root') ); } setInterval(changeTime,1000) 这里虽然每秒都调用React DOM,但是实际更新只有dom改变的内容,React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。 4. 组件和props 组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。 1. 函数组件和class组件 函数组件 函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。 function HelloWorld(props){ const element=&lt;h1&gt;hello,{props.name}&lt;/h1&gt; return element } ReactDOM.render( &lt;HelloWorld name=&quot;world!&quot;&gt;&lt;/HelloWorld&gt;, document.getElementById('root') ); class组件 class HelloWorld extends React.Component { render() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; } } ReactDOM.render( &lt;HelloWorld name=&quot;world&quot;&gt;&lt;/HelloWorld&gt;, document.getElementById('root') ); React 元素可以是dom元素也可以是用户自定义的组件： 组件名必须是以大写字母开头。 2. 构建组件的基本流程 我们调用 ReactDOM.render() 函数，并传入&lt;HelloWorld name=&quot;world&quot;&gt;&lt;/HelloWorld&gt; 作为参数。 React 调用 HelloWorld 组件，并将 {name: 'world'} 作为 props 传入。 HelloWorld 组件将 &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt; 元素作为返回值。 React DOM 将 DOM 高效地更新为 &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;。 3. 组合组件 组件可以在其输出中引用其他组件 function HelloWorld(props){ //自定义helloworld组件 return &lt;h1&gt;hello,{props.name}&lt;/h1&gt; } function App() { //自定义app组件 return ( &lt;div&gt; &lt;HelloWorld name=&quot;Sara&quot; /&gt; &lt;HelloWorld name=&quot;Cahal&quot; /&gt; &lt;HelloWorld name=&quot;Edite&quot; /&gt; &lt;/div&gt; ); } //渲染app组件 ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 4. 提取组件 将组件拆分为更小的组件。将可复用组件提取处来。 写一个看文章结构的组件案例 html &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; css .article-content{ width:200px; height:200px; background:skyblue; } .line{ width:100%; height:1px; background:#fff; } react // 文章 function Article(props){ const element=( &lt;div className=&quot;article-content&quot;&gt; &lt;div className=&quot;article-header&quot;&gt; 标题 &lt;/div&gt; &lt;div className=&quot;line&quot;&gt;&lt;/div&gt; &lt;div className=&quot;article-main&quot;&gt; 内容 &lt;/div&gt; &lt;/div&gt; ) return element } ReactDOM.render( &lt;Article /&gt;, document.getElementById(&quot;root&quot;) ) 将className为line的标签提取出来作为一个组件 // 自定义line组件 function Line(props){ const element=&lt;div className=&quot;line&quot;&gt;&lt;/div&gt; return element } // 文章 function Article(props){ const element=( &lt;div className=&quot;article-content&quot;&gt; &lt;div className=&quot;article-header&quot;&gt; 标题 &lt;/div&gt; &lt;Line /&gt; //使用line组件 &lt;div className=&quot;article-main&quot;&gt; 内容 &lt;/div&gt; &lt;/div&gt; ) return element } ReactDOM.render( &lt;Article /&gt;, document.getElementById(&quot;root&quot;) ) 5.React的Props的只读性 组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props React 组件都必须像纯函数一样保护它们的 props 不被更改。 测试 5. state与生命周期 1. 了解state State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件。 除了拥有并设置了它的组件，其他组件都无法访问。 2. 将函数组件转换为Class组件 步骤： 创建一个同名的 ES6 class，并且继承于 React.Component。 添加一个空的 render() 方法。 将函数体移动到 render() 方法之中。 在 render() 方法中使用 this.props 替换 props。 删除剩余的空函数声明。 函数Clock组件 function Clock(props) { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } Class组件写法 class Clock extends React.Component { render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt; //this访问props &lt;/div&gt; ); } } 3. 实现组件自我更新 3-1. 在函数组件中可以添加定时器，时刻渲染组件达到自己更新的效果 function Clock(props){ return &lt;h1&gt;time:{props.time}&lt;/h1&gt;; } function tick(){ let d=new Date() ReactDOM.render( &lt;Clock time={d.toLocaleTimeString()} /&gt;, document.getElementById('root') ) } setInterval(tick, 1000); 此时在组件外更新，每次组件更新时 render 方法都会被调用 3-2. 向 class 组件中添加局部的 state,添加生命周期函数实现组件内部渲染更新 步骤 1. 添加一个 class 构造函数，然后在该函数中为 this.state 赋初值： class Clock extends React.Component { constructor(props) { super(props);//Class 组件应该始终使用 props 参数来调用父类(继承类)的构造函数。 this.state = {date: new Date()}; } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt; //this访问props &lt;/div&gt; ); } } 2. 把 render() 方法中的 this.props.date 替换成 this.state.date ： class Clock extends React.Component { constructor(props) { super(props);//Class 组件应该始终使用 props 参数来调用父类(继承类)的构造函数。 this.state = {date: new Date()}; } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; //this访问props &lt;/div&gt; ); } } 3. 直接使用Clock组件 class Clock extends React.Component { constructor(props) { super(props);//Class 组件应该始终使用 props 参数来调用父类(继承类)的构造函数。 this.state = {date: new Date()}; } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } } ReactDOM.render( &lt;Clock /&gt;, document.getElementById('root') ); 4. 在class类中使用生命周期方法 挂载生命周期函数 componentDidMount 组件已经被渲染到 DOM 中后运行 卸载生命周期函数 componentWillUnmount 组件卸载时运行 根据上面的生命周期,可以在componentDidMount中添加定时器,在componentWillUnmount移出定时器,达到组件内部更新的效果 class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount() { //挂载 this.timerID = setInterval( () =&gt; this.tick(), 1000 ); } componentWillUnmount() { //卸载 clearInterval(this.timerID); } tick() { this.setState({ //更新state date: new Date() }); } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } } const root = ReactDOM.createRoot(document.getElementById('root')); root.render(&lt;Clock /&gt;); 4. state使用注意事项 4-1. 不要直接修改state,而是使用setState()方法 this.state.date='Test Data' //错误 this.setState({date:&quot;Test Data&quot;}) //正确 4-2. state和props的更新是异步的,不要依赖他们的值来更新下一个状态,而是使用setState((state,props)=&gt;{...}) setState()方法接收一个函数,该函数有state和props两个参数 //更新state中counter值 this.setState((state, props) =&gt; ({ counter: state.counter + props.increment })); 4-3. state的更新会被合并 当state中包含dataA和dataB两个变量 constructor(props) { super(props); this.state = { dataA: [], dataB: [] }; } 可以使用setState单独更新一个变量 this.setState({ dataA: ['1'] }); 此时是浅合并,state中的dataA已经被修改,dataB被保留 可以直接更新所有变量 this.setState({ dataA: ['1'], dataB:['2'] }); 此时state中的dataA和dataB被替换 4-4. 数据是向下流动的 假如有A组件和B组件,A组件是B组件的父组件,A组件可以选择把它的 state 作为 props 向下传递到它的子组件B中 5. 生命周期函数 5-1. 挂载生命周期函数 componentDidMount 组件已经被渲染到 DOM 中后运行 5-2. 卸载生命周期函数 componentWillUnmount 组件卸载时运行 6. 事件处理 1. 与传统html的写法不同 React 事件的命名采用小驼峰式（camelCase），而不是纯小写。 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。 事件阻止默认行为不用return false , 使用e.preventDefault 2. 写一个计数器来体验事件处理 通常情况下， 根据JavaScript 函数工作原理,如果你没有在方法后面添加 ()，例如 onClick={this.handleClick}，你应该为这个方法绑定 this,否则this指向undefined。 在class组件中创建方法要想访问到构造函数中的state,需要使用bind绑定this指向,隐式传递参数 // class类 class Lamp extends React.Component{ constructor(props){ //构造函数 super(props); this.state={ num:0 }; // 为了在回调中使用 `this`，这个绑定是必不可少的。在自定义函数中绑定this指向 this.addNum = this.addNum.bind(this); this.reduceNum = this.reduceNum.bind(this); } addNum(){ this.setState((state)=&gt;{ return { num:++state.num } }) // console.log(this.state.num) } reduceNum(){ this.setState((state)=&gt;{ return { num:--state.num } }) } render(){ return ( &lt;div&gt; &lt;button onClick={this.addNum}&gt; add &lt;/button&gt; &lt;button style={{marginLeft:&quot;10px&quot;}} onClick={this.reduceNum}&gt; reduce &lt;/button&gt; &lt;h1&gt;{this.state.num}&lt;/h1&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;Lamp /&gt;,document.getElementById(&quot;root&quot;)) 3. 向事件处理程序传递参数 3-1. 通过箭头函数（事件对象e会通过第二个参数显示传递） ... testFun(v){ console.log(v) //1 } ... &lt;button onClick={()=&gt;{this.testFun(1)}}&gt;test&lt;/button&gt; 3-2. 使用 Function.prototype.bind 来实现（事件对象以及更多的参数将会被隐式的进行传递） ... testFun(this,v){ console.log(this,v) // 2 } ... &lt;button onClick={this.testFun.bind(this, 2)}&gt;test&lt;/button&gt; 7. 条件渲染 创建不同的组件来封装各种你需要的行为,依据应用的不同状态，你可以只渲染对应状态下的部分内容。使用 JavaScript 运算符 if 或者条件运算符去创建元素来表现当前的状态。 1. 根据条件if判断组件显示 //组件A class ComponentA extends React.Component{ render(){ return &lt;h1&gt;组件A&lt;/h1&gt; } } //组件B class ComponentB extends React.Component{ render(){ return &lt;h1&gt;组件B&lt;/h1&gt; } } //根据props值决定显示哪个组件 class ChooseComponent extends React.Component{ constructor(props){ super(props) } render(){ if(this.props.isComponent=='A'){ return &lt;ComponentA /&gt; }else{ return &lt;ComponentB /&gt; } } } ReactDOM.render(&lt;ChooseComponent isComponent=&quot;B&quot; /&gt; , document.getElementById(&quot;root&quot;)) 2. 在jsx中使用条件运算符 三目运算符 //组件A class ComponentA extends React.Component{ render(){ return &lt;h1&gt;组件A&lt;/h1&gt; } } //组件B class ComponentB extends React.Component{ render(){ return &lt;h1&gt;组件B&lt;/h1&gt; } } //根据props值决定显示哪个组件 class ChooseComponent extends React.Component{ constructor(props){ super(props) } render(){ return ( &lt;div&gt; &lt;p&gt; 此时{this.props.isComponent==&quot;B&quot;?&quot;显示B&quot;:&quot;显示A&quot;}组件 &lt;/p&gt; {this.props.isComponent==&quot;B&quot;?&lt;ComponentB /&gt;:&lt;ComponentA /&gt;} &lt;/div&gt; ) } } ReactDOM.render(&lt;ChooseComponent isComponent=&quot;A&quot; /&gt; , document.getElementById(&quot;root&quot;)) 使用逻辑&amp;&amp;,前面有假则假 //组件A class ComponentA extends React.Component{ render(){ return &lt;h1&gt;组件A&lt;/h1&gt; } } //组件B class ComponentB extends React.Component{ render(){ return &lt;h1&gt;组件B&lt;/h1&gt; } } //根据props值决定显示哪个组件 class ChooseComponent extends React.Component{ constructor(props){ super(props) } render(){ return ( &lt;div&gt; {this.props.isComponent==&quot;A&quot; &amp;&amp;&lt;ComponentA/&gt;} {this.props.isComponent==&quot;B&quot; &amp;&amp;&lt;ComponentB/&gt;} &lt;/div&gt; ) } } ReactDOM.render(&lt;ChooseComponent isComponent=&quot;A&quot; /&gt; , document.getElementById(&quot;root&quot;)) 3. 阻止组件渲染 在组件render方法中return null //根据props值决定显示哪个组件 class ChooseComponent extends React.Component{ constructor(props){ super(props) } render(){ return null //阻断了组件渲染，隐藏了组件 return ( &lt;div&gt; {this.props.isComponent==&quot;A&quot; &amp;&amp;&lt;ComponentA/&gt;} {this.props.isComponent==&quot;B&quot; &amp;&amp;&lt;ComponentB/&gt;} &lt;/div&gt; ) } } ReactDOM.render(&lt;ChooseComponent isComponent=&quot;A&quot; /&gt; , document.getElementById(&quot;root&quot;)) 8. 列表和key 1. 基础列表组件 使用map()将元素标签放置循环中赋值给变量，此变量接收到了一个列表组件。 function Test(props){ let arr=[1,2,3,4,5] let element=arr.map((v)=&gt;{ return &lt;li&gt;{v}&lt;/li&gt; }) return &lt;ul&gt;{element}&lt;/ul&gt; } ReactDOM.render(&lt;Test/&gt;, document.getElementById(&quot;root&quot;)) 2.使用key 2-1. key的使用 根据上面案例中，如果给Test组件添加props，传递一个数组并且使用该数组来遍历组件，将会报错 &quot;Warning: Each child in a list should have a unique 'key' prop.%s%s See 此时需要用到key： function Test(props){ const numbers=props.numbers //接收数组 let element=numbers.map((number,index)=&gt;{ //执行遍历 return &lt;li key={index}&gt;{number}&lt;/li&gt; //给遍历元素添加key }) return &lt;ul&gt;{element}&lt;/ul&gt; } const numbers=[1,2,3,4,5] ReactDOM.render(&lt;Test numbers={numbers}/&gt;, document.getElementById(&quot;root&quot;)) 2-2. key的理解和注意点 key 帮助 React 识别元素改变（比如被添加或删除），给数组中的每一个元素赋予一个确定的标识。 key 最好元素在列表中拥有的一个唯一字符串，可以使用元素索引 index 作为 key，但是会导致性能变差。 元素的 key 只有放在就近的数组上下文中才有意义。（在 map() 方法中的元素需要设置 key 属性。） key 值在兄弟节点之间必须唯一。 9. 表单 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。 1. 受控组件 对于受控组件来说，输入的值始终由 React 的 state 驱动。(通过onchange监听值的改变然后传递给state) class TestForm extends React.Component{ constructor(props){ super(props) this.state={value:''} this.handleChange=this.handleChange.bind(this) } handleChange(e){ this.setState({ value:e.target.value }) } render(){ return (&lt;div&gt; &lt;input value={this.state.value} onChange={this.handleChange} /&gt; &lt;p&gt;{this.state.value}&lt;/p&gt; &lt;/div&gt;) } } ReactDOM.render(&lt;TestForm/&gt;,document.getElementById(&quot;root&quot;)) input ... &lt;input value={this.state.value} onChange={this.handleChange} /&gt; textarea textarea value={this.state.value} onChange={this.handleChange} /&gt; ... select 标签 &lt;label&gt; 选择你喜欢的风味: &lt;select value={this.state.value} onChange={this.handleChange}&gt; &lt;option value=&quot;grapefruit&quot;&gt;葡萄柚&lt;/option&gt; &lt;option value=&quot;lime&quot;&gt;酸橙&lt;/option&gt; &lt;option value=&quot;coconut&quot;&gt;椰子&lt;/option&gt; &lt;option value=&quot;mango&quot;&gt;芒果&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; 2. 非受控组件 input[type='file'] file因为它的 value 只读，所以它是 React 中的一个非受控组件。 &lt;input type=&quot;file&quot; /&gt; 3. 处理多个输入 当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。 使用了 ES6 计算属性名称的语法更新给定输入名称对应的 state 值(通过[]中写表达式得到属性名称) class TestForm extends React.Component{ constructor(props){ super(props) this.state={ oneVal:'', twoVal:0 } this.handleChange=this.handleChange.bind(this) } handleChange(e){ let value=e.target.value this.setState({ [e.target.name]:value //ES6 计算属性名称的语法 }) } render(){ return (&lt;div&gt; &lt;input name=&quot;oneVal&quot; value={this.state.oneVal} onChange={this.handleChange} /&gt;&lt;br/&gt; &lt;input name=&quot;twoVal&quot; value={this.state.twoVal} onChange={this.handleChange} /&gt; &lt;p&gt;oneVal: {this.state.oneVal}&lt;/p&gt;&lt;br/&gt; &lt;p&gt;twoVal: {this.state.twoVal}&lt;/p&gt; &lt;/div&gt;) } } ReactDOM.render(&lt;TestForm/&gt;,document.getElementById(&quot;root&quot;)) 10. 状态提升 1. 理解 状态提升：将多个组件中需要共享的 state 向上移动到它们的最近共同父组件中，便可实现共享 state 理解：a组件有个state值，b组件也需要时应当state值提升到父组件通过props传下来实现兄弟组件共享.(状态提升) 2. 举例 需求: 组件1存温度,组件2判断是否到达沸点,组件2需要拿到组件1中的state值来判断。 /* 组件1存温度 */ class TestChildOne extends React.Component{ constructor(props){ super(props) this.state={ num:0 } this.handleNum=this.handleNum.bind(this) } handleNum(e){ let value=e.target.value this.setState({ num:value }) } render(){ const element=&lt;input value={this.state.num} onChange={this.handleNum}/&gt; return element } } /* 组件2判断是否到达沸点 */ class TestChildTwo extends React.Component{ constructor(props){ super(props) this.state={ num:0 } } render(){ const element=( &lt;&gt; {this.state.num&gt;90?&quot;沸点到达了&quot;:&quot;还差点温度&quot;} &lt;input value={this.state.num} onChange={this.handleNum}/&gt; &lt;/&gt; ) return element } } 此时两个组件都存在状态this.state.num,可以写一个父组件存储该状态，父组件使用属性发送，两个子组件使用props接收值 class TestChildOne extends React.Component{ constructor(props){ super(props) this.state={ //组价自身维护的state num:0 } this.handleNum=this.handleNum.bind(this) } handleNum(e){ let value=e.target.value this.props.onChildOneHandle(value) //子组件给父组件发送值 } render(){ let num=this.props.num const element=&lt;input value={num} onChange={this.handleNum}/&gt; return element } } class TestChildTwo extends React.Component{ constructor(props){ super(props) } render(){ const element=&lt;&gt;{this.props.num&gt;90?&quot;沸点到达了&quot;:&quot;还差点温度&quot;}&lt;/&gt; return element } } class TestParent extends React.Component{ constructor(props){ super(props) this.state={ num:0 } this.childOneHandle=this.childOneHandle.bind(this) } childOneHandle(val){//子组件给父组件间传参数，自定义事件 this.setState({ num:val }) } render(){ const element=( &lt;&gt; &lt;TestChildOne num={this.state.num} onChildOneHandle={this.childOneHandle}/&gt;//自定义事件接收子组件的值 &lt;TestChildTwo num={this.state.num} /&gt; &lt;/&gt; ) return element } } ReactDOM.render( &lt;TestParent /&gt; ,document.getElementById(&quot;root&quot;)) 点击查看运行结果 3. 总结 兄弟组价需要共享state时，需要状态提升到父组件 父组件接收子组件的数据时需要使用自定义组件 父组件接收值 //1.在组件上定义事件 &lt;&gt; &lt;TestChildOne num={this.state.num} onChildOneHandle={this.childOneHandle}/&gt;//自定义事件接收子组件的值 &lt;/&gt; ... //2. 接收值设置state childOneHandle(val){//子组件给父组件间传参数，自定义事件 this.setState({ num:val }) 子组件发送值 ... handleNum(e){ let value=e.target.value this.props.onChildOneHandle(value) //子组件给父组件发送值 } render(){ let num=this.props.num const element=&lt;input value={num} onChange={this.handleNum}/&gt; //input监听value改变事件 return element } ... 11.组合模式 使用组合来实现组件间的代码重用（类似vue的插槽） 1. 使用props.children clss ContainerLayout extends React.Component{ constructor(props){ super(props) } render(){ return ( &lt;div class=&quot;container-layout&quot;&gt; {this.props.children} &lt;/div&gt; ) } } ReactDOM.render( &lt;ContainerLayout&gt; &lt;div class=&quot;main&quot;&gt; main &lt;/div&gt; &lt;/ContainerLayout&gt; ,document.getElementById(&quot;root&quot;)) 2. 指定属性名 class ContainerLayout extends React.Component{ constructor(props){ super(props) } render(){ const element=( &lt;div className=&quot;container-layout&quot;&gt; {this.props.header} {this.props.main} {this.props.footer} &lt;/div&gt; ) return element } } class ContainerMain extends React.Component{ constructor(props){ super(props) } render(){ const element=( &lt;div className=&quot;container-main&quot;&gt; main &lt;/div&gt; ) return element } } class ContainerHeader extends React.Component{ constructor(props){ super(props) } render(){ const element=( &lt;div className=&quot;container-header&quot;&gt; header &lt;/div&gt; ) return element } } class ContainerFooter extends React.Component{ constructor(props){ super(props) } render(){ const element=( &lt;div className=&quot;container-footer&quot;&gt; footer &lt;/div&gt; ) return element } } ReactDOM.render( &lt;ContainerLayout header={&lt;ContainerHeader/&gt;} main={&lt;ContainerMain/&gt;} footer={&lt;ContainerFooter/&gt;} /&gt; ,document.getElementById(&quot;root&quot;) ) 12. 代码分割 1. 打包概念 打包是一个将文件引入并合并到一个单独文件的过程，最终形成一个 “bundle”。 接着在页面上引入该 bundle，整个应用即可一次性加载。 Create React App使用的Webpack进行打包 2. 使用import() 使用之前： import { add } from './math'; console.log(add(16, 26)); 使用之后 import(&quot;./math&quot;).then(math =&gt; { console.log(math.add(16, 26)); }); 当 Webpack 解析到该语法时，会自动进行代码分割。 3. 使用React.lazy引入组件 React.lazy 函数能让你像渲染常规组件一样处理动态引入（的组件）。 React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise，该 Promise 需要 resolve 一个 defalut export 的 React 组件。 在 Suspense 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优雅降级（如 loading 指示器等）。 使用: import React, { Suspense } from 'react'; const OtherComponent = React.lazy(() =&gt; import('./OtherComponent')); function MyComponent() { return ( &lt;div&gt; &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; //引入组件加载时的显示，fallback 属性接受任何在组件加载过程中你想展示的 React 元素。 &lt;OtherComponent /&gt; &lt;/Suspense&gt; &lt;/div&gt; ); } 13. Context 1.理解 Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。 Context共享全局的数据，使用场景有当前认证的用户、主题或首选语言等。 2. API 2-1. React.createContext const MyContext = React.createContext(defaultValue); 创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。 将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效。 2-2. Context.Provider &lt;MyContext.Provider value={/* 某个值 */}&gt; Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。 Provider 接收一个 value 属性，传递给消费组件。 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染 2-3. Class.contextType 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。 使用 this.context 来消费最近 Context 上的那个值。 class MyClass extends React.Component { componentDidMount() { let value = this.context; /* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */ } componentDidUpdate() { let value = this.context; /* ... */ } componentWillUnmount() { let value = this.context; /* ... */ } render() { let value = this.context; /* 基于 MyContext 组件的值进行渲染 */ } } const MyContext = React.createContext(defaultValue); MyClass.contextType = MyContext; 使用 static 这个类属性来初始化你的 contextType class MyClass extends React.Component { static contextType = MyContext; render() { let value = this.context; /* 基于这个值进行渲染工作 */ } } 2-4. Context.Consumer &lt;MyContext.Consumer&gt; {value =&gt; /* 基于 context 值进行渲染*/} &lt;/MyContext.Consumer&gt; React 组件也可以订阅到 context 变更。 2-5. Context.displayName const MyContext = React.createContext(/* some value */); MyContext.displayName = 'MyDisplayName'; &lt;MyContext.Provider&gt; // 在 DevTools 中: &quot;MyDisplayName.Provider&quot; &lt;MyContext.Consumer&gt; // 在 DevTools 中: &quot;MyDisplayName.Consumer&quot; context 对象接受一个名为 displayName 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。 3. 动态Context---基本使用 设置主题案例 3-1. 创建组件 class Container extends React.Component {...} //内容组件 class ThemedButton extends React.Component {...} //按钮 ，用来修改context状态 class App extends React.Component {...}//根组件 3-2. 创建context，使用contextType将context引入组件内部 //创建context const themes={ dark:'#222', light:'#eee' } const ThemeContext = React.createContext( themes.dark // 默认值 ); Container.contextType=ThemeContext ThemedButton.contextType=ThemeContext 3-3. 在App根组件设置state，state的值包含context的属性和值 使用ThemeContext.Provider将改变的state传到内部组件context中 class App extends React.Component { constructor(props){ super(props) this.state={ themes:themes.dark } this.changeThemes=this.changeThemes.bind(this) } changeThemes(){ this.setState({ themes:this.state.themes===themes.dark?themes.light:themes.dark }) } render(){ //使用ThemeContext.Provider 的value 子组件的context的值将由value值决定 子组件使用context接收值 //ThemeContext.Provider 外的组件的context值是默认值 return ( &lt;ThemeContext.Provider value={this.state.themes}&gt; &lt;Container changeThemes={this.changeThemes}&gt;&lt;/Container&gt; &lt;/ThemeContext.Provider&gt; ) } } 3-4. 在App内部组件中传递事件 //内容样式 class Container extends React.Component { constructor(props){ super(props) } render(){ let themes=this.context //获取context值 console.log(this.context) return ( &lt;div style={{width:'100%',height:'500px',border:'10px solid skyblue',background:themes}}&gt; &lt;ThemedButton onClick={this.props.changeThemes}/&gt; &lt;/div&gt; ) } } //按钮 class ThemedButton extends React.Component { constructor(props){ super(props) } render(){ //{...this.props} 将props传递的属性全部使用 return ( &lt;button {...this.props}&gt;点击切换 / {this.context}&lt;/button&gt; ) } } 3-5. 所有代码 //内容样式 class Container extends React.Component { constructor(props){ super(props) } render(){ let themes=this.context console.log(this.context) return ( &lt;div style={{width:'100%',height:'500px',border:'10px solid skyblue',background:themes}}&gt; &lt;ThemedButton onClick={this.props.changeThemes}/&gt; &lt;/div&gt; ) } } //按钮 class ThemedButton extends React.Component { constructor(props){ super(props) } render(){ //{...this.props} 将props传递的属性全部使用 return ( &lt;button {...this.props}&gt;点击切换 / {this.context}&lt;/button&gt; ) } } //创建context const themes={ dark:'#222', light:'#eee' } const ThemeContext = React.createContext( themes.dark // 默认值 ); Container.contextType=ThemeContext ThemedButton.contextType=ThemeContext class App extends React.Component { constructor(props){ super(props) this.state={ themes:themes.dark } this.changeThemes=this.changeThemes.bind(this) } changeThemes(){ this.setState({ themes:this.state.themes===themes.dark?themes.light:themes.dark }) } render(){ //使用ThemeContext.Provider 的value 子组件的context的值将由value值决定 子组件使用context接收值 //ThemeContext.Provider 外的组件的context值是默认值 return ( &lt;ThemeContext.Provider value={this.state.themes}&gt; &lt;Container changeThemes={this.changeThemes}&gt;&lt;/Container&gt; &lt;/ThemeContext.Provider&gt; ) } } const root=ReactDOM.createRoot(document.getElementById('root')) root.render(&lt;App/&gt;) codepen查看运行 4. 嵌套组件中更新Context 根组件给较深的子组件传递context 且使用较深组件更新context状态的方法 4-1. 创建一个context 确保传递给 createContext 的默认值数据结构是调用的组件（consumers）所能匹配的 const themesContext=React.createContext({ theme:'dark', changeTheme:()=&gt;{} }) 4-2. 在根组件添加state state中包含更新state函数，通过context provider传递至根组件 class App extends React.Component{ constructor(props){ super(props) this.changeTheme=()=&gt;{ this.setState(state=&gt;{ return{ theme:state.theme===&quot;#222&quot;?themes.light:themes.dark } }) } this.state={ theme:themes.dark, changeTheme:this.changeTheme } } render(){ return ( &lt;ThemesContext.Provider value={this.state}&gt; &lt;Content/&gt; &lt;/ThemesContext.Provider&gt; ) } } 4-3. 在嵌组件中使用ThemeContext.Consumer 通过 context 传递一个函数，使得 consumers 组件更新 context //嵌套组件 class ChangeButton extends React.Component{ constructor(props){ super(props) } render(){ return ( &lt;ThemesContext.Consumer&gt; { ({theme,changeTheme})=&gt;{ console.log(theme,changeTheme) return &lt;button onClick={changeTheme}&gt;{theme=='#222'?'白天':'黑夜'}&lt;/button&gt; } } &lt;/ThemesContext.Consumer&gt; ) } } class Content extends React.Component{ constructor(props){ super(props) } render(){ // console.log(this.context) return ( &lt;div&gt; &lt;ChangeButton/&gt; &lt;/div&gt; ) } } codepen查看运行 5. 一个组件消费多个 Context 5-1. 组件中提供初始 context 值 class App extends React.Component { render() { const {signedInUser, theme} = this.props; // 提供初始 context 值的 App 组件 return ( &lt;ThemeContext.Provider value={theme}&gt; &lt;UserContext.Provider value={signedInUser}&gt; &lt;Layout /&gt; &lt;/UserContext.Provider&gt; &lt;/ThemeContext.Provider&gt; ); } } 5-2. 组件中使用多个 context // 一个组件可能会消费多个 context function Content() { return ( &lt;ThemeContext.Consumer&gt; {theme =&gt; ( &lt;UserContext.Consumer&gt; {user =&gt; ( &lt;ProfilePage user={user} theme={theme} /&gt; )} &lt;/UserContext.Consumer&gt; )} &lt;/ThemeContext.Consumer&gt; ); } 14. 错误边界 1. 理解 错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。 (简单理解: 子组件发生错误时，渲染备用UI的组件。) 只有 class 组件才可以成为错误边界组件。 大多数情况只需要声明一个错误边界组件，在整个应用去使用 2. 使用 2-1. 定义公共组件，在需要的地方使用这个组件包裹子组件 class ErrorBoundary extends React.Component { constructor(props) { super(props); this.state = { hasError: false }; } static getDerivedStateFromError(error) { // 更新 state 使下一次渲染能够显示降级后的 UI return { hasError: true }; } componentDidCatch(error, errorInfo) { // 捕获错误信息 // 你同样可以将错误日志上报给服务器 logErrorToMyService(error, errorInfo); } render() { if (this.state.hasError) { // 渲染错误视图 return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; } // 渲染正确视图 return this.props.children; } } 2-2. 在组件中使用 &lt;ErrorBoundary&gt; &lt;MyWidget /&gt; // 自定义组件 &lt;/ErrorBoundary&gt; 3. 注意点 错误边界无法捕获以下场景中产生的错误： 事件处理（了解更多） 异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）。使用try...catch{} 服务端渲染 它自身抛出来的错误（并非它的子组件） 15. Refs转发 Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧 1. 使用Ref在组件内部获取dom 使用ref.name标记 使用this.refs.name获取值 class Container extends React.Component{ constructor(props){ super(props) } componentDidMount(){ //挂载生命周期 console.log(this.refs.containerDom) //&lt;div class=&quot;container&quot;&gt;main&lt;/div&gt; console.log(this.refs.containerDom.className)//container } render(){ return ( &lt;div ref=&quot;containerDom&quot; className=&quot;container&quot;&gt; main &lt;/div&gt; ) } } const root = ReactDOM.createRoot(document.getElementById('root')) root.render(&lt;Container/&gt;) 2. 转发自定义组件中的refs React.forwardRef创建的组件可以共享自身绑定的ref 使用React.forwardRef((props,ref)=&gt;{...})方法创建一个组件。该方法多了一个ref参数，该参数接收父组件传递的ref并绑定给内部组件ref上。该方法返回一个render。 在外部组件使用。使用React.createRef()创建一个变量，将该变量绑定到forwardRef创建的组件ref上 获取共享的ref。React.createRef()创建的变量返回一个对象，对象中的current属性可以拿到forwardRef创建的组件ref。 class Container extends React.Component{ constructor(props){ super(props) this.containerBtnDom=React.createRef() } componentDidMount(){ //挂载生命周期 console.log(this.containerBtnDom) //返回值: {current: button.container-button} } render(){ return ( &lt;div ref=&quot;containerDom&quot; className=&quot;container&quot;&gt; &lt;ContainerButton ref={this.containerBtnDom}&gt; main &lt;/ContainerButton&gt; &lt;/div&gt; ) } } const ContainerButton=React.forwardRef((props,ref)=&gt;{ //共享ref，该方法相比于创建组件的方法多了一个ref参数 //返回一个render return &lt;button className=&quot;container-button&quot; ref={ref}&gt;点击&lt;/button&gt; }) const root = ReactDOM.createRoot(document.getElementById('root')) root.render(&lt;Container/&gt;) 3. 在高阶组件中转发 refs 4. 在 DevTools 中显示自定义名称 16. Fragments 1. 理解 Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。（空组件，占位组件） 2. 使用 2-1. React.Fragment &lt;React.Fragment&gt;..&lt;/React.Fragment&gt; class Columns extends React.Component { render() { return ( &lt;React.Fragment&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/React.Fragment&gt; ); } } class Table extends React.Component { render() { return ( &lt;table&gt; &lt;tr&gt; &lt;Columns /&gt; &lt;/tr&gt; &lt;/table&gt; ); } } 此时Table正确输出table： &lt;table&gt; &lt;tr&gt; &lt;div&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/div&gt; &lt;/tr&gt; &lt;/table&gt; 2-2. 短语法 &lt;&gt;...&lt;/&gt; class Columns extends React.Component { render() { return ( &lt;&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/&gt; ); } } 3. Fragments可传递key属性 key 是目前唯一可以传递给 Fragment 的属性。 在遍历一个数组时使用到了Fragments可以给Fragments添加key function Glossary(props) { return ( &lt;dl&gt; {props.items.map(item =&gt; ( // 没有`key`，React 会发出一个关键警告 &lt;React.Fragment key={item.id}&gt; &lt;dt&gt;{item.term}&lt;/dt&gt; &lt;dd&gt;{item.description}&lt;/dd&gt; &lt;/React.Fragment&gt; ))} &lt;/dl&gt; ); } 17. 高阶组件 1. 理解 高阶组件是参数为组件，返回值为新组件的函数。 组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。 18. jsx详解 1. Jsx编译的结果 JSX 仅仅只是 React.createElement(component, props, ...children) 函数的语法糖。 jsx语句 &lt;MyButton color=&quot;blue&quot; shadowSize={2}&gt; Click Me &lt;/MyButton&gt; &lt;div className=&quot;container&quot;&gt; 编译为： React.createElement( MyButton, {color: 'blue', shadowSize: 2}, 'Click Me' ) React.createElement( 'div', {className: 'container'} ) 2. React必须在作用域内 JSX 会编译为 React.createElement 调用形式，所以 React 库也必须包含在 JSX 代码作用域内。(直接通过 &lt;script&gt; 标签加载 React，则必须将 React 挂载到全局变量中) import React from 'react'; import CustomButton from './CustomButton'; function WarningButton() { // return React.createElement(CustomButton, {color: 'red'}, null); return &lt;CustomButton color=&quot;red&quot; /&gt;; } 3. 使用点语法来引用一个 React 组件 import React from 'react'; const MyComponents = { DatePicker: function DatePicker(props) {//组件 return &lt;div&gt;Imagine a {props.color} datepicker here.&lt;/div&gt;; } } function BlueDatePicker() { return &lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;; //直接引用 } 4. 自定义的组件必须以大写字母开头 5. props可以使用表达式 6. 字符串字面量 以下两个 JSX 表达式是等价的： &lt;MyComponent message=&quot;hello world&quot; /&gt; &lt;MyComponent message={'hello world'} /&gt; 7. Props 默认值为 “True” 以下两个 JSX 表达式是等价的： &lt;MyTextBox autocomplete /&gt; &lt;MyTextBox autocomplete={true} /&gt; 8. 属性展开 使用展开运算符 ... 来在 JSX 中传递整个 props 对象 function App1() { return &lt;Greeting firstName=&quot;Ben&quot; lastName=&quot;Hector&quot; /&gt;; } function App2() { const props = {firstName: 'Ben', lastName: 'Hector'}; return &lt;Greeting {...props} /&gt;; } 9. 布尔类型、Null 以及 Undefined 将会忽略 &lt;div /&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;{false}&lt;/div&gt; &lt;div&gt;{null}&lt;/div&gt; &lt;div&gt;{undefined}&lt;/div&gt; &lt;div&gt;{true}&lt;/div&gt; 19. Portals 1. 理解 Portals将子节点渲染到存在于父组件以外的 DOM 节点。 使用场景:对话框、悬浮卡以及提示框。 2. 基本使用 ReactDOM.createPortal(child, container) child：任何react组件。container： dom元素 子组件（Portals组件） // the portal API. class Modal extends React.Component { constructor(props) { super(props); // Create a div that we'll render the modal into. Because each // Modal component has its own element, we can render multiple // modal components into the modal container. this.el = document.createElement('div'); } componentDidMount() { //组件绑定时 // Append the element into the DOM on mount. We'll render // into the modal container element (see the HTML tab). modalRootEl.appendChild(this.el); } componentWillUnmount() { //组件销毁时 // Remove the element from the DOM when we unmount modalRootEl.removeChild(this.el); } render() { // Use a portal to render the children into the element return ReactDOM.createPortal( // 任何react子组件: JSX, strings, arrays, etc. this.props.children, // DOM元素 this.el, ); } } 父组件 class App extends React.Component { constructor(props) { super(props); this.state = {showModal: false}; this.handleShow = this.handleShow.bind(this); this.handleHide = this.handleHide.bind(this); } handleShow() { this.setState({showModal: true}); } handleHide() { this.setState({showModal: false}); } render() { // Show a Modal on click. // (In a real app, don't forget to use ARIA attributes // for accessibility!) const modal = this.state.showModal ? ( &lt;Modal&gt; &lt;div className=&quot;modal&quot;&gt; &lt;div&gt; With a portal, we can render content into a different part of the DOM, as if it were any other React child. &lt;/div&gt; This is being rendered inside the #modal-container div. &lt;button onClick={this.handleHide}&gt;Hide modal&lt;/button&gt; &lt;/div&gt; &lt;/Modal&gt; ) : null; return ( &lt;div className=&quot;app&quot;&gt; This div has overflow: hidden. &lt;button onClick={this.handleShow}&gt;Show modal&lt;/button&gt; {modal} &lt;/div&gt; ); } } 3. Portals创建的组件存在事件冒泡 20. 使用createReactClass()方法创建组件 使用 create-react-class 模块代替Es中class创建组件的方法 1. 基本使用 class创建组件 class Greeting extends React.Component { render() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; } } createReactClass创建组件 var createReactClass = require('create-react-class'); var Greeting = createReactClass({ render: function() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; } }); 2. 声明默认属性（props） class中定义defaultProps属性 class Greeting extends React.Component { // ... } Greeting.defaultProps = { name: 'Mary' }; createReactClass使用defaultProps属性 var Greeting = createReactClass({ getDefaultProps: function() { return { name: 'Mary' }; }, // ... }); 3. 初始化state class组件 class Counter extends React.Component { constructor(props) { super(props); this.state = {count: props.initialCount}; } // ... } createReactClass中创建state //getInitialState方法 var Counter = createReactClass({ getInitialState: function() { return {count: this.props.initialCount}; }, // ... }); 4. 自动绑定this class中.bind(this) class SayHello extends React.Component { constructor(props) { super(props); this.state = {message: 'Hello!'}; // 这一行很重要！ this.handleClick = this.handleClick.bind(this); } handleClick() { alert(this.state.message); } render() { // 由于 `this.handleClick` 已经绑定至实例，因此我们才可以用它来处理点击事件 return ( &lt;button onClick={this.handleClick}&gt; Say hello &lt;/button&gt; ); } } createReactClass中会自动绑定至实例 var SayHello = createReactClass({ getInitialState: function() { return {message: 'Hello!'}; }, handleClick: function() { //直接使用this实例上的属性 alert(this.state.message); }, render: function() { return ( &lt;button onClick={this.handleClick}&gt; Say hello &lt;/button&gt; ); } }); 21. 使用React.createElement语法糖 使用jsx时的语法 class Container from React.Component{ construct(props){ super(props) } render(){ return &lt;div name='test'&gt;container&lt;/div&gt; } } ReactDOM.render(&lt;Container /&gt; , document.getElementById(&quot;root&quot;)) 使用React.createElement语法糖 React.createElement(元素组件名称, 属性, ...children) class Container from React.Component{ construct(props){ super(props) } render(){ return React.createElement('div', {name:'test'}, null) } } ReactDOM.render(React.createElement('Container',null,null) , document.getElementById(&quot;root&quot;)) 创建React.createElement的快捷方式 const e = React.createElement; ReactDOM.render( e('div', null, 'Hello World'), document.getElementById('root') ); 22. Hook 1. 简介 理解 Hook 就是 JavaScript 函数。 注意点： 只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。 只能在 React 的函数组件中或者自定义的 Hook 中调用 Hook。 2. Hook API useState 返回一个 state，以及更新 state 的函数。 setState参数接收一个新的state值 import React, { useState } from 'react'; const [state, setState] = useState(initialState); 计数器demo： // Babel环境 function ContainerButton(){ const [count,setCount]=React.useState(0) const handleAdd=()=&gt;{ setCount(count+1); } return ( &lt;button onClick={handleAdd}&gt;点击{count}&lt;/button&gt; ) } ReactDOM.render( &lt;ContainerButton/&gt;, document.getElementById('root') ); useEffect 初次了解 赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。 effect 将在每轮渲染结束后执行，但你可以选择让它 在只有某些值改变的时候 才执行。 每个 effect 都可以返回一个清除函数。React 会在组件卸载的时候执行清除操作。 不需要清除的effect操作使用 function ContainerButton(){ const [count,setCount]=React.useState(0) const handleAdd=()=&gt;{ setCount(count+1); } React.useEffect(() =&gt; { //会在state状态发生改变时执行 console.log(count) }); return ( &lt;button onClick={handleAdd}&gt;点击{count}&lt;/button&gt; ) } ReactDOM.render( &lt;ContainerButton/&gt;, document.getElementById('root') ); 需要清除的effect操作使用 假设订阅一个ws连接，组件渲染到屏幕之后打开ws连接，组件卸载时关闭连接 function Container(){ const socket = new WebSocket('ws://localhost:8080'); React.useEffect(() =&gt; { socket.addEventListener('open', function (event) { socket.send('Hello Server!'); }); return ()=&gt;{ //销毁时执行的事件 socket.addEventListener('close', function (event) { socket.send('WebSocket close!'); }); } }); return ( &lt;div&gt;WebSocket&lt;/div&gt; ) } ReactDOM.render( &lt;Container/&gt;, document.getElementById('root') ); 详细理解 接收参数： useEffect 接受两个参数，第一个参数是一个回调函数，这个回调函数会在组件渲染之后执行。第二个参数是一个数组，它用来指定在什么情况下需要执行这个回调函数 在组件挂载时只请求一次数据，将 useEffect 的第二个参数设置为空数组 [] useEffect(() =&gt; { // 在组件挂载时请求数据 fetchData(); }, []); 在某个状态变化时重新请求数据，可以将需要监视的状态变量作为 useEffect 的第二个参数 useEffect(() =&gt; { // 在 searchTerm 变化时请求数据 fetchData(); }, [searchTerm]); useContext const value = useContext(MyContext); 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。 基本使用 function Container(){ const [count,setCount]=React.useState(0) const handleAddCount=()=&gt;{ setCount(count+1) } return ( // 传递context &lt;CountContext.Provider value={count}&gt; &lt;div&gt;&lt;ContainerButton handleAddCount={handleAddCount}/&gt;&lt;/div&gt; &lt;/CountContext.Provider&gt; ) } function ContainerButton(props){ const count = React.useContext(CountContext) //调用context return &lt;button onClick={props.handleAddCount}&gt;点击{count}&lt;/button&gt; } const CountContext=React.createContext(0) //创建context ReactDOM.render( &lt;Container/&gt;, document.getElementById('root') ); useReducer useCallback // 配合React.memo使用，memo可以防止父组件状态更新时子组件重新渲染。useCallback函数缓存 import React, { useCallback, memo, useState } from &quot;react&quot;; const Child = memo((props: { count: number }) =&gt; { //memo包裹子组件不会重新渲染,props有父组件值是会重新渲染 console.log(&quot;子组件渲染&quot;); return &lt;div&gt;子组件 {props.count}&lt;/div&gt;; }); const UseCallbackDemo = () =&gt; { let [count, setCount] = useState&lt;number&gt;(0); const handleClick = useCallback(() =&gt; { setCount(++count); }, [count]); return ( &lt;div&gt; &lt;button onClick={handleClick}&gt;点击&lt;/button&gt; &lt;Child count={count} /&gt; &lt;/div&gt; ); }; export default UseCallbackDemo; useMemo useRef useImperativeHandle useLayoutEffect useDebugValue useDeferredValue useTransition useId useSyncExternalStore useInsertionEffect 3. 自定义Hook方法 通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。 自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。 创建 useTitle Hook Demo import { useEffect } from 'react' const useTitle = (title) =&gt; { useEffect(() =&gt; { document.title = title }, []) return } export default useTitle React学习链接 项目网课 https://www.bilibili.com/video/BV1Z44y1K7Fj/?p=99 项目搭建文章 https://juejin.cn/post/7174412042013507615 ","tags":[{"index":-1,"name":"React","slug":"TL1T7hUz1","used":true,"link":"https://qin_hu.gitee.io/blog/tag/TL1T7hUz1/"}],"title":"React入门","feature":"","link":"https://qin_hu.gitee.io/blog/post/react-ru-men/","stats":{"text":"49 min read","time":2937000,"words":10311,"minutes":49},"date":"2023-12-26 11:51:46","dateFormat":"2023-12-26"},{"content":"问题： 一般项目中分为生产环境和测试环境，而生产环境的api路径和测试环境的api路径是不一样的，在打包时指定打包的环境可以解决这个问题。 方案： 1. 在项目根目录创建两个环境变量文件.env.production和.env.test,区分生产环境和正式环境 .env.production # 线上环境平台打包路径 VITE_PUBLIC_PATH = ./ # 线上环境路由历史模式（Hash模式传&quot;hash&quot;、HTML5模式传&quot;h5&quot;、Hash模式带base参数传&quot;hash,base参数&quot;、HTML5模式带base参数传&quot;h5,base参数&quot;） VITE_ROUTER_HISTORY = &quot;hash&quot; # 是否在打包时使用cdn替换本地库 替换 true 不替换 false VITE_CDN = false # 是否启用gzip压缩或brotli压缩（分两种情况，删除原始文件和不删除原始文件） # 压缩时不删除原始文件的配置：gzip、brotli、both（同时开启 gzip 与 brotli 压缩）、none（不开启压缩，默认） # 压缩时删除原始文件的配置：gzip-clear、brotli-clear、both-clear（同时开启 gzip 与 brotli 压缩）、none（不开启压缩，默认） VITE_COMPRESSION = &quot;gzip&quot; # 地址 VITE_BASE = &quot;https://xxx.xxx.com&quot; .env.test # 线上环境平台打包路径 VITE_PUBLIC_PATH = ./ # 线上环境路由历史模式（Hash模式传&quot;hash&quot;、HTML5模式传&quot;h5&quot;、Hash模式带base参数传&quot;hash,base参数&quot;、HTML5模式带base参数传&quot;h5,base参数&quot;） VITE_ROUTER_HISTORY = &quot;hash&quot; # 是否在打包时使用cdn替换本地库 替换 true 不替换 false VITE_CDN = false # 是否启用gzip压缩或brotli压缩（分两种情况，删除原始文件和不删除原始文件） # 压缩时不删除原始文件的配置：gzip、brotli、both（同时开启 gzip 与 brotli 压缩）、none（不开启压缩，默认） # 压缩时删除原始文件的配置：gzip-clear、brotli-clear、both-clear（同时开启 gzip 与 brotli 压缩）、none（不开启压缩，默认） VITE_COMPRESSION = &quot;gzip&quot; # 地址 VITE_BASE = &quot;http://192.168.110.200:9001&quot; 在项目中通过import.meta.env.VITE_BASE访问环境的路径。 题外话，判断生产环境我们使用node提供的process： process.env.NODE_ENV === &quot;development&quot; 2. 在package.json中创建声明打包命令 &quot;scripts&quot;: { ... &quot;build:pro&quot;: &quot;rimraf dist &amp;&amp; vite build --mode production&quot;, &quot;build:test&quot;: &quot;rimraf dist &amp;&amp; vite build --mode test&quot;, ... }, 3. 执行打包 测试环境 npm run build:test 生产环境 npm run build:pro ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"}],"title":"打包 - vite前端项目打包按环境区分路径","feature":"","link":"https://qin_hu.gitee.io/blog/post/da-bao-vite-qian-duan-xiang-mu-da-bao-an-huan-jing-qu-fen-lu-jing/","stats":{"text":"3 min read","time":151000,"words":601,"minutes":3},"date":"2023-12-26 11:34:48","dateFormat":"2023-12-26"},{"content":"1.安装 npm install vue-router@4 2. 创建router实例 router/index.ts import { Router, createRouter, createWebHashHistory, RouteRecordRaw, RouteComponent } from &quot;vue-router&quot;; const routes = [ { path: '/', component: import('../view/home/index.vue') }, { path: '/about', component: import('../view/about/index.vue') }, ] export const router: Router = createRouter({ history: createWebHashHistory(), routes: routes, strict: true, }); export default router 3. 引入router-view视图出口 App.vue &lt;template&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/template&gt; 4. main.ts中引入 import { createApp } from 'vue' import router from './router/route' import App from './App.vue' const app=createApp(App) app.use(router) app.mount('#app') ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"}],"title":"vue生态 - vue-router的基本使用","feature":"","link":"https://qin_hu.gitee.io/blog/post/vue-sheng-tai-vue-router-de-ji-ben-shi-yong/","stats":{"text":"1 min read","time":40000,"words":114,"minutes":1},"date":"2023-12-26 11:31:36","dateFormat":"2023-12-26"},{"content":"1. 搭建基本环境 参考官网说明： https://v2.vuepress.vuejs.org/zh/guide/getting-started.html#%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85 2. 基本配置 使用defaultTheme配置sidebar和navbar import { defineUserConfig, defaultTheme } from 'vuepress' export default defineUserConfig({ lang: 'zh-CN', title: '你好， VuePress ！', description: '这是我的第一个 VuePress 站点', base: '/', theme: defaultTheme({ // 默认主题配置 navbar: [ { text: '首页', link: '/' } ], sidebar: [ // SidebarItem { text: '使用教程', link: '/使用教程/', children: [ { text: '第一篇', link: '/使用教程/first.md', // children: [], }, ], }, // 字符串 - 页面文件路径 '/经验分享/first.md', ], }) }) 3. 创建页面 将 docs 目录作为你的 sourceDir ，例如你在运行 vuepress dev docs 命令。此时，你的 Markdown 文件对应的路由路径为： └─ docs ├─ guide │ ├─ getting-started.md │ └─ README.md ├─ contributing.md └─ README.md 相对路径 路由路径 /README.md / /index.md / /contributing.md /contributing.html /guide/README.md /guide/ /guide/getting-started.md /guide/getting-started.html 4. 自定义布局 参考链接： https://v2.vuepress.vuejs.org/zh/reference/default-theme/extending.html#%E5%B8%83%E5%B1%80%E6%8F%92%E6%A7%BD 创建一个客户端配置文件 .vuepress/client.ts import { defineClientConfig } from '@vuepress/client' import Layout from './layouts/Layout.vue'//引入自定义的布局 export default defineClientConfig({ layouts: { Layout, }, }) 创建 .vuepress/layouts/Layout.vue ，并使用由默认主题的 Layout 布局提供的插槽： &lt;script setup&gt; import ParentLayout from '@vuepress/theme-default/layouts/Layout.vue' &lt;/script&gt; &lt;template&gt; &lt;ParentLayout&gt; &lt;template #page-bottom&gt; &lt;div class=&quot;my-footer&quot;&gt;This is my custom page footer&lt;/div&gt; &lt;/template&gt; &lt;/ParentLayout&gt; &lt;/template&gt; &lt;style lang=&quot;css&quot;&gt; .my-footer { text-align: center; } &lt;/style&gt; 在 Frontmatter 中设置自定义布局： README.md --- layout: CustomLayout --- 组件替换 开发一个子主题 5.在 Markdown 中直接使用 Vue 组件 &lt;span class=&quot;home&quot;&gt;{{num}}&lt;/span&gt; &lt;script setup&gt; const num=2 &lt;/script&gt; &lt;style scoped&gt; .home{ width:400px; height:400px; background:pink; } &lt;/style&gt; 6. Frontmatter Frontmatter 必须在 Markdown 文件的顶部，并且被包裹在一对三短划线中间。下面是一个基本的示例： --- lang: zh-CN title: 页面的标题 description: 页面的描述 --- 可以通过 Frontmatter 来覆盖当前页面的 lang, title, description 等属性 详细配置查看文档：https://v2.vuepress.vuejs.org/zh/reference/default-theme/frontmatter.html 7. 注册vue组件 enhance函数 enhance 函数既可以是同步的，也可以是异步的。它接收一个 Context 参数，包含以下属性： app 是由 createApp 创建的 Vue 应用实例。 router 是由 createRouter 创建的路由实例。 siteData 是一个根据用户配置生成的 Ref 对象，包含 base, lang, title, description, head 和 locales。 enhance 函数会在客户端应用创建后被调用，你可以对 Vue 应用添加各种能力。 注册vue组件 写一个自定义组件 docs/.vuepress/components/Card.vue &lt;script setup lang='ts'&gt; &lt;/script&gt; &lt;template&gt; &lt;div&gt;teest&lt;/div&gt; &lt;/template&gt; &lt;style lang='scss' scoped&gt; &lt;/style&gt; 在client.js中注册vue全局组件 import { defineClientConfig } from '@vuepress/client' import Layout from './layouts/Layout.vue' import Card from &quot;./components/Card.vue&quot; export default defineClientConfig({ layouts: {//注册自定义的布局 Layout, }, enhance({ app }) { app.component('Card', Card)//注册全局组件 }, }) 在README.md中使用 &lt;card&gt;&lt;/card&gt; 使用自定义的样式 在.vuepress文件夹下新建style/index.scss文件 h1 { font-size:50px; } client.js 文件中引入 import { defineClientConfig } from '@vuepress/client' import Layout from './layouts/Layout.vue' import MyLayout from './layouts/MyLayout.vue' import './styles/index.scss' //这里引入自定义样式文件 export default defineClientConfig({ layouts: { Layout, MyLayout }, enhance({ app }) { // app.component('Card', Card) }, }) 学习链接： https://v2.vuepress.vuejs.org/zh/ https://blog.csdn.net/baijiafan/article/details/126884367 ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"}],"title":"vue生态 - vuepress使用","feature":"","link":"https://qin_hu.gitee.io/blog/post/vue-sheng-tai-vuepress-shi-yong/","stats":{"text":"5 min read","time":245000,"words":852,"minutes":5},"date":"2023-12-26 11:30:21","dateFormat":"2023-12-26"},{"content":"创建tsx文件 TsxComponents目录 TsxComponents/src/TsxComponents.tsx import { defineComponent } from &quot;vue&quot;; export default defineComponent({ name: &quot;TsxComponents&quot;, props: { value: { type: undefined, default: [] } }, setup(props, { slots }) { return () =&gt; { if (!slots) return null; return &lt;div&gt;tsx组件测试&lt;/div&gt; }; } }); TsxComponents/index.ts import TsxComponents from &quot;./src/TsxComponents&quot; export { TsxComponents }; 全局注册 main.ts import { TsxComponents } from &quot;@/components/TsxComponents&quot; app.component(&quot;Auth&quot;, Auth); app.component(&quot;TsxComponents&quot;, TsxComponents); 组件中使用 App.vue &lt;TsxComponents&gt;&lt;/TsxComponents&gt; ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"}],"title":"组件 - 封装tsx/jsx组件","feature":"","link":"https://qin_hu.gitee.io/blog/post/zu-jian-feng-zhuang-tsxjsx-zu-jian/","stats":{"text":"1 min read","time":34000,"words":101,"minutes":1},"date":"2023-12-26 11:28:49","dateFormat":"2023-12-26"},{"content":"简介 vue3使用组件的name名当作被递归的组件，在封装tree组件树，动态路由nav，动态表行中起到作用。 三个注意点： 必须在声明组件的name属性 在&lt;script setup&gt;中这样声明： defineOptions({ inheritAttrs: true, customOptions: { name: 'Recursion', }, }); 在循环中要有结束递归的条件 &lt;div v-for=&quot;item in list&quot;&gt; {{ item.a }} &lt;template v-if=&quot;item.children &amp;&amp; item.children.length&quot;&gt; &lt;Recursion :list=&quot;item.children&quot; /&gt; &lt;/template&gt; &lt;/div&gt; 组件全局注册（非必须） import Recursion from './components/Recursion/index.vue'; const app = createApp(App); app.component('Recursion', Recursion); 详细代码 Recursion/index.vue &lt;script setup lang=&quot;ts&quot;&gt; import { reactive, withDefaults, defineProps, defineEmits, computed, defineOptions, } from 'vue'; interface Props { list: any; } defineOptions({ inheritAttrs: true, customOptions: { name: 'Recursion', }, }); const props = withDefaults(defineProps&lt;Props&gt;(), { list: [], }); &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;div v-for=&quot;item in list&quot;&gt; {{ item.a }} &lt;template v-if=&quot;item.children &amp;&amp; item.children.length&quot;&gt; &lt;Recursion :list=&quot;item.children&quot; /&gt; &lt;/template&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; App.vue使用 &lt;Demo :list=&quot;[ { a: '1', b: '2', }, { a: '3', b: '4', children: [ { a: '3', b: '4', }, { a: '5', b: '6', }, ], }, ]&quot; /&gt; ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"}],"title":"组件 - 封装递归组件","feature":"","link":"https://qin_hu.gitee.io/blog/post/zu-jian-feng-zhuang-di-gui-zu-jian/","stats":{"text":"2 min read","time":89000,"words":278,"minutes":2},"date":"2023-12-26 11:24:19","dateFormat":"2023-12-26"},{"content":"封装增删改查的hook vue3+element后台开发封装业务hook 1. useData.ts 存储数据 import { reactive} from 'vue' export default function useData() { const pageData = reactive({ columnData: [ { label: '部门名称', prop: 'traceId', }, { label: '负责人', prop: 'startTime', }, { label: '联系方式', prop: 'userName', }, { label: '职能', prop: 'userId', }, { label: '区域', prop: 'name', }, { label: '校区', prop: 'content', }, { label: '授权', prop: 'auth', }, ] }) return { pageData }; } 基本使用 const { pageData } = useData() 2. useDelete.ts 删除 import { ref } from 'vue' import { ElMessageBox, ElMessage } from 'element-plus' //const idList = ref&lt;Array&lt;number | string&gt;&gt;([]) //批量 export default function useDelete() { async function deleteHandler(id: number | string) { return new Promise((resolve, reject) =&gt; { ElMessageBox.confirm( '确认删除已选中的数据项?', '警告', { confirmButtonText: '确定', cancelButtonText: '取消', } ).then(async () =&gt; { //调接口 ElMessage({ type: 'success', message: '删除成功' }) //idList.value=[] resolve(true) }).catch((err:any) =&gt; { reject(err) }) }) } //多选 function select(val: any) { idList.value = val.idList console.log(idList.value) } return { deleteHandler, //select, //idList }; } 页面使用 //删除后加载数据 const { deleteHandler } = useDelete() async function deleteCb(id:number|string){ try { await deleteHandler(id) loadData() } catch (error) { throw error } } 3. useSearch.ts 查询 import { reactive, ref } from 'vue' import type { FormInstance } from 'element-plus' export default function useSearch() { // 查询的数据 const formData = reactive&lt;{ [key:string]:any }&gt;({ pageSize: 10, pageNum: 1 }) // 表格数据 const tableData = reactive&lt;any&gt;({ list: [], total: 0 }) const searchFormRef = ref&lt;FormInstance&gt;() //数据重载 const reloadData = () =&gt; { formData.pageNum = 1 formData.pageSize = 10 } // 重置 const resetData = () =&gt; { if (searchFormRef.value) { searchFormRef.value.resetFields() searchFormRef.value.clearValidate() } for (const key in formData) { if (Object.prototype.hasOwnProperty.call(formData, key)) { formData[key] = undefined } } reloadData() loadData() } // 查询 const loadData = async () =&gt; { try { //调接口 // tableData.list = res.data.dta } catch (error) { throw error } } return { formData, loadData, searchFormRef, resetData, tableData, reloadData }; } 基本使用 const { formData, tableData, loadData, resetData, reloadData } = useSearch() onMounted(() =&gt; { loadData() }) 4. useUpdate.ts 更新 import { reactive, ref,computed } from 'vue' import type { FormInstance, FormRules } from 'element-plus' import { ElMessage } from &quot;element-plus&quot; export default function useUpdate() { // 添加表单 const updateFormData = reactive&lt;{ [key:string]:any }&gt;({ }) const updateFormRef = ref&lt;FormInstance&gt;() const updateFormRules = reactive&lt;FormRules&gt;({ }) //提交 const submit = async () =&gt; { return new Promise(async (resolve, reject) =&gt; { if (!updateFormRef.value) { reject(false) return } try { await updateFormRef.value.validate() if (rowId.value) { //编辑 //调接口 } else {//添加 //调接口 } closeHandle() ElMessage({ type: 'success', message: '更新成功' }) resolve(true) } catch (error) { reject(error) throw error } }) } //打开弹窗 const rowId = ref() const showHandle = ref(false) const openHandle= (row: any, id?: number | string) =&gt; { resetForm() showHandle.value = true rowId.value=id if (Boolean(id)) {//编辑赋值 for (let key in row) { if (Object.prototype.hasOwnProperty.call(row, key)) { updateFormData[key] = row[key] } } } } //重置表单 const resetForm = () =&gt; { if (updateFormRef.value) { updateFormRef.value.resetFields() updateFormRef.value.clearValidate() } for (let key in updateFormData) { updateFormData[key] =undefined } } //关闭弹窗 const closeHandle= () =&gt; { showHandle.value = false rowId.value=undefined resetForm() } return { updateFormData, updateFormRef, updateFormRules, rowId, submit, showHandle, openHandle, closeHandle, }; } 页面使用 const { updateFormData, updateFormRef, updateFormRules, rowId, submit, openHandle, closeHandle, } = useUpdate() //提交回调 //提交 async function submitCb() { try { await submit() formData.pageNum = 1 formData.pageSize = 10 setTimeout(() =&gt; { loadData() }, 50); } catch (error) { throw error } } 在页面中引入 import { onMounted } from 'vue' import { EditPen, Plus, Refresh, Search } from '@element-plus/icons-vue'; import useSearch from './hook/useSearch'; import useData from './hook/useData'; import useUpdate from './hook/useUpdate'; import useDelete from './hook/useDelete'; import useSettingStore from '@/store/modules/useSettingStore' //数据 const { pageData } = useData() //==查询 const { formData, tableData, loadData, resetData, reloadData, searchFormRef } = useSearch() onMounted(() =&gt; { loadData() }) //==更新 const { updateFormData, updateFormRef, updateFormRules, rowId, submit, openHandle, closeHandle, } = useUpdate() //提交回调 //提交 async function submitCb() { try { await submit() formData.pageNum = 1 formData.pageSize = 10 setTimeout(() =&gt; { loadData() }, 50); } catch (error) { throw error } } //==删除 //删除后加载数据 const { deleteHandler } = useDelete() async function deleteCb(id:number|string){ try { await deleteHandler(id) loadData() } catch (error) { throw error } } 基本弹窗模板 &lt;script setup lang='ts'&gt; import type { FormInstance, FormRules } from 'element-plus'; import { ref, reactive, useAttrs, onMounted } from 'vue' import { requiredCheck } from &quot;@/utils/verify&quot; import useSettingStore from &quot;@/store/modules/useSettingStore/index&quot; const settingStore = useSettingStore() const attrs = useAttrs() interface Props { modelValue?: any, title?: string, cancelText?: string confirmText?: string, width?: string, placeholderText?: string, isMultiple?: boolean } const props = withDefaults(defineProps&lt;Props&gt;(), { modelValue: false, //默认值 title: '新增记账', cancelText: '取消', confirmText: '确定', width: &quot;598px&quot;, isMultiple: true //默认多选 }); const emit = defineEmits(['update:modelValue', 'selectHandler']) //更新 onMounted(() =&gt; { }) //取消 function cancelCb(){ emit('update:modelValue',false) } &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;el-dialog @close=&quot;emit('update:modelValue',false)&quot; v-model=&quot;props.modelValue&quot; :title=&quot;title&quot; :width=&quot;width&quot; align-center draggable :close-on-click-modal=&quot;false&quot;&gt; &lt;div class=&quot;content pad-base&quot;&gt; &lt;/div&gt; &lt;template #footer&gt; &lt;div class=&quot;h-box justify-end&quot;&gt; &lt;span class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;cancelCb&quot;&gt;{{ props.cancelText }}&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;cancelCb&quot;&gt; {{ props.confirmText }} &lt;/el-button&gt; &lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;/el-dialog&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped lang=&quot;less&quot;&gt; :deep(.el-dialog header) { background: #2878e8; color: #fff; padding: unset !important; height: 42px; line-height: 42px; font-size: 15px; } :deep(.el-dialog__title), :deep(.el-dialog__close) { color: #fff; } :deep(.el-dialog__header) { margin: unset !important; border-top-left-radius: 15px; border-top-right-radius: 15px; span { font-size: 15px; margin-left: 10px; } } :deep(.el-dialog__headerbtn) { top: 0px !important; width: 32px !important; height: 32px !important; } .el-dialog__header {} :deep(.el-dialog__footer) { height: 48px; background: #e7eaec; border-bottom-left-radius: 15px; border-bottom-right-radius: 15px; } :deep(.el-dialog) { background-color: transparent; } :deep(.el-dialog__body) { background: #fff; } .header{ .select{ &gt;div{ display: inline-block; width: 60px; border: 1px solid var(--split-line-color); text-align: center; cursor: pointer; padding: 5px; &amp;:nth-child(1){ border-bottom-left-radius: 5px; border-top-left-radius: 5px; } &amp;:nth-child(3){ border-bottom-right-radius: 5px; border-top-right-radius: 5px; } } .active{ border: 1px solid var(--primary-bg); color: var(--primary-bg); } } } .depart{ .el-button{ // width: 200px; justify-content: start; } } .depart-content{ max-width: 200px; display: flex; flex-direction: column; // max-height: 150px; overflow-y: scroll; &amp;::-webkit-scrollbar{ width: 0px; } &gt;span{ margin-bottom: 5px; } } .el-tag { cursor: pointer; } &lt;/style&gt; 分页 usePaging.ts /** * 分页hook * @returns */ import { ref, onMounted, onUnmounted } from 'vue' import { getDynamiclist } from &quot;@renderer/api/dynamic/index&quot; /** * @param selectQuery css选择器 * @param options 自定义参数 * @returns */ export default function usePaging(selectQuery,{ account }) { // const {account}=options // 页数 const pageNum = ref(0) // 页总数 const total = ref(0) // 每页数量 const pageSize = ref(5) // 加载状态 const loadingStatus = ref('more') // 集合 const list = ref([]); // 获取dom const dom = ref() /** * 初始化 */ onMounted(() =&gt; { dom.value = document.querySelector(selectQuery) reload() listenerScroll() }) /** * 重新加载 * @returns */ async function reload() { if (loadingStatus.value == &quot;loading&quot;) { return; } loadingStatus.value = 'more' pageNum.value = 0 list.value = [] await loadMore() } /** * 加载更多 * @returns */ async function loadMore() { if (loadingStatus.value == &quot;loading&quot; || loadingStatus.value == &quot;noMore&quot;) { return; } loadingStatus.value = &quot;loading&quot;; try { // start 调接口，执行逻辑 console.log(pageNum.value) let res = (await getDynamiclist({ pageNum: pageNum.value + 1, pageSize: pageSize.value, account: account })).data if (res.list) { list.value = list.value.concat(res.list.map(item =&gt; { return { ...item, isSelf: item.account === account } })); pageNum.value += 1 } // end // 判断当前加载的数量是否等于总数 if (pageNum.value == 1) { total.value = Number(res.total) } if (list.value.length &lt; total.value) { loadingStatus.value = &quot;more&quot;; } else { loadingStatus.value = &quot;noMore&quot;; } } catch (e) { loadingStatus.value = &quot;more&quot;; pageNum.value-- console.error(e) } } /** * 监听是否滚动到底部 */ function scrollHandle() { const clientHeight = dom.value.clientHeight; const scrollTop = dom.value.scrollTop; const scrollHeight = dom.value.scrollHeight; if (clientHeight + scrollTop === scrollHeight) { loadMore() } } function listenerScroll() { dom.value.addEventListener('scroll', scrollHandle) } /** * 移除监听 */ onUnmounted(() =&gt; { dom.value.removeEventListener('scroll', scrollHandle) }) return { list, loadingStatus }; } ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"}],"title":"hook","feature":"","link":"https://qin_hu.gitee.io/blog/post/feng-zhuang-dui-shu-ju-chu-li-de-hook/","stats":{"text":"9 min read","time":506000,"words":1483,"minutes":9},"date":"2023-12-26 11:22:07","dateFormat":"2023-12-26"},{"content":"1. 了解 Pinia 是 Vue 的存储库，它允许您跨组件/页面共享状态。 2. 安装 npm install pinia npm install pinia-plugin-persistedstate 3. 配置 创建入口 /store/index.ts import { createPinia } from 'pinia'; import { createPersistedState } from 'pinia-plugin-persistedstate'; const pinia = createPinia(); pinia.use( createPersistedState({ storage: sessionStorage, }) ); export default pinia; vue导入插件 main.ts import { createApp } from 'vue'; import './style.css'; import pinia from './store/index.ts'; import App from './App.vue'; const app = createApp(App); app.use(pinia); app.mount('#app'); 4. 创建模块 在store中创建modules文件夹用于存储state模块文件 创建一个测试store文件useDemoStore.ts //defineStore()的返回值命名最好使用 store 的名字，同时以 `use` 开头且以 `Store` 结尾 import { defineStore } from 'pinia'; //1. Options式写法 const useDemoStore = defineStore('demo', { state: () =&gt; { //state return { count: 0, }; }, getters: {}, actions: { //操作state increment() { this.count++; }, }, //持久化存储重点---开启 //这个时候数据默认是存在localStorage persist: { enabled: true, //开启 storage: sessionStorage, //修改存储位置 key: 'userInfo', //设置存储的key paths: ['count'], //指定要长久化的字段 }, }); export default useDemoStore; //2. Setup式写法 // import { ref, computed } from 'vue'; // export const useDemoStore = defineStore( // 'demo', // () =&gt; { // //设置state // let count = ref(0); // //依赖state的计算属性值 // let computedTest = computed(() =&gt; count.value * 99); // //action 修改state // function increment() { // count.value--; // } // function add() { // count.value++; // } // //暴露属性 // return { count, computedTest, add, increment }; // }, // //配置持久化存储 // { // persist: { // enabled: true, //开启 // storage: sessionStorage, //修改存储位置 // key: 'userInfo', //设置存储的key // paths: ['count'], //指定要长久化的字段 // }, // } // ); 5. 使用 使用创建的useDemoStore状态 &lt;script setup lang=&quot;ts&quot;&gt; // store测试 import { useDemoStore } from '../store/modules/useDemoStore.ts'; const store = useDemoStore(); console.log(store); &lt;/script&gt; &lt;template&gt; &lt;div&gt; {{ store.count }} &lt;button @click=&quot;store.increment()&quot;&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"}],"title":"vue生态 - Pinia基本使用","feature":"","link":"https://qin_hu.gitee.io/blog/post/pinia-ji-ben-shi-yong/","stats":{"text":"2 min read","time":118000,"words":404,"minutes":2},"date":"2023-12-26 11:21:05","dateFormat":"2023-12-26"},{"content":"1. vite创建项目 npm create vite@latest project-name 选择vue npm i 2. 初始化文件夹 在src目录下创建pages文件夹（路由），components文件夹(组件) ,utils文件夹 ,types文件夹，network文件夹，router文件夹,store文件夹。在src/assets下创建styles文件夹， 3. 样式初始化 reset.css npm i reset-css border.css /* 该css样式用于解决移动端1像素边框问题。 */ @charset &quot;utf-8&quot;; .border, .border-top, .border-right, .border-bottom, .border-left, .border-topbottom, .border-rightleft, .border-topleft, .border-rightbottom, .border-topright, .border-bottomleft { position: relative; } .border::before, .border-top::before, .border-right::before, .border-bottom::before, .border-left::before, .border-topbottom::before, .border-topbottom::after, .border-rightleft::before, .border-rightleft::after, .border-topleft::before, .border-topleft::after, .border-rightbottom::before, .border-rightbottom::after, .border-topright::before, .border-topright::after, .border-bottomleft::before, .border-bottomleft::after { content: &quot;\\0020&quot;; overflow: hidden; position: absolute; } /* border * 因，边框是由伪元素区域遮盖在父级 * 故，子级若有交互，需要对子级设置 * 定位 及 z轴 */ .border::before { box-sizing: border-box; top: 0; left: 0; height: 100%; width: 100%; border: 1px solid #eaeaea; transform-origin: 0 0; } .border-top::before, .border-bottom::before, .border-topbottom::before, .border-topbottom::after, .border-topleft::before, .border-rightbottom::after, .border-topright::before, .border-bottomleft::before { left: 0; width: 100%; height: 1px; } .border-right::before, .border-left::before, .border-rightleft::before, .border-rightleft::after, .border-topleft::after, .border-rightbottom::before, .border-topright::after, .border-bottomleft::after { top: 0; width: 1px; height: 100%; } .border-top::before, .border-topbottom::before, .border-topleft::before, .border-topright::before { border-top: 1px solid #eaeaea; transform-origin: 0 0; } .border-right::before, .border-rightbottom::before, .border-rightleft::before, .border-topright::after { border-right: 1px solid #eaeaea; transform-origin: 100% 0; } .border-bottom::before, .border-topbottom::after, .border-rightbottom::after, .border-bottomleft::before { border-bottom: 1px solid #eaeaea; transform-origin: 0 100%; } .border-left::before, .border-topleft::after, .border-rightleft::after, .border-bottomleft::after { border-left: 1px solid #eaeaea; transform-origin: 0 0; } .border-top::before, .border-topbottom::before, .border-topleft::before, .border-topright::before { top: 0; } .border-right::before, .border-rightleft::after, .border-rightbottom::before, .border-topright::after { right: 0; } .border-bottom::before, .border-topbottom::after, .border-rightbottom::after, .border-bottomleft::after { bottom: 0; } .border-left::before, .border-rightleft::before, .border-topleft::after, .border-bottomleft::before { left: 0; } @media (max--moz-device-pixel-ratio: 1.49), (-webkit-max-device-pixel-ratio: 1.49), (max-device-pixel-ratio: 1.49), (max-resolution: 143dpi), (max-resolution: 1.49dppx) { /* 默认值，无需重置 */ } @media (min--moz-device-pixel-ratio: 1.5) and (max--moz-device-pixel-ratio: 2.49), (-webkit-min-device-pixel-ratio: 1.5) and (-webkit-max-device-pixel-ratio: 2.49), (min-device-pixel-ratio: 1.5) and (max-device-pixel-ratio: 2.49), (min-resolution: 144dpi) and (max-resolution: 239dpi), (min-resolution: 1.5dppx) and (max-resolution: 2.49dppx) { .border::before { width: 200%; height: 200%; transform: scale(.5); } .border-top::before, .border-bottom::before, .border-topbottom::before, .border-topbottom::after, .border-topleft::before, .border-rightbottom::after, .border-topright::before, .border-bottomleft::before { transform: scaleY(.5); } .border-right::before, .border-left::before, .border-rightleft::before, .border-rightleft::after, .border-topleft::after, .border-rightbottom::before, .border-topright::after, .border-bottomleft::after { transform: scaleX(.5); } } @media (min--moz-device-pixel-ratio: 2.5), (-webkit-min-device-pixel-ratio: 2.5), (min-device-pixel-ratio: 2.5), (min-resolution: 240dpi), (min-resolution: 2.5dppx) { .border::before { width: 300%; height: 300%; transform: scale(.33333); } .border-top::before, .border-bottom::before, .border-topbottom::before, .border-topbottom::after, .border-topleft::before, .border-rightbottom::after, .border-topright::before, .border-bottomleft::before { transform: scaleY(.33333); } .border-right::before, .border-left::before, .border-rightleft::before, .border-rightleft::after, .border-topleft::after, .border-rightbottom::before, .border-topright::after, .border-bottomleft::after { transform: scaleX(.33333); } } layout.css /* 更大设备 */ @media screen and (min-width: 1281px) {} /* 笔记本或PC */ @media screen and (min-width: 1024px) and (max-width: 1280px) {} /* ##平板电脑/Ipad竖屏 */ @media screen and (min-width: 768px) and (max-width: 1023px) {} /* 多数竖屏的智能手机 */ @media screen and (min-width: 320px) and (max-width: 767px) {} /* 公共 */ @media screen and (min-width: 320px) and (max-width: 1023px) { } common.css html { height: 100vh; overflow-x: hidden; overflow: hidden; } .h-fill { width: 100%; } .v-fill { height: 100%; } .fill { width: 100%; height: 100%; } .flex-h { display: flex; flex-direction: row; } .h-box { display: flex; flex-direction: row; align-items: center; } .h-box.gap&gt;div:not(:last-child) { margin-right: 10px; } .h-box-gap { display: flex; flex-direction: row; align-items: center; } .h-box-gap&gt;div:not(:last-child) { margin-right: 15px; } .flex-v { display: flex; flex-direction: column; } .flex-v.gap&gt;div:not(:last-child) { margin-bottom: 10px; } .flex-extend { flex: 1; } .v-box { display: flex; flex-direction: column; align-items: center; } .v-box.gap&gt;div:not(:last-child) { margin-bottom: 10px; } .flex-align-center { align-items: center; } .flex-self-align-end { align-self: flex-end; } .flex-self-align-center { align-self: center; } .flex-align-end { align-items: flex-end; } .justify-center { justify-content: center; } .justify-end { justify-content: flex-end; } .justify-between { justify-content: space-between; } .justify-around { justify-content: space-around; } .flex-wrap { flex-wrap: wrap; } .flex-nowrap { flex-wrap: nowrap; } .bot-fixed { position: fixed; bottom: 0; width: 100%; } .top-fixed { position: fixed; width: 100%; z-index: 9999; } .pos-real { position: relative; } .pos-abs { position: absolute; } .pos-abs-fill { position: absolute; left: 0; top: 0; bottom: 0; right: 0; } .pos-abs-lt { position: absolute; left: 0; top: 0; } .pos-abs-rt { position: absolute; right: 0; top: 0; } .pos-abs-lb { position: absolute; left: 0; bottom: 0; } .pos-abs-rb { position: absolute; right: 0; bottom: 0; } .pos-abs-b { position: absolute; bottom: 0; } .pos-fixed { position: fixed; } .full-screen { width: 100vw; height: 100vh; } .pad-sm { padding: 8px; } .pad-base { padding: 15px; } .pad-lg { padding: 22.5px; } .mg-sm { margin: 8px; } .mg-base { margin: 15px; } .mg-lg { margin: 22.5px; } .mg-l-sm { margin-left: 8px; } .mg-r-sm { margin-right: 8px; } .mg-t-sm { margin-top: 8px; } .mg-b-sm { margin-bottom: 8px; } .mg-l-base { margin-left: 15px; } .mg-r-base { margin-right: 15px; } .mg-t-base { margin-top: 15px; } .mg-b-base { margin-bottom: 15px; } .mg-l-lg { margin-left: 22.5px; } .mg-r-lg { margin-right: 22.5px; } .mg-t-lg { margin-top: 22.5px; } .mg-b-lg { margin-bottom: 22.5px; } .pad-l-sm { padding-left: 8px; } .pad-l-xs { padding-left: 5px; } .pad-r-sm { padding-right: 8px; } .pad-t-sm { padding-top: 8px; } .pad-b-sm { padding-bottom: 8px; } .pad-l-base { padding-left: 15px; } .pad-r-base { padding-right: 15px; } .pad-t-base { padding-top: 15px; } .pad-b-base { padding-bottom: 15px; } .pad-l-lg { padding-left: 22.5px; } .pad-r-lg { padding-right: 22.5px; } .pad-t-lg { padding-top: 22.5px; } .pad-b-lg { padding-bottom: 22.5px; } .text-ellipsis { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } .text-ellipsis-2 { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; white-space: unset; } .text-ellipsis-4 { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 4; overflow: hidden; white-space: unset; } .bg-white { background-color: #FFFFFF; } .text-white { color: #FFFFFF; } .text-gray { color: #AAAAAA; } .text-blue { color: #0089FF; } .text-xs { font-size: 7px; } .text-sm { font-size: 14px; } .text-md { font-size: 16px; } .round-corner { border-radius: 10px; } .text-bold { font-weight: bold; } .text-lighter { font-weight: lighter !important; } .scale-xs { transform: scale(1.2); } .text-center { text-align: center; } .text-right { text-align: right; } .h-scroll { white-space: nowrap; overflow-x: auto; overflow-y: hidden; } .v-scroll { overflow-x: hidden; overflow-y: auto; } .bcg-col-28323D { background-color: #28323D !important; } .bcg-col-2A2B2D { background-color: #1E282F !important; } .bcg-col-3C3D40 { background-color: rgb(31, 38, 48) !important; } .bcg-col-232323 { background-color: #232323 !important; } .bcg-col-171E27 { background-color: #171E27 !important; } .radius-lr-none { border-top-left-radius: 0rpx !important; border-top-right-radius: 0rpx !important; } .mg-l-xs { margin-left: 5px; } .w-100 { width: 100%; } .h-100 { height: 100%; } .cursor-pointer { cursor: pointer } .mg-r-xs { margin-right: 5px; } .col-255-96-16 { color: rgba(255, 96, 16, 0.05); } .col-222 { color: #222; } .col-aaa { color: #aaa; } .line-h { line-height: 1; } 4. 使用less，scss npm i less 5. 配置路径别名 安装@types/node: 解决在ts环境中找不到node中间件的报错 npm i @types/node 在vite.config.ts中添加配置 import { defineConfig } from 'vite' import {resolve} from 'path' import react from '@vitejs/plugin-react' // https://vitejs.dev/config/ export default defineConfig({ plugins: [react()], resolve:{ alias:{ '@':resolve(__dirname,'./src') } } }) ts中配置寻找路径目录 tsconfig.json &quot;compilerOptions&quot;: { ... &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;: { &quot;@/*&quot;:[&quot;src/*&quot;] } 6. 配置ts 7. 引入ui插件 8. 配置路由 9. 封装请求响应拦截器和反向代理 10. 配置pinia https://juejin.cn/post/7047762419019415559#heading-0 https://juejin.cn/post/7081621121350500382 https://juejin.cn/post/7213994684262891576#heading-14 11. 配置主题 12. 配置国际化 https://juejin.cn/post/7123471441168695310#heading-1 13. 封装布局组件 14. 项目托管 15. 编写代码 其他 JsDoc https://blog.csdn.net/KNIGH_YUN/article/details/104845603 思路 初始化项目 基本配置 构建布局 主题 路由和侧边栏 权限验证 标签栏导航 新增页面 样式 ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"}],"title":"项目搭建思路","feature":"","link":"https://qin_hu.gitee.io/blog/post/xiang-mu-kai-fa-si-lu/","stats":{"text":"10 min read","time":588000,"words":1694,"minutes":10},"date":"2023-12-26 11:13:57","dateFormat":"2023-12-26"},{"content":"1. v-overflow-parent 判断子元素是否超出父元素 overflow-parent.js export default { //指令 -- mounted: function (el) { const parent = el.parentNode; const isOverflow = el.scrollWidth &gt; parent.clientWidth; if (isOverflow) { console.log(true); } else { console.log(false); } } }; 使用： &lt;template&gt; &lt;div style=&quot;width: 100px&quot;&gt; &lt;p v-overflow-parent&gt;111111111111111111111111111111111&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import overflowParent from &quot;overflow-parent.js&quot;; export default { directives: { &quot;overflow-parent&quot;: overflowParent, }, }; &lt;/script&gt; 2. v-text-scroll 文字溢出自动滚动，可选滚动到末尾返回，或者滚动到末尾往返 export default { //方案1. 文字滚动到末尾返回到初始位置，可以设置过渡时间 // mounted: function (el, binding) { // // const style = window.getComputedStyle(el); // const textWidth = el.clientWidth; // const contentWidth = el.scrollWidth; // if (contentWidth &gt; textWidth) { // el.style.overflowX = &quot;hidden&quot;; // el.style.whiteSpace = &quot;nowrap&quot;; // let scrollDistance = contentWidth - textWidth; // let duration = binding.value || 2000; // let speed = scrollDistance / duration; // let startTime = null; // function step(timestamp) { // if (!startTime) { // startTime = timestamp; // } // let elapsed = timestamp - startTime; // let distance = speed * elapsed; // el.scrollLeft = distance % (scrollDistance + textWidth); // if (elapsed &lt; duration) { // window.requestAnimationFrame(step); // } else { // startTime = null; // window.requestAnimationFrame(step); // } // } // window.requestAnimationFrame(step); // } // } //方案2. 文字滚动到末尾往返回到初始位置，可以设置速度 mounted(el, binding) { //scrollSpeed增速，值越大滚动速度越快，默认值0.5；\\ let scrollSpeed = 0.5; if (binding.value?.scrollSpeed) { scrollSpeed = binding.value.scrollSpeed; scrollSpeed = scrollSpeed ? scrollSpeed : 0.5; } let scrollContainer = el; let clientWidth = scrollContainer.clientWidth; //元素宽 let contentWidth = scrollContainer.scrollWidth; //可滚动的宽 //父节点添加溢出隐藏 let parent = el.parentNode; parent.style.overflow='hidden' parent.style.whiteSpace=&quot;nowrap&quot; // 设置过渡效果 let isScrollToEnd = false; let scrollLeft = 0; const animate = () =&gt; { let containerWidth = clientWidth; let textWidth = contentWidth; let maxScrollLeft = textWidth - containerWidth; if (textWidth &gt; containerWidth) { // 文本超出容器 if (scrollLeft &lt; maxScrollLeft &amp;&amp; !isScrollToEnd) { // 向左滚动 scrollLeft += scrollSpeed; } else { // 滚动到最右边，开始返回到最左边 isScrollToEnd = true; scrollLeft -= scrollSpeed; if (scrollLeft &lt;= 0) { // 返回到最左边，重新开始向右滚动 isScrollToEnd = false; } } scrollContainer.style.transform = `translateX(-${scrollLeft}px)`; } requestAnimationFrame(animate); }; animate(); } }; 使用： //方案1. &lt;div style=&quot;width: 200px; overflow: hidden&quot;&gt; &lt;p v-text-scroll=&quot;10000&quot;&gt;//过渡时间 ~s~1111111111111111111111111111111111111111111111111111111111~e~ &lt;/p&gt; &lt;/div&gt; //方案2. &lt;div style=&quot;width: 200px; overflow: hidden&quot;&gt; &lt;p v-text-scroll=&quot;1&quot;&gt;//增速 ~s~1111111111111111111111111111111111111111111111111111111111~e~ &lt;/p&gt; &lt;/div&gt; ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"}],"title":"Vue自定义指令","feature":"","link":"https://qin_hu.gitee.io/blog/post/vue-zi-ding-yi-zhi-ling/","stats":{"text":"3 min read","time":159000,"words":508,"minutes":3},"date":"2023-12-26 10:53:40","dateFormat":"2023-12-26"},{"content":"1. vue或者uniapp中webpack编译不能解析mjs 问题报错： Uncaught ReferenceError: require is not defined 解决方案: https://github.com/dcloudio/uni-app/issues/2412 vue.config.js module.exports = { chainWebpack: (config) =&gt; { config.module .rule(&quot;mjs$&quot;) .test(/\\.mjs$/) .include.add(/node_modules/) .end() .type(&quot;javascript/auto&quot;); }, }; 2. 打包后nginx访问时静态资源404 // vite.config.js export default defineConfig({ base:'./', build: { rollupOptions: { // https://rollupjs.org/configuration-options/ }, }, }) 3. VsCode编辑器找不到模块“./App.vue”或其相应的类型声明。 解决方案： 禁用默认的ts扩展 4. 找不到模块 “path“ 或其相对应的类型声明 解决方案： npm i @types/node --D 5. vite + ts 找不到模块@/xxxx 或其相应的类型声明 tsconfig.json { &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;ESNext&quot;, &quot;useDefineForClassFields&quot;: true, &quot;module&quot;: &quot;ESNext&quot;, &quot;moduleResolution&quot;: &quot;Node&quot;, &quot;strict&quot;: true, &quot;jsx&quot;: &quot;preserve&quot;, &quot;resolveJsonModule&quot;: true, &quot;isolatedModules&quot;: true, &quot;esModuleInterop&quot;: true, &quot;lib&quot;: [&quot;ESNext&quot;, &quot;DOM&quot;], &quot;skipLibCheck&quot;: true, &quot;noEmit&quot;: true, //解析非相对模块的基础地址，默认是当前目录 &quot;baseUrl&quot;: &quot;./&quot;, //路径映射，相对于baseUrl &quot;paths&quot;: { &quot;@/*&quot;: [&quot;./src/*&quot;] }, }, &quot;include&quot;: [&quot;src/**/*.ts&quot;, &quot;src/**/*.d.ts&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.vue&quot;], &quot;references&quot;: [{ &quot;path&quot;: &quot;./tsconfig.node.json&quot; }] } 6. 参数“app”隐式具有“any”类型 { &quot;compilerOptions&quot;: { ... &quot;strict&quot;: false, ... }, ... } 7. 开发 Vue3 + TS 项目时，ts文件提示找不到模块“.vue”或其相应的类型声明 https://www.cnblogs.com/lingern/p/16077216.html 8. 找不到模块“@/components/HelloWorld.vue”或其相应的类型声明。 项目根目录新建env.d.ts declare module '*.vue' { import { defineComponent } from 'vue' const component: ReturnType&lt;typeof defineComponent&gt; export default component } ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"}],"title":"Vue开发问题","feature":"","link":"https://qin_hu.gitee.io/blog/post/vue-kai-fa-wen-ti/","stats":{"text":"2 min read","time":119000,"words":397,"minutes":2},"date":"2023-12-26 10:37:34","dateFormat":"2023-12-26"},{"content":"1. 触底加载 使用原生js和uniapp分别实现的demo 1. 判断触底 js 这里我们使用浏览器的三个高度值： 浏览器窗口（文档）的可视高度(visionHeight)：（就是你肉眼可见的那部分全屏高度） window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight 浏览器向上滚动的高度(scrolledHeight)： window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop 文档的真实高度(trueHeight)： document.documentElement.scrollHeight || document.body.scrollHeight 所以： visionHeight + scrolledHeight = trueHeight 就表示滚到底了。 function listenBottomOut (){ //窗口高度 let visionHeight=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight //浏览器向上滚动的高度 let scrollHeight=window.pageYOffset // 文档真实高度 let trueHeight=document.documentElement.scrollHeight let isBottom=visionHeight+scrollHeight&gt;=trueHeight if(isBottom){ //触底了 }else{ //没触底 } // return (visionHeight+scrollHeight)&gt;=trueHeight } uniapp 页面使用onReachBottom方法 scroll-view使用@scrolltolower事件 2. 代码实现 export default { data() { return { list: [], pageNum: 0, pageSize: 20, loadingStatus: 'more' } }, mounted() { this.reload() window.addEventListener('scroll', this.listenBottomOut) }, destroyed() { // 离开页面取消监听 window.removeEventListener('scroll', this.listenBottomOut, false) }, methods: { //触底事件 listenBottomOut() { //窗口高度 let visionHeight = window.innerHeight || document.documentElement.clientHeight || document.body .clientHeight //浏览器向上滚动的高度 let scrollHeight = window.pageYOffset // 文档真实高度 let trueHeight = document.documentElement.scrollHeight if (visionHeight + scrollHeight &gt;= trueHeight) { //触底了 this.loadMore() } }， async reload() { //重新加载 if (this.loadingStatus == &quot;loading&quot;) { return; } this.loadingStatus = 'more' this.pageNum = 0 this.list = [] await this.loadMore() }, async loadMore() { if (this.loadingStatus == &quot;loading&quot; || this.loadingStatus == &quot;noMore&quot;) { return; } this.loadingStatus = &quot;loading&quot;; try { //接口操作 let res = await getPacketList({ //掉接口 data: { pageNum: this.pageNum + 1, pageSize: this.pageSize } }) if (res.pages.rows) { this.list = this.list.concat(res.pages.rows); this.pageNum += 1 } //以下固定写法 if (this.pageNum == 1) { this.total = res.pages.total } if (this.list.length &lt; this.total) { this.loadingStatus = &quot;more&quot;; } else { this.loadingStatus = &quot;noMore&quot;; } } catch (e) { this.loadingStatus = &quot;more&quot;; this.pageNum-- console.error(e) } } } } 2. 实现一个onShow 使用visibilitychange监听窗口的是否可见，当可见是重新对时初始化 mounted() { const onShow = () =&gt; { let isShow = 1 document.addEventListener('visibilitychange', () =&gt; { const leavePageFun = () =&gt; { console.log(&quot;onHide&quot;) } const toPageFun = () =&gt; { console.log(&quot;onShow&quot;) } if (isShow == 2) return if (document.hidden == true) { isShow = 1 leavePageFun() } else { isShow = 2 setTimeout(() =&gt; { isShow = 1 }, 10) toPageFun() } }) } onShow() this.initWeb3Modal() }, 缺点：第一次进入页面时不会调用该方法 ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"},{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"}],"title":"常见前端业务 - 通过语言特性","feature":"","link":"https://qin_hu.gitee.io/blog/post/chang-jian-qian-duan-ye-wu-tong-guo-yu-yan-te-xing/","stats":{"text":"3 min read","time":151000,"words":507,"minutes":3},"date":"2023-12-25 16:37:51","dateFormat":"2023-12-25"},{"content":"1. 轮播图插件 - Swiper swiper 在Vue2中使用的一个demo 1.npm下载安装swiper，现在swiper默认支持vue3，所以我们使用低版本 npm install swiper@5.4.5 2.在需要用到的组件引入swiper import Swiper from &quot;swiper&quot; 3.在组件style中引入swiper插件的css（在node_modules找到Swiper包里边的css文件引入） @import &quot;../../../node_modules/swiper/swiper-bundle.css&quot;; //低版本引入css @import &quot;../../../node_modules/swiper/css/swiper.css&quot;; 4.在methods方法里面初始化swiper插件。 &lt;div class=&quot;swiper-container&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot;&gt;slider1&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;slider2&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;slider3&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ... methods：{ init () { var mySwiper = new Swiper('.swiper-container', { autoplay: true,//可选选项，自动滑动 }) } } .... mounted(){ this.init() //防止swiper初始化不展示，在数据加载成功后(mounted中)调用 } 问题 分页器不显示 https://blog.csdn.net/weixin_42118522/article/details/107586363 2. 音乐播放器 - vue3-aplayer，aplyer 使用vue3实现音乐播放器的demo 1. 下载 npm i vue3-aplayer 2. 引入 import Aplayer from &quot;vue3-aplayer&quot;; ... components: { Aplayer, }, 3. 使用 &lt;aplayer :autoplay=&quot;false&quot; :music=&quot;{ title: '知足', artist: '五月天', src: 'http://freetyst.nf.migu.cn/public/product9th/product45/2022/06/0814/2013年05月07日滚石唱片内容准入327首/标清高清/MP3_128_16_Stero/63480207146145922.mp3', pic: 'https://p2.music.126.net/_B1Fn_Z1WxHzqGLzLZDf-w==/109951163263882447.jpg', lrc: '[00:00.000] 作词 : 五月天 阿信\\n[00:00.675] 作曲 : 五月天 阿信\\n[00:01.350] 编曲 : 周恒毅/五月天\\n[00:02.025] 制作人 : 五月天\\n[00:02.700]\\n[00:21.461]怎么去拥有 一道彩虹\\n[00:27.518]怎么去拥抱 一夏天的风\\n[00:33.441]天上的星星 笑地上的人\\n[00:39.444]总是不能懂 不能觉得足够\\n[00:44.899]\\n[00:51.483]如果我爱上 你的笑容\\n[00:57.461]要怎么收藏 要怎么拥有\\n[01:03.514]如果你快乐 不是为我\\n[01:09.390]会不会放手 其实才是拥有\\n[01:14.335]当一阵风吹来 风筝飞上天空\\n[01:20.653]为了你而祈祷 而祝福 而感动\\n[01:26.355]终于你身影消失在 人海尽头\\n[01:33.046]才发现 笑着哭 最痛\\n[01:38.816]\\n[01:42.504]那天你和我 那个山丘\\n[01:48.429]那样的唱着 那一年的歌\\n[01:54.409]那样的回忆 那么足够\\n[02:00.418]足够我天天 都品尝着寂寞\\n[02:05.873]\\n[02:29.008]当一阵风吹来 风筝飞上天空\\n[02:35.229]为了你而祈祷 而祝福 而感动\\n[02:40.506]终于你身影消失在 人海尽头\\n[02:47.002]才发现 笑着哭 最痛\\n[02:52.140]当一阵风吹来 风筝飞上天空\\n[02:58.514]为了你而祈祷 而祝福 而感动\\n[03:03.925]终于你身影消失在 人海尽头\\n[03:10.379]才发现 笑着哭 最痛\\n[03:15.229]哦……\\n[03:20.122]如果我爱上 你的笑容\\n[03:26.054]要怎么收藏 要怎么拥有\\n[03:31.770]如果你快乐 再不是为我\\n[03:37.491]会不会放手 其实才是拥有\\n[03:42.940]\\n[03:43.414]知足的快乐\\n[03:45.810]叫我忍受心痛\\n[03:49.285]知足的快乐\\n[03:51.948]叫我忍受心痛\\n[03:56.434]\\n[03:57.992] 配唱制作人 : 马毓芬\\n[03:59.550] 协力 : 陈建良\\n[04:01.108] 吉他 : 石头\\n[04:02.666] 木吉他 : 怪兽\\n[04:04.224] 钢琴 : 周恒毅\\n[04:05.782] 弦乐 : 周恒毅\\n[04:07.340] 和声编写 : 阿信+玛莎\\n[04:08.898] 和声 : 阿信\\n[04:10.456] 录音 : Conrad Hijazi+五月天@五月天录音室\\n[04:12.014] 混音 : 林正忠@白金录音室\\n[04:13.572] 录音助理 : 黄士杰+张崇杰\\n[04:15.130] OP : 认真工作室\\n[04:16.688] SP : Rock Music Publishing Co.,Ltd.\\n', theme: 'pic', }&quot; :list=&quot;list&quot; float showLrc fixed :mini=&quot;isMini&quot; @play=&quot;onPlay&quot; @pause=&quot;onPause&quot; &gt; &lt;/aplayer&gt; 文档链接 https://github.com/SevenOutman/vue-aplayer/blob/develop/docs/README.zh-CN.md https://aplayer.netlify.app/docs/guide/events.html#%E5%8E%9F%E7%94%9F-media-%E4%BA%8B%E4%BB%B6 4.注意点 音乐播放器要在切换路由时不进行销毁，此时可以在app.vue下进行全局使用 app.vue &lt;template&gt; &lt;div&gt; &lt;router-view&gt; &lt;/router-view&gt; &lt;!--hide-audio进行隐藏播放器--&gt; &lt;div :class=&quot;isHideAudio?'hide-audio':''&quot;&gt; &lt;!--section-audio封装的组件--&gt; &lt;section-audio&gt;&lt;/section-audio&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; 3. web3连接钱包App - wagmi 使用vue3+wagmi实现的demo: 1. 安装依赖 package.json &quot;dependencies&quot;: { &quot;bignumber.js&quot;: &quot;9.0.2&quot;, &quot;@wagmi/core&quot;: &quot;0.9.5&quot;, &quot;@walletconnect/types&quot;: &quot;2.4.3&quot;, &quot;@web3modal/ethereum&quot;: &quot;2.1.1&quot;, &quot;@web3modal/html&quot;: &quot;2.1.1&quot;, &quot;eth-json-rpc-filters&quot;: &quot;5.1.0&quot;, &quot;eth-json-rpc-middleware&quot;: &quot;9.0.1&quot;, &quot;ethers&quot;: &quot;5.6.0&quot; //当前签名使用5.6.0 } cdn &lt;script type=&quot;text/javascript&quot; src=&quot;https://unpkg.com/evm-chains@0.2.0/dist/umd/index.min.js&quot;&gt;&lt;/script&gt; window.evmChains 2. 连接钱包 import { configureChains, createClient, getProvider, connect, watchAccount, disconnect } from '@wagmi/core' import { goerli, mainnet } from '@wagmi/core/chains' import { EthereumClient, modalConnectors, walletConnectProvider } from '@web3modal/ethereum' import { Web3Modal } from '@web3modal/html' // import { InjectedConnector } from '@wagmi/core/connectors/injected' var web3Modal = null; export default { methods: { initWeb3Modal() { // -----------------------webmodal2初始化 // 1. Define constants const projectId = '8e6b5ffdcbc9794bf9f4a1952578365b' const chains = [mainnet, goerli] // 2. Configure wagmi client const { provider } = configureChains(chains, [walletConnectProvider({ projectId })]) const wagmiClient = createClient({ autoConnect: true, connectors: modalConnectors({ appName: 'WOW EARN', chains }), provider }) // 3. Create ethereum and modal clients ethereumClient = new EthereumClient(wagmiClient, chains) window.web3Modal = web3Modal = new Web3Modal({ projectId }, ethereumClient) console.log('window.web3Modal', window.web3Modal, wagmiClient, ethereumClient) //监听弹窗的打开和关闭 web3Modal.subscribeModal((newState) =&gt; console.log(newState.open) ); //监听是否连接成功 watchAccount( async (account) =&gt; { //connecting 窗口打开，连接中. | connected 连接成功 | disconnected 断开连接 if (account.isConnected &amp;&amp; account.status == &quot;connected&quot;) {//断开连接的操作 console.log('连接成功', account.status) console.log(account) //拿到数据 let chainId = await account.connector.getChainId() let chainData = window.evmChains.getChain(chainId); commit('setSelectedAccount', account.address) commit('setChain', chainData) commit('setConnected', true) } if (account.isDisconnected &amp;&amp; account.status == &quot;disconnected&quot;) {//连接成功的操作 console.log('断开连接', account.status) console.log(account) dispatch('disconnect') Vue.prototype.$stompClient ? .disconnect() //断开websocket链接 uni.reLaunch({ url: '/pages/index/index' }) } } ) }, openweb3Modal() { web3Modal.openModal() } } } &lt;/script&gt; 3. 签名信息 通过签名校验身份登陆 import { disconnect, fetchSigner, signTypedData } from '@wagmi/core' export default { methods: { async createSignature(account, chainId) { //地址chainId return new Promise(async (resolve, reject) =&gt; { try { const domain = { &quot;name&quot;: &quot;Robot Login&quot;, &quot;version&quot;: &quot;1&quot;, &quot;chainId&quot;: chainId, &quot;verifyingContract&quot;: &quot;0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC&quot; } const types = { &quot;EIP712Domain&quot;: [{ &quot;name&quot;: &quot;name&quot;, &quot;type&quot;: &quot;string&quot; }, { &quot;name&quot;: &quot;version&quot;, &quot;type&quot;: &quot;string&quot; }, { &quot;name&quot;: &quot;chainId&quot;, &quot;type&quot;: &quot;uint256&quot; }, { &quot;name&quot;: &quot;verifyingContract&quot;, &quot;type&quot;: &quot;address&quot; } ], &quot;LoginInfo&quot;: [{ &quot;name&quot;: &quot;uri&quot;, &quot;type&quot;: &quot;string&quot; }, { &quot;name&quot;: &quot;nonce&quot;, &quot;type&quot;: &quot;string&quot; }, { &quot;name&quot;: &quot;timeStamp&quot;, &quot;type&quot;: &quot;uint256&quot; }, { &quot;name&quot;: &quot;address&quot;, &quot;type&quot;: &quot;string&quot; } ] } const value = { &quot;uri&quot;: &quot;/auth/loginByAddress&quot;, //路径 &quot;nonce&quot;: uuidv4(), //uuid &quot;timeStamp&quot;: Date.now(), &quot;address&quot;: account } const signature = await signTypedData({ domain, types, value, }) console.log(signature) resolve({ signature: signature, }) } catch (err) { await disconnect() //断开连接 reject(err) // if (err.code == 'ACTION_REJECTED') { // user rejected signing拒绝签名 this.$showError(err.message) // } } }) }, }, } 4. 充值 &lt;script&gt; import { getContract, fetchBalance, getProvider, fetchSigner } from '@wagmi/core' import ERC20TokenABI from '@/common/ERC20.json' export default { methods: { async sendCoin() { let p if (!this.depositAmount || isNaN(p = parseFloat(this.depositAmount))) { //depositAmount：用户输入的充值数量 return } return new Promise(async (resolve, reject) =&gt; { try { var from = this.info.walletAddress;//钱包地址 var to = this.address;//充值地址，通过接口获取 var contractAddress = contractAddrs[`${this.coinName}-${this.currency}`];//合约地址 const signer = await fetchSigner()//签名者 console.log(signer) const contract = getContract({//合约实例 address: contractAddress, abi: erc20ABI, signerOrProvider: signer }) let res = await contract.balanceOf(from)//当前余额 console.log(res.toNumber(), contract) if (res.toNumber() &gt; p * 1000000) { contract.transfer(to, p * 1000000, {//调用方法充值 // gasLimit: gas, // // 偷懒，直接是用 2gwei // gasPrice: ethers.utils.parseUnits(&quot;2&quot;, &quot;gwei&quot;), }).then(function (tx) { console.log(tx); resolve() }).catch((err) =&gt; { console.error(err) reject(err) }) } else { reject(new Error(this.$t('depositPage.errorBalance'))) } } catch (e) { console.error(e) reject(e) } }) } }, } &lt;/script&gt; 官方文档 https://wagmi.sh/core/actions/signTypedData https://docs.ethers.org/v5/ https://web3modal.com/ 4. 连接webSocket - sockjs-client,stompjs 使用vue2实现的demo。 1. 安装 npm i sockjs-client stompjs 2. 使用 main.js ... //引入依赖 import SockJS from 'sockjs-client'; import Stomp from 'stompjs'; Vue.prototype.$connectSocket = () =&gt; { var socket = new SockJS('https://testws.wowearn.com/wow-ws'); var stompClient = Stomp.over(socket); //连接客户端 Vue.prototype.$stompClient = stompClient stompClient.connect({}, function (frame) { //连接 // 订阅消息 stompClient.subscribe('/topic/wow/push-one/'+ uni.getStorageSync('userInfo').id, function (greeting) { console.log('greeting.command',greeting) }); // 新闻消息 stompClient.subscribe('/topic/wow/message/push-all', function (greeting) { if(greeting.command == 'MESSAGE' &amp;&amp; JSON.parse(greeting.body).langKey == uni.getStorageSync('locale')){ // 显示未读红点 store.commit(&quot;user/setMessageStatus&quot;, true) // uni.showTabBarRedDot({ //显示红点 // index: 2 //tabbar下标 // }) } }); }); } 5. 二维码扫码功能 - html5-qrcode 使用vue2+html5-qrcode实现的demo 1. 简单了解 使用这个轻量级库可以轻松/快速地将二维码、条形码和其他常见的代码扫描功能集成到您的web应用程序中。 就是实现h5浏览器扫码。 2. 安装 npm i html5-qrcode or &lt;script src=&quot;https://unpkg.com/html5-qrcode&quot; type=&quot;text/javascript&quot;&gt; 引入： // To use Html5QrcodeScanner (more info below) import {Html5QrcodeScanner} from &quot;html5-qrcode&quot; // To use Html5Qrcode (more info below) import {Html5Qrcode} from &quot;html5-qrcode&quot; 官网地址 3. 思路 拿到cameraId，开启扫码，通过回调拿到扫码内容后关掉扫码弹窗。 授权cameraId 使用Html5Qrcode的getCameras()方法生成一个cameraId，这个id用于标识扫码的窗口。 创建qrcode实例 使用实例中的start方法打开摄像头实现扫码。 4. 代码 封装成组件使用 h5-qrcode.vue文件 &lt;template&gt; &lt;view class=&quot;h5-qrcode&quot;&gt; &lt;view v-if=&quot;showModal&quot; id=&quot;h5-qrcode&quot;&gt; &lt;/view&gt; &lt;view @click=&quot;getCameras&quot; :class=&quot;&quot;&gt; &lt;slot&gt; &lt;/slot&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import { Html5Qrcode } from 'html5-qrcode'; export default { name: &quot;h5-qrcode&quot;, data() { return { cameraId: '', html5QrCode: null, showModal: false } }, methods: { async getCameras() { this.showModal = true try { let devices = await Html5Qrcode.getCameras() if (devices &amp;&amp; devices.length) { if (devices.length &gt; 1) { this.cameraId = devices[1].id; } else { this.cameraId = devices[0].id; } this.start(); this.showModal = false } } catch (e) { uni.showToast({ icon: 'none', title: e }) } }, start() { this.html5QrCode = new Html5Qrcode(&quot;h5-qrcode&quot;); this.html5QrCode .start( this.cameraId, // retreived in the previous step. { fps: 10, // sets the framerate to 10 frame per second qrbox: 250 // 250 // sets only 250 X 250 region of viewfinder to // scannable, rest shaded. }, qrCodeMessage =&gt; { // do something when code is read. For example: if (qrCodeMessage) { console.log('qrCodeMessage', qrCodeMessage) this.$emit('getQrCodeMessage', qrCodeMessage) this.stop(); this.showModal = false } }, errorMessage =&gt; { // parse error, ideally ignore it. For example: // console.log(`QR Code no longer in front of camera.`); } ) .catch(err =&gt; { uni.showToast({ icon: 'none', title: err }) }); }, stop() { this.html5QrCode .stop() .then(ignore =&gt; { // QR Code scanning is stopped. console.log('QR Code scanning stopped.'); }) .catch(err =&gt; { // Stop failed, handle it. console.log('Unable to stop scanning.'); }); }, } } &lt;/script&gt; 新建一个页面使用（建议新建一个页面） &lt;template&gt; &lt;container-layout isBack :topTitle=&quot;``&quot;&gt; &lt;view class=&quot;qrcode&quot;&gt; &lt;view id=&quot;h5-qrcode&quot; style=&quot;margin-top: 15%&quot;&gt; &lt;/view&gt; &lt;/view&gt; &lt;/container-layout&gt; &lt;/template&gt; &lt;script&gt; import { Html5Qrcode } from 'html5-qrcode'; export default { name: &quot;h5-qrcode&quot;, data() { return { cameraId: '', html5QrCode: null, } }, onReady() { this.getCameras() }, methods: { async getCameras() { try { let devices = await Html5Qrcode.getCameras() if (devices &amp;&amp; devices.length) { if (devices.length &gt; 1) { this.cameraId = devices[1].id; } else { this.cameraId = devices[0].id; } this.start(); } } catch (e) { uni.showToast({ icon: 'none', title: e }) } }, start() { this.html5QrCode = new Html5Qrcode(&quot;h5-qrcode&quot;); this.html5QrCode .start( this.cameraId, // retreived in the previous step. { fps: 10, // sets the framerate to 10 frame per second qrbox: 250 }, qrCodeMessage =&gt; { // do something when code is read. For example: if (qrCodeMessage) { console.log('qrCodeMessage', qrCodeMessage) this.stop(); uni.$emit('getQrCodeMessage', qrCodeMessage) uni.navigateBack() } }, errorMessage =&gt; { // parse error, ideally ignore it. For example: // console.log(`QR Code no longer in front of camera.`); } ) .catch(err =&gt; { uni.showToast({ icon: 'none', title: err }) }); }, stop() { this.html5QrCode .stop() .then(ignore =&gt; { // QR Code scanning is stopped. console.log('QR Code scanning stopped.'); }) .catch(err =&gt; { // Stop failed, handle it. console.log('Unable to stop scanning.'); }); }, } } &lt;/script&gt; 6. 生成二维码 - uQRCode 使用uniapp写的一个demo 前面已经写了如何打开相机扫描二维码的功能，现在来看看如何快速生成二维码。 uQRCode基于Canvas API封装了一套方法，建议开发者使用canvas生成，一键调用，非常方便 uQRCode官网示例 ## 使用npm安装 # npm安装 npm install uqrcodejs # 或者 npm install @uqrcode/js 使用 //html部分 &lt;canvas id=&quot;qrcode&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt; ... JS部分 // 获取uQRCode实例 mounted(){ var qr = new UQRCode(); // 设置二维码内容 qr.data = &quot;https://uqrcode.cn/doc&quot;; // 设置二维码大小，必须与canvas设置的宽高一致 qr.size = 200; // 调用制作二维码方法 qr.make(); // 获取canvas元素 var canvas = document.getElementById(&quot;qrcode&quot;); // 获取canvas上下文 var canvasContext = canvas.getContext(&quot;2d&quot;); // 设置uQRCode实例的canvas上下文 qr.canvasContext = canvasContext; // 调用绘制方法将二维码图案绘制到canvas上 qr.drawCanvas(); } 7. 国密加密 - SM2 https://qin_hu.gitee.io/blog/post/jie-kou-qing-qiu-he-xiang-ying-shi-yong-sm2-jia-mi/ 8. 切换路由时取消未完成的异步请求 - axios，vue-router vue切换路由时关闭上一个页面的axios请求。使用vue实现的demo 问题 当切换页面时，上一个页面的axios请求会影响页面加载的速度，降低了用户的体验感，因此需要在切换页面时关闭上一个页面的axios请求。 思路 使用一个全局变量将当前所在页面的所有的请求都保存下来，当切换页面时取消所有的axios请求。 实现 1. request请求拦截器保存请求 window.axiosPromiseArr = [] // axios中设置放置要取消的对象 axios.interceptors.request.use(config =&gt; { //发起请求时保存页面所有请求 config.cancelToken = new axios.CancelToken(cancel =&gt; { window.axiosPromiseArr.push({ cancel }) }); return config }); 2. 阻断response响应拦截器中将所有取消的请求 axios.interceptors.response.use(res=&gt;{ //事件处理 },error=&gt;{ if (axios.isCancel(error)) { // 为了终结promise链 (实际请求不会走到.catch(rej=&gt;{}),这样就不会触发错误提示之类的) return new Promise(() =&gt; {}); }else{ return Promise.reject(error) } }); 3. 进入路由钩子拦截时候，取消保存的axiosPromiseArr router.beforeEach((to, from, next) =&gt; { window._axiosPromiseArr.forEach((ele,index) =&gt; { ele.cancel() // 路由跳转之前，终止上一个页面正在请求的内容 // 清空请求的参数 delete window._axiosPromiseArr[index] }); }); ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"},{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"},{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"常见前端业务 - 基于插件","feature":"","link":"https://qin_hu.gitee.io/blog/post/chang-jian-qian-duan-ye-wu/","stats":{"text":"18 min read","time":1047000,"words":3457,"minutes":18},"date":"2023-12-25 15:50:43","dateFormat":"2023-12-25"},{"content":"最新的vue3版本中这样定义 Demo.vue &lt;script setup lang=&quot;ts&quot;&gt; /* vue3之前在组件中自定义v-model时props是使用value接收值，现在使用modalValue接收 */ import { reactive, withDefaults, defineProps, defineEmits, computed, } from 'vue'; interface Props { modelValue: String; //父组件使用v-model=&quot;modelValue&quot; twoValue: String; //父组件使用v-model:twoValue=&quot;modelValue&quot; } const props = withDefaults(defineProps&lt;Props&gt;(), { modelValue: '', //默认值 twoValue: '', }); const emit = defineEmits(['update:modelValue', 'update:twoValue']); //此时使用withDefaults设置了props默认值， //props是流式的，无法更改 //,所以需要使用计算属性计算出新值 const value = computed(() =&gt; { //通过计算属性绑定新值 return props.modelValue; }); const twoValue = computed(() =&gt; { return props.twoValue; }); &lt;/script&gt; &lt;template&gt; &lt;div class=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;value&quot; @input=&quot;emit('update:modelValue', $event.target.value)&quot; /&gt; &lt;input type=&quot;text&quot; v-model=&quot;TwoValue&quot; @input=&quot;emit('update:twoValue', $event.target.value)&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; App.vue &lt;script setup lang=&quot;ts&quot;&gt; import { ref, onMounted } from 'vue'; const keyword = ref(''); const twoValue = ref(''); import Demo from './Demo.vue'; &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;Demo v-model=&quot;keyword&quot; v-model:twoValue=&quot;twoValue&quot; /&gt; modelValue: {{ keyword }} twoValue:{{ twoValue }} &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 之前的定义方法 1.代码： 1-1.父组件 引入子组件 test-cns1 &lt;template&gt; &lt;view class=&quot;content&quot;&gt; &lt;!-- v-model 接收单个；.sync 接收多个 --&gt; &lt;!-- vue2写法 --&gt; &lt;test-cns1 v-model=&quot;name&quot; :firstName.sync=&quot;first&quot; :lastName.sync=&quot;last&quot;&gt;&lt;/test-cns1&gt; &lt;hr&gt; &lt;!-- vue3写法 --&gt; &lt;!-- &lt;test-cns1 v-model=&quot;name&quot; v-model:first-name=&quot;first&quot; v-model:last-name=&quot;last&quot;&gt;&lt;/test-cns1&gt; --&gt; {{first}}&lt;br&gt;{{last}}&lt;br&gt;{{name}} &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { first:'', last:'', name:'' } } } &lt;/script&gt; 1-2.子组件 &lt;template&gt; &lt;view class=&quot;test-cns&quot;&gt; &lt;!-- 单个双向绑定 input--&gt; name:&lt;input type=&quot;text&quot; :value=&quot;name&quot; @input=&quot;$emit('input', $event.target.value)&quot;&gt; &lt;!-- 多个双向绑定 update: --&gt; firstName:&lt;input type=&quot;text&quot; :value=&quot;firstName&quot; @input=&quot;$emit('update:firstName', $event.target.value)&quot;&gt; lastName: &lt;input type=&quot;text&quot; :value=&quot;lastName&quot; @input=&quot;$emit('update:lastName', $event.target.value)&quot; /&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { props: { name:String, firstName: String, lastName: String } } &lt;/script&gt; &lt;style scoped&gt; .test-cns { display: flex; flex-direction: column; } &lt;/style&gt; 2.总结： 在子组件单个双向绑定发送事件使用input，多个使用 update:Name；父组件接收时，v-model 接收单个，.sync 接收多个（vue3中使用v-model:name的写法） ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"}],"title":"组件 - 自定义v-model指南","feature":"","link":"https://qin_hu.gitee.io/blog/post/zu-jian-zi-ding-yi-v-model-zhi-nan/","stats":{"text":"4 min read","time":199000,"words":614,"minutes":4},"date":"2023-12-25 14:32:39","dateFormat":"2023-12-25"},{"content":"1.简介 组件可以扩展 HTML 元素，封装可重用的代码。 组件系统让我们可以用独立可复用的小组件来构建大型应用. 2.创建局部组件 注册-&gt;配置-&gt;使用（只能在父组件中使用） 2-1.使用方法 2-1-1.注册： var Child={ template:'&lt;h1&gt;子组件&lt;/h1&gt;' } 2-1-2.配置组件名 components:{ 'test':Child // 组件名：注册变量名 } 2-1-3.使用 &lt;test&gt;&lt;/test&gt; 例： &lt;div id=&quot;app&quot;&gt; &lt;runoob&gt;&lt;/runoob&gt; &lt;/div&gt; &lt;script&gt; var Child = { template: '&lt;h1&gt;自定义组件!&lt;/h1&gt;' } // 创建根实例 new Vue({ el: '#app', components: { // &lt;runoob&gt; 将只在父模板可用 'runoob': Child } }) &lt;/script&gt; 3.创建全局组件 3-1.语法： Vue.component(tagName, options); ##使用方法： 3-1-1.注册 Vue.component('all',{ template:'&lt;h1&gt;全局组件&lt;/h1&gt;' }) 3-1-2.使用 &lt;all&gt;&lt;/all&gt; 4.Prop prop 是子组件用来接受父组件传递过来的数据的一个自定义属性。 4-1.props注册 Vue.component('Proptest',{ props:['message'], template:'&lt;h1&gt;{{message}}&lt;/h1&gt;', }) 4-2.使用 1)静态message=&quot;Proptest&quot; &lt;Proptest message=&quot;Proptest&quot;&gt;&lt;/Proptest&gt; 2)动态:message=&quot;Proptest&quot; &lt;Proptest :message=&quot;Proptest&quot;&gt;&lt;/Proptest&gt; 动态prop 类似于用 v-bind 绑定 HTML 特性到一个表达式，也可以用 v-bind 动态绑定 props 的值到父组件的数据中。每当父组件的数据变化时，该变化也会传导给子组件 ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"}],"title":"组件 - 自定义组件","feature":"","link":"https://qin_hu.gitee.io/blog/post/zu-jian-zi-ding-yi-zu-jian/","stats":{"text":"2 min read","time":104000,"words":380,"minutes":2},"date":"2023-12-25 14:31:33","dateFormat":"2023-12-25"},{"content":" 新增组合式API，Vue 的组件可以按两种不同的风格书写：选项式 API 和组合式 API。 1. 动态绑定属性 &lt;script setup lang=&quot;ts&quot;&gt; import { reactive } from 'vue'; const boxStyle = reactive({ class: ['box1', 'box2'], style: { fontSize: '20px', color: 'red', }, }); &lt;/script&gt; &lt;template&gt; &lt;div v-bind=&quot;boxStyle&quot;&gt;动态属性&lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 2. 动态参数 &lt;script setup lang=&quot;ts&quot;&gt; import { ref, computed } from 'vue'; // 1. 动态事件 const isChange = ref('click'); const handlerFun = () =&gt; { console.log(111, isChange.value); }; // 2. 复杂参数使用计算属性 const num = ref(2); let arr = ['class', 'style', 'off']; let setClassName = computed(() =&gt; { return arr[num.value]; }); &lt;/script&gt; &lt;template&gt; &lt;!-- 1. 动态事件 --&gt; &lt;!-- &lt;button v-on:[isChange]=&quot;handlerFun&quot;&gt;动态事件&lt;/button&gt; 下面是简写 --&gt; &lt;!-- 2. 复杂参数使用计算属性 &lt;div off=&quot;2&quot;&gt;复杂参数使用计算属性&lt;/div&gt; --&gt; &lt;div :[setClassName]=&quot;num&quot;&gt;复杂参数使用计算属性&lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 3. reactive和ref reactive响应式对象其实是 JavaScript Proxy代理，其行为表现与一般对象相似。不同之处在于 Vue 能够跟踪对响应式对象属性的访问与更改操作。创建引用类型(集合类型)的响应式对象，对基本类型无效。 ref创建基本数据类型的响应式值 在setup中使用.value访问，在模板中被自动“解包”（不需要加.value） &lt;script setup lang=&quot;ts&quot;&gt; import { reactive, ref } from 'vue'; // 1. ref const num = ref(1); console.log(num.value); // 1.1 也可以直接使用ref创建基本类型响应式 const obj = ref({ a: 1, }); // 1.2 赋值 obj.value = { a: 2, }; obj.value.a = 3; console.log(obj); // 1.3 解包 // - 对象解包 const count = ref(1); const obj1 = reactive({ count, //深层式赋值可行 }); console.log('赋值前:', obj1.count, count.value); //1,1 //此时赋值reactive和ref中的值都会改变 obj1.count = 2; console.log('赋值:', obj1.count, count.value); //2,2 // -数组解包 const arr = reactive([ref('nihao')]); //获取值需要加上value console.log(arr[0].value); //nihao // 2. reactive const data = reactive({ age: 18, name: 'XiaoMing', }); &lt;/script&gt; &lt;template&gt; &lt;!-- 1 --&gt; &lt;div&gt;{{ num }}&lt;/div&gt; &lt;div&gt;{{ obj }}&lt;/div&gt; &lt;!-- { &quot;age&quot;: 18, &quot;name&quot;: &quot;XiaoMing&quot; } --&gt; &lt;div&gt;{{ data }}&lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 4. 使用setup()函数 &lt;!-- 1. 使用setup(props?,context?)函数 手动暴露大量的状态和方法,props参数，接收组件传进来的属性值。context接收上下文传透，插槽，事件和暴露。 注意点： 1. setup函数中的this是undefined 2. setup是要是一个同步函数 3. setup函数中的props直接结构赋值会失去响应式,应该使用 toRefs 和 toRef 这两个工具函数（toRefs将多个props转换为ref，toRef转换单个属性为ref） 4. setup函数中的context参数提供上下文,context中提供attrs, slots, emit, expose这四个方法 --&gt; &lt;script&gt; import { ref, reactive, toRefs, toRef, expose } from 'vue'; export default { props: { title: { default: 'biaoti', type: String, }, }, setup(props, context) { const num = ref(0); const add = () =&gt; { num.value++; }; // 1. props // 将 `props` 转为一个其中全是 ref 的对象，然后解构 const { title } = toRefs(props); // `title` 是一个追踪着 `props.title` 的 ref console.log(title.value); //biaoti // 或者，将 `props` 的单个属性转为一个 ref // const title = toRef(props, 'title') // 2. context /* // 透传 Attributes（非响应式的对象，等价于 $attrs） console.log(context.attrs) // 插槽（非响应式的对象，等价于 $slots） console.log(context.slots) // 触发事件（函数，等价于 $emit） console.log(context.emit) // 暴露公共属性（函数） console.log(context.expose) */ //3. 使用expose暴露公共属性，当父组件通过模板引用访问该组件的实例时，将仅能访问 expose 函数暴露出的内容 //- 让组件实例处于 “关闭状态” 即不向父组件暴露任何东西 expose(); // - 有选择暴露，父组件可以通过模板访问到这个属性 expose({ count: num, }); return { //需要 num, add, }; }, }; &lt;/script&gt; &lt;template&gt; &lt;div&gt;{{ num }}&lt;/div&gt; &lt;button @click=&quot;add&quot;&gt;add&lt;/button&gt; &lt;/template&gt; 5. 使用单文件组件中的&lt;script setup&gt; Demo.vue &lt;script setup lang=&quot;ts&quot;&gt; /* 理解： 1. 支持ts，提高运行性能。(能够使用纯 TypeScript 声明 props 和自定义事件。更好的运行时性能。) 2. &lt;script setup&gt; 中的代码会在每次组件实例被创建的时候执行。 3. 模板中直接使用。（任何在 &lt;script setup&gt; 声明的顶层的绑定 (包括变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用） */ import { ref, reactive, defineProps, withDefaults, useSlots, useAttrs, } from 'vue'; // 1. 响应式 const num = ref(1); const obj = reactive({ age: 12, }); // 2. 自定义指令。必须遵循 vNameOfDirective 这样的命名规范 const vColorRed = { beforeMount(el) { el.style.color = 'red'; }, }; // 3. 使用 defineProps 和 defineEmits API。 // 在声明 props 和 emits 选项时获得完整的类型推导支持 // defineProps 接收与 props 选项相同的值，defineEmits 接收与 emits 选项相同的值。 // 3.1 props // const props = defineProps({ // testName: String, // }); // 在创建props时使用withDefaults声明默认值。使用接口创建类型，withDefaults设置默认值 interface Props { testName: String; } const props = withDefaults(defineProps&lt;Props&gt;(), { testName: 'nihao', }); console.log(props); //{testName: 'demo'} // 3.2 emit，模板中使用emit('change')传事件，父组件使用@change接收事件 const emit = defineEmits(['change']); //4. useSlots() 和 useAttrs() // 得到vue实例上的$slots 和 $attrs const slots = useSlots(); const attrs = useAttrs(); console.log('slots', slots); console.log('attrs', attrs); //attrs {once: 'sfdfsd'} &lt;/script&gt; &lt;template&gt; &lt;div&gt; {{ num }} {{ obj }} &lt;/div&gt; &lt;div&gt; &lt;p v-color-red&gt;自定义指令——字体变红&lt;/p&gt; &lt;!--创建自定义事件 --&gt; &lt;button @click=&quot;emit('change')&quot;&gt;自定义事件&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; App.vue &lt;script setup lang=&quot;ts&quot;&gt; import Demo from './Demo.vue'; const change = () =&gt; { console.log('子组件事件'); }; &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;Demo testName=&quot;demo&quot; @change=&quot;change&quot; once=&quot;sfdfsd&quot; /&gt; &lt;/div&gt; &lt;/template&gt; 6. 计算属性 &lt;script setup lang=&quot;ts&quot;&gt; /* 计算属性与方法的最大区别： 计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算。 */ import { computed, ref } from 'vue'; const num = ref(1); const numScale = computed(() =&gt; { return num.value * 2; }); const addNum = () =&gt; { num.value++; return null; }; &lt;/script&gt; &lt;template&gt; &lt;div&gt; num: {{ num }} numScale: {{ numScale }} &lt;button @click=&quot;addNum&quot;&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 7. class和style &lt;script setup lang=&quot;ts&quot;&gt; import { reactive, ref, computed } from 'vue'; //当class或者style的判断比较复杂时与计算属性结合 const isShow = ref(true); const myClass = computed(() =&gt; ({ active: isShow.value, })); const myStyle = computed(() =&gt; ({ color: isShow.value ? 'red' : '#000', })); &lt;/script&gt; &lt;template&gt; &lt;div :class=&quot;myClass&quot; :style=&quot;myStyle&quot;&gt;动态属性&lt;/div&gt; &lt;button @click=&quot;isShow = !isShow&quot;&gt; {{ isShow ? '红色' : '黑色' }} &lt;/button&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; # 8. 侦听器 &lt;script setup lang=&quot;ts&quot;&gt; import { reactive, watch, ref, computed, watchEffect } from 'vue'; // 1. wath(侦听对象，侦听回调方法,options)。 侦听指定的依赖对象 // 1-1. 监听响应属性值 const num = ref(0); watch( num, (newV, oldV) =&gt; { console.log('newV', newV); console.log('oldV', oldV); }, { // deep: true, immediate: true, } ); const changeNum = () =&gt; { num.value++; }; // 1-2. 监听对象中的属性时需要使用computed const obj = reactive({ a: 1, b: 2, }); watch( computed(() =&gt; obj.a), (newV, oldV) =&gt; { console.log('newV', newV); console.log('oldV', oldV); }, { // deep: true,//深度监听 immediate: true, //立即更新 // flush: 'post',//访问被 Vue 更新之后的 DOM } ); const changeAttr = () =&gt; { obj.a++; }; // 2. watchEffect(侦听回调方法,options) 会在副作用发生期间(方法里的响应值发生变化时)追踪依赖。自动跟踪回调的响应式依赖 watchEffect( () =&gt; { console.log(obj.a); console.log(num.value); }, { // flush: 'post' } ); // 3.停止监听器 const unwatch = watchEffect(() =&gt; {}); // ...当该侦听器不再需要时 unwatch(); &lt;/script&gt; &lt;template&gt; &lt;button @click=&quot;changeNum&quot;&gt;changeNum&lt;/button&gt; &lt;button @click=&quot;changeAttr&quot;&gt;changeAttr&lt;/button&gt; &lt;button @click=&quot;unwatch&quot;&gt;unwatch&lt;/button&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 9. 模板引用 模板上的ref允许在DOM元素创建和加载之后获取到Dom Demo.vue &lt;script setup lang=&quot;ts&quot;&gt; // ref: 模板上的ref允许在DOM元素创建和加载之后获取到Dom import { reactive, ref, onMounted, watchEffect } from 'vue'; // 1. 获取单个ref const testRef = ref(null); // 2. 获取一组ref,将ref绑定在v-for上面时 const testRefs = ref([]); // 3. 动态ref ref可以是一个方法 const testRef3 = ref(null); //在onMounted(组件挂载成功)获取到模板ref onMounted(() =&gt; { console.log(testRef.value); // &lt;div&gt;动态属性&lt;/div&gt; console.log(testRefs.value); console.log(testRef3.value); //&lt;div&gt;testRef3&lt;/div&gt; }); //在watchEffect中获取到ref 需要考虑到ref为null的情况 watchEffect(() =&gt; { if (testRef.value) { console.log(testRef.value); } else { // 此时还未挂载，或此元素已经被卸载（例如通过 v-if 控制） } }); // 4. 一个父组件无法访问到一个使用了 &lt;script setup&gt; 的子组件中的任何东西，除非子组件在其中通过 defineExpose 宏显式暴露 defineExpose({ testRef, testRefs, testRef3, }); &lt;/script&gt; &lt;template&gt; &lt;div ref=&quot;testRef&quot;&gt;动态属性&lt;/div&gt; &lt;div v-for=&quot;item in 2&quot; :key=&quot;item&quot; ref=&quot;testRefs&quot;&gt; &lt;p&gt;{{ item }}&lt;/p&gt; &lt;/div&gt; &lt;div :ref=&quot;(el) =&gt; (testRef3 = el)&quot;&gt;testRef3&lt;/div&gt; &lt;/template&gt; App.vue &lt;script setup lang=&quot;ts&quot;&gt; import { ref, onMounted } from 'vue'; const demo = ref(null); onMounted(() =&gt; { console.log(demo.value); // 打印value中存在testRef，testRefs,testRef3 }); import Demo from './Demo.vue'; &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;Demo ref=&quot;demo&quot; /&gt; &lt;/div&gt; &lt;/template&gt; # 10. 动态组价 元素和特殊的 is attribute 实现,is属性接收组件注册的name属性或者引入的模块名称.is 的值必须加上前缀: 当切换多个组件时 想要组件保持存活状态，可以使用KeepAlive来缓存组件 TestOne.vue &lt;script setup lang=&quot;ts&quot;&gt; import { reactive } from 'vue'; &lt;/script&gt; &lt;template&gt; &lt;div class=&quot;test-one&quot;&gt;TestOne&lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt; .test-one { width: 200px; height: 50px; background: skyblue; } &lt;/style&gt; TestTwo.vue &lt;script setup lang=&quot;ts&quot;&gt; import { reactive } from 'vue'; &lt;/script&gt; &lt;template&gt; &lt;div class=&quot;test-two&quot;&gt;TestTwo&lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt; .test-two { width: 200px; height: 50px; background: pink; } &lt;/style&gt; Demo.vue &lt;script setup lang=&quot;ts&quot;&gt; //&lt;component&gt; 元素和特殊的 is attribute 实现,is属性接收组件注册的name属性或者引入的模块名称.is 的值必须加上前缀: //当切换多个组件时 想要组件保持存活状态，可以使用KeepAlive来缓存组件 import { ref } from 'vue'; import TestOne from '../components/TestOne/index.vue'; import TestTwo from '../components/TestTwo/index.vue'; const show = ref(1); &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;top&quot;&gt; &lt;p @click=&quot;show = 1&quot;&gt;组件1&lt;/p&gt; &lt;p @click=&quot;show = 2&quot;&gt;组件2&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt; &lt;component :is=&quot;show === 1 ? TestOne : TestTwo&quot;&gt;&lt;/component&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt; .box { } .top { display: flex; width: 200px; justify-content: space-between; cursor: pointer; } &lt;/style&gt; 11. 组件自定义v-model 移步到这篇文章： https://www.heerblog.top/viewArticle?aid=96035f11-2209-9d4c-9d96-05339c924a11 Demo.vue &lt;script setup lang=&quot;ts&quot;&gt; /* vue3之前在组件中自定义v-model时props是使用value接收值，现在使用modalValue接收 */ import { reactive, withDefaults, defineProps, defineEmits, computed, } from 'vue'; interface Props { modelValue: String; //父组件使用v-model=&quot;modelValue&quot; twoValue: String; //父组件使用v-model:twoValue=&quot;modelValue&quot; } const props = withDefaults(defineProps&lt;Props&gt;(), { modelValue: '', //默认值 twoValue: '', }); const emit = defineEmits(['update:modelValue', 'update:twoValue']); //此时使用withDefaults设置了props默认值， //props是流式的，无法更改 //,所以需要使用计算属性计算出新值 const value = computed(() =&gt; { //通过计算属性绑定新值 return props.modelValue; }); const twoValue = computed(() =&gt; { return props.twoValue; }); &lt;/script&gt; &lt;template&gt; &lt;div class=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;value&quot; @input=&quot;emit('update:modelValue', $event.target.value)&quot; /&gt; &lt;input type=&quot;text&quot; v-model=&quot;TwoValue&quot; @input=&quot;emit('update:twoValue', $event.target.value)&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; App.vue &lt;script setup lang=&quot;ts&quot;&gt; import { ref, onMounted } from 'vue'; const keyword = ref(''); const twoValue = ref(''); import Demo from './Demo.vue'; &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;Demo v-model=&quot;keyword&quot; v-model:twoValue=&quot;twoValue&quot; /&gt; modelValue: {{ keyword }} twoValue:{{ twoValue }} &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 12. 禁用Attributes继承 &lt;script lang=&quot;ts&quot;&gt; // 使用普通的 &lt;script&gt; 来声明选项 export default { inheritAttrs: false, }; &lt;/script&gt; &lt;script setup lang=&quot;ts&quot;&gt; import { reactive, useAttrs } from 'vue'; const attrs = useAttrs(); //或者直接在模板中使用$attrs console.log(attrs); //{demo: 'test', __vInternal: 1} /* 如果你不想要一个组件自动地继承 attribute，你可以在组件选项中设置 inheritAttrs: false */ &lt;/script&gt; &lt;template&gt; &lt;div&gt;{{ attrs }}&lt;/div&gt; &lt;div&gt;{{ $attrs }}&lt;/div&gt; &lt;/template&gt; 13. 依赖和注入(provide和 inject) 总结 父传子方案： provide 和 inject解决&quot;prop 逐级透传&quot;问题。一个父组件相对于其所有的后代组件，会作为依赖提供者。任何后代的组件树，无论层级有多深，都可以注入由父组件提供给整条链路的依赖。 传值与注入值 provide传值 provide(/* 注入名 */ 'message', /* 值 */ 'hello!') inject注入值 const value = inject('message', '这是默认值') 传响应式的值,修改响应式的值使用方法 provide传值 const name = ref(''); const updateName = (e) =&gt; { name.value = e.target.value; }; provide('name', { name, updateName//更新值的方法 }); inject注入值 const { name, updateName } = inject('name'); //使用updateName更新 可以使用readonly()禁止修改 官方建议使用 Symbol 作注入名,避免键名冲突 案例 创建Demo父组件，Demo父组件下有一个DemoZindexTwo子组件，DemoZindexTwo组件下有一个DemoZindexOne组件。使用provide将Demo组件数据传递到子组件DemoZindexOne中，实现祖孙数据传递。 第一层子组件 DemoZindexTwo/index.vue &lt;script setup lang=&quot;ts&quot;&gt; import DemoZindexOne from '../DemoZindexOne/index.vue'; &lt;/script&gt; &lt;template&gt; &lt;div style=&quot;width: 200px; height: 200px; background: pink&quot;&gt; DemoZindexTwo &lt;DemoZindexOne /&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 第二层子组件：DemoZindexOne/index.vue &lt;script setup lang=&quot;ts&quot;&gt; import { inject } from 'vue'; import { myInjectionKey } from '../../utils/key.ts';//Symbol键名 const age = inject('age', 1); //inject('key',defaultValue) console.log('DemoZindexOne', age); const { name, updateName } = inject('name'); console.log('DemoZindexOne name', name); const myInjectValue = inject(myInjectionKey); console.log(myInjectValue); //nihao &lt;/script&gt; &lt;template&gt; &lt;div style=&quot;width: 100px; height: 100px; background: green; font-size: 12px&quot;&gt; DemoZindexOne {{ name }} &lt;input type=&quot;text&quot; @input=&quot;updateName&quot; :value=&quot;name&quot; /&gt; {{ myInjectValue }} &lt;/div&gt; &lt;/template&gt; 父组件：Demo.vue &lt;script setup lang=&quot;ts&quot;&gt; /* 父传子方案： provide 和 inject解决&quot;prop 逐级透传&quot;问题。一个父组件相对于其所有的后代组件，会作为依赖提供者。任何后代的组件树，无论层级有多深，都可以注入由父组件提供给整条链路的依赖。 */ import DemoZindexTwo from '../components/DemoZindexTwo/index.vue'; import { myInjectionKey } from '../utils/key.ts'; import { provide, ref, readonly } from 'vue'; //1. 父组件传值 provide('age', 18); //子组件接收：inject('age',defalutValue) //2. 传响应式的值,修改响应式的值使用方法 const name = ref(''); const updateName = (e) =&gt; { console.log(e.target.value); name.value = e.target.value; }; provide('name', { //传一个对象 name, updateName, }); //3. 可以使用readonly()禁止修改 const count = ref(0); provide('count', readonly(count)); //4. 使用 Symbol 作注入名,避免键名冲突 const myInjectValue = provide(myInjectionKey, 'nihao'); &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;DemoZindexTwo/&gt; &lt;input type=&quot;text&quot; @input=&quot;updateName&quot; :value=&quot;name&quot; /&gt; &lt;/div&gt; &lt;/template&gt; App.vue &lt;script setup lang=&quot;ts&quot;&gt; import { ref, onMounted } from 'vue'; import Demo from './Demo.vue'; &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;Demo /&gt; &lt;/div&gt; &lt;/template&gt; # 14. 异步组件 defineAsyncComponent 方法接收一个返回 Promise 的加载函数。这个 Promise 的 resolve 回调方法应该在从服务器获得组件定义时调用。你也可以调用 reject(reason) 表明加载失败。 官方文档说明: https://cn.vuejs.org/guide/components/async.html 15. 组合式函数 “组合式函数”(Composables) 是一个利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数。将状态值暴露出去。将逻辑放在一起利于维护。 Demo.vue &lt;!-- “组合式函数”(Composables) 是一个利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数。将状态值暴露出去。 --&gt; &lt;script setup lang=&quot;ts&quot;&gt; import { reactive } from 'vue'; import { useRandomColor } from '../composables/useRandomColor/index.ts'; import { useBoxRadius } from '../composables/useBoxRadius/index.ts'; const { color, setColor } = useRandomColor(); //组合式函数。设置随机颜色 const { setRadius } = useBoxRadius('box'); //传值的组合式函数。设置radius &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;div id=&quot;box&quot; :style=&quot;{ backgroundColor: color, width: '200px', height: '150px' }&quot; &gt;&lt;/div&gt; &lt;button @click=&quot;setColor&quot;&gt;设置随机颜色&lt;/button&gt; &lt;button @click=&quot;setRadius(50)&quot;&gt;设置圆角值&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; composables/useRandomColor/index.ts import { ref } from 'vue'; export function useRandomColor() { //获取随机颜色 const getRandomColor = () =&gt; { var letters = '0123456789ABCDEF'; var color = '#'; for (var i = 0; i &lt; 6; i++) { color += letters[Math.floor(Math.random() * 16)]; } return color; }; const color = ref(''); color.value = getRandomColor(); //设置颜色 const setColor = () =&gt; { color.value = getRandomColor(); }; return { //将组合式中的方法，状态暴露出去 color, setColor, }; } composables/useBoxRadius/index.ts //设置圆角值 export function useBoxRadius(boxDomId: string) { const setRadius = (num: number) =&gt; { console.log(boxDomId); let boxDom = document.querySelector(`#${boxDomId}`) as HTMLElement; console.log(boxDom); if (boxDom &amp;&amp; boxDom.style) { boxDom.style.borderRadius = `${num}px`; } }; return { setRadius, }; } # 16. &lt;Teleport&gt; &lt;!-- &lt;Teleport&gt; 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。 props：（1）to 指向选择器 （2）disabled 是否禁用 &lt;Teleport to=&quot;选择器&quot; :disabled=&quot;false&quot;&gt; --&gt; &lt;script setup lang=&quot;ts&quot;&gt; import { reactive, ref } from 'vue'; const show = ref(false); &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;button @click=&quot;show = true&quot;&gt;open modal&lt;/button&gt; &lt;/div&gt; &lt;Teleport to=&quot;body&quot;&gt; &lt;div class=&quot;modal&quot; v-show=&quot;show&quot;&gt; &lt;button @click=&quot;show = false&quot;&gt;close modal&lt;/button&gt; &lt;/div&gt; &lt;/Teleport&gt; &lt;/template&gt; &lt;style scoped&gt; .modal { position: fixed; inset: 0; background: #ffffff20; width: 100%; height: 100%; } button { margin-top: 50%; } &lt;/style&gt; 17. css功能 &lt;script setup lang=&quot;ts&quot;&gt; import { reactive, ref } from 'vue'; const color = ref('red'); const styles = reactive({ fontSize: '22px', }); &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;p :class=&quot;$style.test&quot;&gt;css Modules&lt;/p&gt; &lt;p :class=&quot;modules.test&quot;&gt;css Modules 自定义名称&lt;/p&gt; &lt;p class=&quot;ref&quot;&gt;v-bind语法&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt; /* 1. scoped。 带有 scoped attribute 的时候，它的 CSS 只会影响当前组件的元素 */ /* 2. :deep() 这个伪类访问根节点,子组件内深度内容 */ :deep(.text) { color: red; } /* 3. :slotted() 伪类以明确地将插槽内容作为选择器的目标 */ :slotted(div) { color: red; } /* 4. :global() 伪类让其中一个样式规则应用到全局 */ :global(.red) { color: red; } /* 5. v-bind语法 将响应式属性应用到css上 */ .ref { color: v-bind('color'); font-size: v-bind('styles.fontSize'); } &lt;/style&gt; &lt;!-- 6. 混合使用局部与全局样式 &lt;style&gt; /* 全局样式 */ &lt;/style&gt; &lt;style scoped&gt; /* 局部样式 */ &lt;/style&gt; --&gt; &lt;!-- /* 7. CSS Modules 使用$style.className访问。 &lt;p :class=&quot;$style.test&quot;&gt;css Modules&lt;/p&gt; */ --&gt; &lt;style module&gt; .test { color: skyblue; } &lt;/style&gt; &lt;!-- /* 8. css Modules可以也可自定义名称 &lt;p :class=&quot;modules.test&quot;&gt;css Modules 自定义名称&lt;/p&gt; */ --&gt; &lt;style module=&quot;modules&quot;&gt; .test { color: red; } &lt;/style&gt; vue API https://cn.vuejs.org/api/ ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"}],"title":"Vue3总结","feature":"","link":"https://qin_hu.gitee.io/blog/post/vue3-zong-jie/","stats":{"text":"24 min read","time":1417000,"words":4784,"minutes":24},"date":"2023-12-25 14:30:10","dateFormat":"2023-12-25"},{"content":"一.安装vue环境 1 Vue Devtools 在浏览器上安装 Vue Devtools插件 2.直接用&lt;script&gt;标签 引入 制作原型或者学习 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt; 生产环境 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14&quot;&gt;&lt;/script&gt; 使用原生 ES Modules &lt;script type=&quot;module&quot;&gt; import Vue from 'https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.esm.browser.js' &lt;/script&gt;` 3.NPM $ npm install vue 4.命令行工具 (CLI) Vue 提供了一个官方的 CLI，为单页面应用 (SPA) 快速搭建繁杂的脚手架。它为现代前端工作流提供了开箱即用的构建设置。只需要几分钟的时间就可以运行起来并带有热重载、保存时 lint 校验，以及生产环境可用的构建版本。 (vue安装详解)[https://cn.vuejs.org/v2/guide/installation.html] 二.创建Hello world 注意点 1. 创建vue实例，代码从此处开始 2. 一个实例对应一个容器，一一对应 3. 语法点 el 挂载点，选定vue要使用哪个容器，通常为css选择器。也可以用dom获取元素 data data存储数据，供el指定容器使用 {{}} {{}}意为插值表达式，里面写js表达式 代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;title&gt;HelloWorld&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 创建容器 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- {{}}插值表达式 --&gt; Hello{{value}} &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip=false//此行代码取消vue控制台生产环境提示 &lt;/script&gt; &lt;script&gt; //创建vue实例，代码从此处开始 const app=new Vue({ el:'#app',//挂载点，选定vue要使用哪个容器，通常为css选择器。也可以用dom获取元素 data:{ //data存储数据，供el指定容器使用 value:&quot;world&quot; } }) &lt;/script&gt; &lt;!-- 1.创建vue实例，代码从此处开始 2.一个实例对应一个容器，一一对应 3.语法点 --&gt; 三.模板语法 1.插值语法 插值法解析标签体内容 {{}} 2.指令语法 插值用于解析标签（包括标签属性，标签体内容，绑定事件等），插值语法“v-”开头 1.v-bind 动态绑定属性,是一种单向的数据绑定，v-bind可以简写: &lt;a v-bind:href=&quot;url.toLocaleUpperCase()&quot;&gt; {{urlText}} &lt;/a&gt; &lt;!-- 简写： --&gt; &lt;a :href=&quot;url.toLocaleUpperCase()&quot;&gt; {{urlText}} &lt;/a&gt; 2.v-model:value 动态绑定属性,是一种双向的数据绑定，只能应用在表单内元素，有value值的标签上，简写为v-model 单向绑定：&lt;input type=&quot;text&quot; :value=&quot;value&quot;&gt; 双向绑定：&lt;input type=&quot;text&quot; v-model=&quot;value2&quot;&gt; 四.el和data的两种写法 el 写法1，挂载点 var vm=new Vue({//vm el:'#app', data:{ text:&quot;数据&quot; } }) 写法2.利用$mount将数据“放/挂载”到vm上去 var vm=new Vue({//vm data:{ //data写法1.对象式 text:&quot;数据&quot; } }) vm.$mount(&quot;#app&quot;) data 写法1.对象式 var vm=new Vue({//vm data:{ //data写法1.对象式 text:&quot;数据&quot; } }) vm.$mount(&quot;#app&quot;) 写法2.函数式 var vm=new Vue({//vm data(){ //data写法2.函数式 return{ text:'你好' } } }) vm.$mount(&quot;#app&quot;) 五.mvvm的理解 1、实现数据与视图的分离 2、通过数据来驱动视图，开发者只需要关心数据变化，DOM操作被封装了。 mvvm模型 M:模型(model):data中的数据 v:视图（view）:模板代码 vm:视图模型（viewModel）：vue实例 观察发现 data中的所有属性，最后都出现在vm身上 vm身上所有的属性及vue原型上的所有属性，在vue模板中都可以直接使用。 六.数据代理 Object.defineProperty()的使用 该方法允许精确地添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，在枚举对象属性时会被枚举到（for...in 或 Object.keys 方法），可以改变这些属性的值，也可以删除这些属性。这个方法允许修改默认的额外选项（或配置）。默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改（immutable）的。 可选键值 configurable 该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。 enumerable 当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。 value 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。 默认为 undefined。 writable 当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符 (en-US)改变。 默认为 false。 // 1.Object.defineProperty()的使用 var obj1 = { x: 1, y: 2 } var obj2 = {} Object.defineProperty(obj1, &quot;z&quot;, { value: 3, //将值插入到了obj1中， configurable: false, //该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。 enumerable: false, //该属性才会出现在对象的枚举属性中。 writable: true //设置值可被赋值符改变 }) // enumerable设置为false，此时不能枚举 for (const key in obj1) { console.log(key) } get 该函数的返回值会被用作属性的值。 set 传一个参数设置get接收的值，进行写的操作 数据代理 通过一个对象代理对另一个对象中的属性的操作（读/写） // 通过obj2修改obj1 var obj1 = { x: 1, y: 2 } var obj2 = {} Object.defineProperty(obj2,'y',{ get(){ return obj1.y //得到obj1中的数据 }, set(value){ obj1.y=value } }) vue中的数据代理 通过vm对象来代理data对象中属性的操作（读/写）。 基本原理 通过Object.defineProperty()把data对象中所有属性添加到vm上。为每一个添加到vm上的属性都指定一个getter/setter。在getter/setter内部去操作(读/写)data中的对应的属性。 vue通过_data得到data中的数据，vm对_data中的数据进行数据代理。_data中进行了数据劫持，目的是渲染页面 七.事件处理 常用事件 点击事件 click v-on:click //or @click 滚轮事件 wheelDelta,scoll 键盘事件 @keyup.enter //or @keydown.enter 事件修饰符 prevent: 阻止默认事件 stop: 阻止事件冒泡 once: 事件只触发1次 capture: 使用事件的捕获模式 self: 只要event.target是当前操作的元素才触发事件 passive: 事件的默认行为立即执行，无需等待事件回调完成 事件总结 使用@xxx或者是v-on:xxx绑定事件，xxx表示事件名 事件的回调配置在methods中，最终会在vm上出现 methods中配置的函数不要使用箭头函数，否则this就不是vm了 methods中配置的函数是被vue所管理的函数，this指向vm或者组件实例对象 @test与@test($event)效果一致 八.计算属性 定义 计算属性是将其data属性中的值进行操作从而得到的一个新的属性，存在缓存机制，提高复用率 示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br&gt;&lt;br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;text&quot; v-model=&quot;fullName&quot;&gt; &lt;/div&gt; &lt;script&gt; var vm=new Vue({ el:'#app', data:{ firstName:'张', lastName:'三' }, computed:{ //1.默认为get // fullName:function(){ // return this.firstName+'-'+this.lastName // } //2.简写格式 // fullName(){ // return this.firstName+'-'+this.lastName // } //3.当要修改计算属性值时 fullName:{ get(){ console.log('ok'); return this.firstName+'-'+this.lastName }, set(value){ return value } } } }) console.log(vm); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 计算属性总结 计算属性: 1.定义:要用的属性不存在，要通过已有属性计算得来。 2.原理:底层借助了0bjcet.defineproperty方法提供的getter和setter。 3.get函数什么时候执行? (1).初次读取时会执行一次。 (2),当依赖的数据发生改变时会被再次调用。 4.优势:与methods实现相比，内部有缓存机制(复用)，效率更高，调试方便。 5.备注: 1.计算属性最终会出现在vm上，直接读取使用即可。 2.如果计算属性要被修改，那必须写set两数去响应修改，且set中要引起计算时依赖的数据发生 九.监听属性 定义 通过 watch 来响应数据的变化。 watch初始化的时候不会运行,只有数据被改变之后才会运行 当需要在数据变化时执行异步或开销较大的操作时，watch这个方式是最有用的。 使用 写法１.watch对象方法 watch:{ 监听的data数据(newval,oldval){ console.log(newval+&quot;---&quot;+oldval) } } 写法2.vm实例对象中的$watch vm.$watch('监听的data数据,function(newval,oldval){ console.log(&quot;新值：&quot;+newval); console.log(&quot;旧值：&quot;+oldval); }) 写法3.watch对象中的配置参数handler watch: { count: { handler(newV, oldV) {//监听值 console.log(&quot;新值：&quot; + newV); console.log(&quot;旧值：&quot; + oldV); }, immediate:true,//立即执行监听 } } 深度监听 监视多级结构中所有属性的变化 使用deep配置项 深度监视: (1).Vue中的watch默认不监测对象内部值的改变(一层)。 (2).配置deep:true可以监测对象内部值改变(多层)。 备注: (1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以! (2).使用watch时根据数据的具体结构，决定是否采用深度监视。 计数器体验监听属性 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;title&gt;监听属性&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt; {{count}} &lt;/p&gt; &lt;button @click=&quot;count++&quot;&gt; 点我 &lt;/button&gt; &lt;/div&gt; &lt;!-- 计数器体验watch --&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false // 1.$watch实例方法,响应值变化 // var vm = new Vue({ // el: &quot;#app&quot;, // data: { // count: 0 // } // }) // vm.$watch('count',function(newV,oldV){ // console.log(&quot;新值：&quot;+newV); // console.log(&quot;旧值：&quot;+oldV); // }) // 2.watch对象 var vm = new Vue({ el: &quot;#app&quot;, data: { count: 0 }, watch: { count(newV, oldV) { console.log(&quot;新值：&quot; + newV); console.log(&quot;旧值：&quot; + oldV); } } }) // 3.watch对象中的配置参数handler // var vm = new Vue({ // el: &quot;#app&quot;, // data: { // count: 0 // }, // watch: { // count: { // handler(newV, oldV) { //监听值 // console.log(&quot;新值：&quot; + newV); // console.log(&quot;旧值：&quot; + oldV); // }, // immediate: true, //立即执行监听 // deep:true//深度监视 // } // } // }) &lt;/script&gt; &lt;/html&gt; 十.监视属性与计算属性对比 监视属性与计算属性对比 comuted能完成的功能，watch都能完成 watch能完成的功能，comuted不一定能完成，例如：watch可以进行异步操作。 两个重要的原则： （1）所有Vue管理的函数，最好写成普通函数，这样this指向才是vm或组件实例对象 （2）所有不被Vue管理的函数（定时器回调函数，ajax的回调等），最好写出=成箭头函数，这样this指向才是vm或组件实例对象 监视器姓名案例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br&gt;&lt;br&gt; 名: &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br&gt;&lt;br&gt; 姓名：&lt;span&gt;{{fullName}}&lt;/span&gt; &lt;/div&gt; &lt;!-- 使用监听属性完成姓名案例 --&gt; &lt;/body&gt; &lt;script&gt; var app = new Vue({ el: &quot;#app&quot;, data: { firstName: '张', lastName: '三', fullName: '张-三' }, watch: { firstName(newV) { //可以使用异步操作 setTimeout(() =&gt; {//此时的箭头函数指向window this.fullName = newV + '-' + this.lastName }, 1000); }, lastName(newV) { this.fullName = this.firstName + '-' + newV } } }) &lt;/script&gt; &lt;/html&gt; 十一.绑定class和style 绑定class 绑定一个对象 对象值为字符串: &lt;div class=&quot;class1&quot; :class=&quot;mystyle&quot;&gt; &lt;/div&gt; /////////////// data:{ mystyle:'class2' } 渲染结果 &lt;div class=&quot;class1&quot; :class=&quot;mystyle&quot;&gt; &lt;/div&gt; /////////////// data:{ mystyle:'class2' } 对象值为数组: &lt;div class=&quot;class1&quot; :class=&quot;mystyle&quot;&gt; &lt;/div&gt; /////////////// data:{ mystyle:['class2','class3'] } 渲染结果 &lt;div class=&quot;class1 class2 class3&quot;&gt; &lt;/div&gt; 在对象中为 v-bind:class 设置一个对象 在对象中为 v-bind:class 设置一个对象，从而动态的切换 class。v-bind:class=&quot;{'类名':布尔值/变量}&quot; style01为true则显示,false则隐藏 &lt;div class=&quot;class1&quot; :class=&quot;{'class3':trf1,'class4':trf2}&quot;&gt; &lt;/div&gt; //////////////// data:{ trf1:true, trf2:true } 渲染结果 &lt;div class=&quot;class1 class3 class4&quot;&gt; &lt;/div&gt; 在对象中为 v-bind:class 设置一个数组 数组中是字符串则绑定的是类名 &lt;div class=&quot;class1&quot; :class=&quot;['class2','class3','class4','class5']&quot;&gt; &lt;/div&gt; 渲染结果 &lt;div class=&quot;class2 class3 class4 class5&quot;&gt; &lt;/div&gt; 数组绑定的是变量则绑定的是data数据 &lt;div class=&quot;class1&quot; :class=&quot;[mystyle,mystyle2]&quot;&gt; &lt;/div&gt; /////////// data:{ mystyle:['class2','class3'], mystyle2:'class4' } 渲染结果 &lt;div class=&quot;class2 class3 class4&quot;&gt; &lt;/div&gt; style绑定 1.在 v-bind:style 直接设置样式： &lt;div class=&quot;class1&quot; :style=&quot;{width:'100vw',height:'75vh'}&quot;&gt; &lt;/div&gt; 2. 绑定一个对象 &lt;div class=&quot;class1&quot; :style=&quot;mystyle3&quot;&gt; &lt;/div&gt; //////////////////////////////////// data:{ mystyle3:'backgroundColor:red'//传入字符串 mystyle3:{//传入对象 backgroundColor:'red', margin:'auto' } } 3.绑定一个数组 &lt;div class=&quot;class1&quot; :style=&quot;[mystyle3,{height:'75vh'}]&quot;&gt; &lt;/div&gt; //////////////////////////////////// data:{ mystyle3:'backgroundColor:red' } 十二.条件渲染 1.v-show v-show 指令通过改变元素的 css 属性（display）来决定元素是显示还是隐藏。 用法： 在v-show中传一个表达式，结果为一个布尔值 //直接传一个布尔值 &lt;h1 v-show=&quot;false&quot;&gt; 好久不见 &lt;/h1&gt; //或者传一个变量 &lt;h1 v-show=&quot;textHs&quot;&gt; 好久不见 &lt;/h1&gt; //或者传一个表达式 &lt;h1 v-show=&quot;textHs1=='你好'&quot;&gt; 好久不见 &lt;/h1&gt; ///////////////////////////// data:{ textHs:false,//布尔值， textHs1:'你好' } 渲染结果 &lt;h1 style=&quot;dispaly:none&quot;&gt; 好久不见 &lt;/h1&gt; &lt;h1 style=&quot;dispaly:none&quot;&gt; 好久不见 &lt;/h1&gt; &lt;h1&gt; 好久不见 &lt;/h1&gt; 2.v-if v-if传一个表达式，结果为布尔值,true则显示节点，false则隐藏节点,当满足条件时会跳过if后的语句 用法 &lt;h2 v-if=&quot;a&quot;&gt; 苹果 &lt;/h2&gt; &lt;h2 v-else-if=&quot;b&quot;&gt; 香蕉 &lt;/h2&gt; &lt;h2 v-else&gt;西瓜&lt;/h2&gt; ////////////////////////////// data:{ a:true, b:true } 渲染结果 &lt;h2&gt; 苹果 &lt;/h2&gt; 使用template不破坏代码结构，template不会渲染成节点 &lt;template v-if=&quot;&quot;a&gt; &lt;h2&gt; 苹果 &lt;/h2&gt; &lt;h2&gt; 香蕉 &lt;/h2&gt; &lt;h2&gt;西瓜&lt;/h2&gt; &lt;!-- --&gt; &lt;/template&gt; ////////////////////////////// data:{ a:true, b:true } 渲染结果 &lt;h2&gt; 苹果 &lt;/h2&gt; &lt;h2&gt; 香蕉 &lt;/h2&gt; &lt;h2&gt;西瓜&lt;/h2&gt; v-if 和 v-show的区别 如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 v-if:如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-show:管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换(display)。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 1.v-show --&gt; &lt;!-- 1.1 传一个布尔值 --&gt; &lt;!-- &lt;h1 v-show=&quot;false&quot;&gt; 好久不见 &lt;/h1&gt; --&gt; &lt;!-- 1.2 传一个变量 --&gt; &lt;h1 v-show=&quot;textHs&quot;&gt; 好久不见 &lt;/h1&gt; &lt;!-- //或者传一个表达式 --&gt; &lt;h1 v-show=&quot;textHs1=='你好'&quot;&gt; 好久不见1 &lt;/h1&gt; &lt;!--2.v-if,v-if-else ，v-else v-if传一个表达式，结果为布尔值,true则显示节点，false则隐藏节点,当满足条件时会跳过if后的语句 --&gt; &lt;h2 v-if=&quot;a&quot;&gt; 苹果 &lt;/h2&gt; &lt;h2 v-else-if=&quot;b&quot;&gt; 香蕉 &lt;/h2&gt; &lt;h2 v-else&gt;西瓜&lt;/h2&gt; &lt;hr&gt; &lt;!-- 使用template不破坏代码结构，template不会渲染成节点 --&gt; &lt;template v-if=&quot;&quot;a&gt; &lt;h2&gt; 苹果 &lt;/h2&gt; &lt;h2&gt; 香蕉 &lt;/h2&gt; &lt;h2&gt;西瓜&lt;/h2&gt; &lt;!-- --&gt; &lt;/template&gt; &lt;/div&gt; &lt;script&gt; Vue.config.productionTip=false var vm=new Vue({ el:'#app', data:{ textHs:false,//布尔值， textHs1:'你好', a:true, b:true } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 十三.遍历列表 语法 写法1. v-for=&quot;值 in 遍历对象&quot; &lt;li v-for=&quot;value in students&quot; :key=&quot;value.id&quot;&gt; {{value.name}} &lt;/li&gt; 写法2. v-for=&quot;(值，索引) in 遍历对象&quot; &lt;li v-for=&quot;(value,index) in students&quot; :key=&quot;value.id&quot;&gt; {{value.name}} &lt;/li&gt; 使用v-for循环后面要加上:key,为每个dom节点添加标识，key的值可以为（index）索引或者id。为了dom的唯一性，key的值最好使用id这种具有唯一性的值 使用 1.遍历数组（常用） &lt;h1&gt;学生列表&lt;/h1&gt; &lt;ul&gt; &lt;li v-for=&quot;(value,index) in students&quot; :key=&quot;value.id&quot;&gt; {{value.name}}:{{value.age}} &lt;/li&gt; &lt;/ul&gt; data: { students: [{ id: 01, name: '小明', age: 14 }, { id: 02, name: '小华', age: 15 }, { id: 03, name: '小芳', age: 16 }] } 渲染结果 &lt;h1&gt;学生列表&lt;/h1&gt; &lt;ul&gt; &lt;li&gt; 小明:14 &lt;/li&gt; &lt;li&gt; 小华:15 &lt;/li&gt; &lt;li&gt; 小芳:16 &lt;/li&gt; &lt;/ul&gt; 2.遍历对象 &lt;h1&gt;汽车信息&lt;/h1&gt; &lt;ul&gt; &lt;li v-for=&quot;(value,index) in car&quot; :key=&quot;index&quot;&gt; {{index}}-{{value}} &lt;/li&gt; &lt;/ul&gt; &lt;!-----------------------&gt; data: { car:{ name:'奔驰', year:'2032' } } 渲染结果 &lt;h1&gt;汽车信息&lt;/h1&gt; &lt;ul&gt; &lt;li&gt; name-奔驰 &lt;/li&gt; &lt;li&gt; year-2032 &lt;/li&gt; &lt;/ul&gt; 3.遍历字符串(不常用) &lt;ul&gt; &lt;li v-for=&quot;value,index in strings&quot; :key=&quot;index&quot;&gt; {{index}}.{{value}} &lt;/li&gt; &lt;/ul&gt; &lt;!------------------------------&gt; data: { strings:&quot;aabbcc&quot; } 渲染结果 &lt;ul&gt; &lt;li&gt; 0.a &lt;/li&gt; &lt;li&gt; 1.a &lt;/li&gt; &lt;li&gt; 2.b &lt;/li&gt; &lt;li&gt; 3.b &lt;/li&gt; &lt;li&gt; 4.c &lt;/li&gt; &lt;li&gt; 5.c &lt;/li&gt; &lt;/ul&gt; 4.遍历数值 &lt;ul&gt; &lt;li v-for=&quot;(value,index) in numbers&quot; :key=&quot;index&quot;&gt; {{value}} &lt;/li&gt; &lt;/ul&gt; 渲染结果 &lt;ul&gt; &lt;li&gt; 1 &lt;/li&gt; &lt;li&gt; 2 &lt;/li&gt; &lt;li&gt; 3 &lt;/li&gt; &lt;li&gt; 4 &lt;/li&gt; &lt;/ul&gt; 十四. 透传 透传 Attributes实现父子传值 1.理解： “透传 attribute”指的是传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或者 v-on 事件监听器。最常见的例子就是 class、style 和 id。组件可以用$attrs接收到透传的值。 2. 代码 2-1.父组件 &lt;template&gt; &lt;view class=&quot;content&quot;&gt; &lt;test-cns2 class=&quot;avtive&quot; :msg=&quot;msg&quot;&gt;&lt;/test-cns2&gt; //声明msg &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { msg:1 } } } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 2-2.子组件 //子组件并未声明props接收，可以使用$attrs接收 &lt;template&gt; &lt;div class=&quot;test-cns&quot;&gt; {{$attrs.msg}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default{ watch:{ '$attrs.msg'(newV){ console.log(newV) //监听$attrs变化 } } } &lt;/script&gt; ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"}],"title":"vue基础入门","feature":"","link":"https://qin_hu.gitee.io/blog/post/vue-ji-chu-ru-men/","stats":{"text":"25 min read","time":1467000,"words":5213,"minutes":25},"date":"2023-12-25 14:24:53","dateFormat":"2023-12-25"},{"content":"1. 初识 Web Component 是一套不同的技术，允许你创建可重用的定制元素（它们的功能封装在你的代码之外）并且在你的 web 应用中使用它们。 解决痛点：在前端插件库中创建的组件不能通用，web components 允许我们封装自己想要的组件，达到组件在任何web应用中都可以通用的目的。 三项技术组成 Custom element（自定义元素）：一组 JavaScript API，允许你定义 custom elements 及其行为，然后可以在你的用户界面中按照需要使用它们。 Shadow DOM（影子 DOM）：一组 JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，你可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。 HTML template（HTML 模板）： &lt;template&gt; 和 &lt;slot&gt; 元素使你可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。 2. 创建一个web components流程 示例：创建一个按钮组件，这个按钮有不同的风格体现。 1. 准备 创建好项目目录，在目录下新建一个co-button文件夹，文件夹新建index.html文件，main.js文件 2. 创建html template模版 index.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;oc-button&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;template id=&quot;oc-button&quot;&gt; &lt;style&gt; :host{ --van-primary-color: #A0E9FF; --van-danger-color: #FFBFBF; --van-default-color: #fff; --van-success-color: #A8DF8E; --van-warning-color: #FFD3B0; } button { border: unset; cursor: pointer; padding: 5px; border-radius: 5px; font-size: 12px; } button.primary-button { background-color: var(--van-primary-color); color: #fff; } button.danger-button { background-color: var(--van-danger-color); color: #fff; } button.default-button { background-color: var(--van-default-color); color: #222; border: .5px solid #dddddd6f; } button.success-button { background-color: var(--van-success-color); color: #fff; } button.warning-button { background-color: var(--van-warning-color); color: #fff; } &lt;/style&gt; &lt;div class=&quot;oc-button&quot;&gt; &lt;button class=&quot;primary-button&quot;&gt;primary&lt;/button&gt; &lt;button class=&quot;danger-button&quot;&gt;danger&lt;/button&gt; &lt;button class=&quot;default-button&quot;&gt;default&lt;/button&gt; &lt;button class=&quot;success-button&quot;&gt;success&lt;/button&gt; &lt;button class=&quot;warning-button&quot;&gt;warning&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; // 这里使用创建的模版组件 &lt;oc-button&gt;&lt;/oc-button&gt; &lt;/body&gt; &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt; &lt;/html&gt; 3. 注册这个组件 class OcButton extends HTMLElement { ocButtonDom; constructor() { super(); this.ocButtonDom=document.querySelector('#oc-button') // 与外部dom节点隔离 this._shadowRoot=this.attachShadow({mode:'open'}) // 得到模版 const template=this.ocButtonDom?.content // 节点克隆 this._shadowRoot.appendChild(template.cloneNode(true)) } } // 注册组件 window.customElements.define('oc-button',OcButton) 4. 定义样式 注意：样式在&lt;template&gt;&lt;/template&gt;节点中定义，访问自身节点时,使用:host伪类访问。 &lt;template id=&quot;oc-button&quot;&gt; &lt;style&gt; :host{ --van-primary-color: #A0E9FF; --van-danger-color: #FFBFBF; --van-default-color: #fff; --van-success-color: #A8DF8E; --van-warning-color: #FFD3B0; } button { border: unset; cursor: pointer; padding: 5px; border-radius: 5px; font-size: 12px; } button.primary-button { background-color: var(--van-primary-color); color: #fff; } button.danger-button { background-color: var(--van-danger-color); color: #fff; } button.default-button { background-color: var(--van-default-color); color: #222; border: .5px solid #dddddd6f; } button.success-button { background-color: var(--van-success-color); color: #fff; } button.warning-button { background-color: var(--van-warning-color); color: #fff; } &lt;/style&gt; &lt;div class=&quot;oc-button&quot;&gt; &lt;button class=&quot;primary-button&quot;&gt;primary&lt;/button&gt; &lt;button class=&quot;danger-button&quot;&gt;danger&lt;/button&gt; &lt;button class=&quot;default-button&quot;&gt;default&lt;/button&gt; &lt;button class=&quot;success-button&quot;&gt;success&lt;/button&gt; &lt;button class=&quot;warning-button&quot;&gt;warning&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; 5. 添加属性（自定义props） 思路：使用getAttribute获取节点属性，在connectedCallback生命周期中接收属性进行创建dom操作。创建好的dom节点插入shadowRoot中。 main.js class OcButton extends HTMLElement { ocButtonDom; constructor() { super(); this.ocButtonDom = document.querySelector('#oc-button') // 与外部dom节点隔离 this._shadowRoot = this.attachShadow({ mode: 'open' }) // 得到模版 const template = this.ocButtonDom?.content // 节点克隆 this._shadowRoot.appendChild(template.cloneNode(true)) } // 监听得到的值 get observedAttributes() { return ['type'] } get type() { return this.getAttribute('type') } get text() { return this.getAttribute('text') } get color() { return this.getAttribute('color') } get width() { return this.getAttribute('width') } get height() { return this.getAttribute('height') } render() { console.log('我来更新dom了') } /** * 根据type 动态显示按钮、显示按钮的类型。 * 根据text 动态显示文字 * 根据color 动态显示颜色 * 根据width 动态显示宽 * 根据height 动态显示高 */ setAttributeCallback() { const button = document.createElement('button') button.className+=`${this.type||'default'}-button` button.setAttribute('type',this.type||'default') button.innerText=this.text||(this.type||'default') button.style.backgroundColor=this.color||`var(--van-${this.type||'default'}-color)` button.style.width=this.width||`auto` button.style.height=this.height||`auto` this._shadowRoot.querySelector('.co-button')?.appendChild(button) } /** * 生命周期 */ connectedCallback() { console.log(this.type) this.setAttributeCallback() console.log('当自定义元素第一次被连接到文档DOM时被调用') } disconnectedCallback() { console.log('当自定义元素与文档DOM断开连接时被调用') } adoptedCallback() { console.log('当自定义元素被移动到新文档时被调用') } attributeChangedCallback(key, oldVal, newVal) { console.log('当自定义元素的一个属性被增加、移除或更改时被调用') console.log(key, oldVal, newVal) this.render() } } // 注册组件 window.customElements.define('oc-button', OcButton) 6. 自定义事件传递 在自定义的组件中使用new CustomEvent对象创建自定义事件，使用dispatchEvent方法分发事件。在使用组件的地方监听调用分发的事件。 main.js /** * 监听按钮点击的事件 */ listenClickCallback(){ this._shadowRoot.querySelector('.co-button')?.querySelector('button')?.addEventListener('click',(e)=&gt;{ console.log(e) const event = new CustomEvent('myCustomEvent', { detail: { /* 事件的详细信息 */ } }); this.dispatchEvent(event); }) } index.html调用事件 &lt;oc-button type=&quot;danger&quot; text=&quot;成功&quot;&gt;&lt;/oc-button&gt; &lt;script&gt; const ocButtonDom = document.querySelector('oc-button') ocButtonDom.addEventListener('myCustomEvent', (event) =&gt; { // 处理自定义事件 console.log('my Customevent',event) }); &lt;/script&gt; 7. 生命周期 connectedCallback：当 custom element首次被插入文档DOM时，被调用。 disconnectedCallback：当 custom element从文档DOM中删除时，被调用。 adoptedCallback：当 custom element被移动到新的文档时，被调用。 attributeChangedCallback: 当 custom element增加、删除、修改自身属性时，被调用。 class HelloComponent extends HTMLElement { // 构造函数 constructor() { super(); } connectedCallback() { console.log('当自定义元素第一次被连接到文档DOM时被调用') } disconnectedCallback() { console.log('当自定义元素与文档DOM断开连接时被调用') } adoptedCallback() { console.log('当自定义元素被移动到新文档时被调用') } attributeChangedCallback() { console.log('当自定义元素的一个属性被增加、移除或更改时被调用') } } 8. 使用slot自定义内容 使用&lt;slot&gt;&lt;/slot&gt;设置默认的插槽，使用&lt;slot name='text'&gt;&lt;/slot&gt; 设置命名的插槽 默认插槽 &lt;template id=&quot;oc-button&quot;&gt; ... &lt;div class=&quot;co-button&quot;&gt; &lt;button&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/button&gt; &lt;/div&gt; &lt;/template&gt; // 调用组件 &lt;oc-button type=&quot;default&quot;&gt; &lt;span&gt; 这个是默认的按钮 &lt;/span&gt; &lt;/oc-button&gt; 命名插槽 &lt;template id=&quot;oc-button&quot;&gt; ... &lt;div class=&quot;co-button&quot;&gt; &lt;button&gt; &lt;slot name='text'&gt;&lt;/slot&gt; &lt;/button&gt; &lt;/div&gt; &lt;/template&gt; // 调用组件 &lt;oc-button type=&quot;default&quot;&gt; &lt;span slot='text'&gt; 这个是默认的按钮 &lt;/span&gt; &lt;/oc-button&gt; 9. 最后一步：将组件通过template创建，供其他页面使用。 ","tags":[{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"},{"index":-1,"name":"Html&Css","slug":"18jtBTPqK","used":true,"link":"https://qin_hu.gitee.io/blog/tag/18jtBTPqK/"}],"title":"Web Component","feature":"","link":"https://qin_hu.gitee.io/blog/post/web-component/","stats":{"text":"9 min read","time":525000,"words":1816,"minutes":9},"date":"2023-12-25 13:05:15","dateFormat":"2023-12-25"},{"content":"数据操作 1. 使用迭代器，循环调用接口后执行逻辑 for await…of 语句创建一个循环，该循环遍历异步可迭代对象以及同步可迭代对象，包括：内置的 String, Array，类似数组对象 (例如 arguments 或 NodeList)，TypedArray, Map, Set 和用户定义的异步/同步迭代器。它使用对象的每个不同属性的值调用要执行的语句来调用自定义迭代钩子。 类似于 await 运算符一样，该语句只能在一个async function 内部使用。 /** * @desc 获取用户信息 */ async getUserInfo(list) { return new Promise(async (res, rej) =&gt; { let arr = deepClone(list) for await (let item of arr) { let res=await queryCacheInfo({ account: item.account }) item.avatarUrl = res.data.avatarUrl item.charmLevel = res.data.charmLevel item.wealthLevel = res.data.wealthLevel item.nickname = res.data.nickname item.age = res.data.age item.gender = res.data.gender item.goodNumber = res.data.goodNumber item.userType = res.data.userType } res(arr) }) } Dom操作 1. 禁止用户打开控制台 禁止用户输入f12和右击鼠标 使用devtools-detector插件监听用户是否打开控制台，如果打开控制台浏览器执行debug。 // 引入插件 import { addListener, launch } from 'devtools-detector'; /** * @desc 监听控制台是否打开 */ function watchDebug(){ // 禁止右键 document.addEventListener('contextmenu', (e) =&gt; { e.preventDefault(); }) // 禁止f12 document.addEventListener('keydown', (e) =&gt; { if (e.code === 'F12' || e.ctrlKey &amp;&amp; e.shiftKey &amp;&amp; e.code === 'KeyI' || e.shiftKey &amp;&amp; e.code === 'F10') { console.log('f12') e.preventDefault(); } if (e.ctrlKey &amp;&amp; e.keyCode == 85) { e.preventDefault(); } }) // 检测控制台是否被打开 const timer = ref(null) function openDebugger() { if (timer.value) { timer.value = null clearInterval(timer.value) } timer.value = setInterval(() =&gt; { debugger; }, 50); } function closeDebugger() { timer.value = null clearInterval(timer.value) } addListener( isOpen =&gt; (isOpen ? openDebugger() : closeDebugger) ) launch(); } 2. input输入停止后执行事件 &lt;body&gt; &lt;input onchange=&quot;inputChange(event)&quot; class=&quot;input&quot; type=&quot;text&quot;&gt; &lt;/body&gt; &lt;script&gt; const inputDom=document.querySelector('input') let timer=null function inputChange(event){ clearTimeout(timer) timer=setTimeout(()=&gt;{ console.log(event.target.value) },1000) } &lt;/script&gt; ","tags":[{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"}],"title":"es6常用技巧","feature":"","link":"https://qin_hu.gitee.io/blog/post/es6-chang-yong-ji-qiao/","stats":{"text":"3 min read","time":133000,"words":458,"minutes":3},"date":"2023-12-25 12:00:30","dateFormat":"2023-12-25"},{"content":"1. 理解 TypeScript是JavaScript的超集，具有可选的类型并可以编译为纯JavaScript。 从技术上讲TypeScript就是具有静态类型的JavaScript 。 2. 安装环境 1. 安装node 在node官网下载包 通过node -v命令查看是否安装成功， 2. 下载typescript npm i typescript -g tsc --version 如果是Mac上面使用sudo npm install typescript -g指令进行安装 3. 编写helloworld程序 创建一个项目目录，并使用npm init初始化 初始化Typescript配置文件，在终端输入tsc --init生成tsconfig.json文件 安装@types/node,使用npm install @types/node --dev-save进行安装。这个主要是解决模块的声明文件问题。 编写HelloWorld.ts文件，并通过vscode运行任务项 var a:string=&quot;hellowrold&quot; console.log(a) 在终端使用tsc HelloWorld.ts命令运行HelloWorld.ts文件， 这时候就会生成一个helloWorld.js文件 在终端中输入node helloWorld.js就可以看到结果了。 3. 变量类型 列举一下ts的类型： Undefined : 未赋值类型 Number:数值类型; string : 字符串类型; Boolean: 布尔类型； enum：枚举类型； any : 任意类型，一个牛X的类型； void：空类型；//函数无返回值时 Array : 数组类型; Tuple : 元祖类型； Null ：空类型。 //@ undefined let a1:string; //声明变量未赋值 //@ number let a2:number=12 let a3:number=12.23 console.log(a2,a3) //12,12.23 let a4:number=a2-a3 console.log(a4) //-0.23000000000000043 精度 let a5:number=Infinity let a6:number=-Infinity console.log(a5,a6) //正无穷Infinity 负无穷-Infinity let a7:number=NaN; console.log(a7) //NaN 非数值 //@ string let s1:string=&quot;123&quot; let s2:string='TTT' console.log(s1,s2)//123 TTT //@ boolean let b1:boolean=true let b2:boolean=false console.log(b1,b2)//true false //@ enum enum Name1{ xiaoming, xiaohei, xiaohong } console.log(Name1.xiaohei,Name1.xiaohong) //没有值返回索引 enum Name2{ xiaoming=12, xiaohei=15, xiaohong=17 } console.log(Name2.xiaoming,Name2.xiaohong)//有值返回值 //@ any 当不知道结果值类型时 let n1:any=1 console.log(n1) //1 n1=&quot;to string&quot; console.log(n1) //to string 4. 函数 函数功能：把功能相近的需求封装成一个独立的代码块，每次传入不同的变量或参数，就可以实现不同的结果。 1. 函数的表达方式 定义函数注意点： 声明（定义）函数必须加 function 关键字； 函数名与变量名一样，命名规则按照标识符规则； 函数参数可有可无，多个参数之间用逗号隔开； 每个参数参数由名字与类型组成，之间用逗号隔开； 函数的返回值可有可无，没有时，返回类型为 void； 大括号中是函数体。 1. 函数声明式 function addNum(num:number):number{ //加1方法 return ++num } console.log(addNum(1))//2 function addCount(num1:number,num2:number):number{ return num1+num2 } console.log(addCount(1,3))//4 2. 函数表达式 const getAge=function(age:number):string{ return `你今天${age}岁了！` } 3. 箭头函数 const getAge=(age:number):string=&gt;{ return `你今天${age}岁了！` } console.log(getAge(17)) //你今天17岁了！ 2. 形参和实参 函数定义时写的参数是形参。在这里规范参数传参类型 调用函数时传入的参数称为实参。实参类型对应形参的类型。 3. typescript中的参数 1. 可选参数 使用?符合定义可选参数，没有传参时可选参是undefined const getContent = (id: number, keyworld?: string): string =&gt; { switch (id) { case 1: return `xiaoming search ${keyworld}` break; case 2: return &quot;xiaohong&quot; + ` search ${keyworld}` break; case 3: return &quot;xiaobai&quot; + ` search ${keyworld}` break; default: return &quot;no content&quot; break; } } console.log(getContent(2)) //xiaoming search undefined console.log(getContent(2, 'nihao')) //xiaoming search nihao 2. 默认参 形参中直接赋值默认值，不传递参数时参数是默认值 const add = (n1: number, n2: number = 3): number =&gt; { return n1 + n2 } console.log(add(4)) //7 3. 剩余参 有多个参数时使用数组接收 const getValue=(val1:string,val2:string,...moreVal:string[]):string=&gt;{ moreVal.forEach(item=&gt;{ console.log(item) //打印多余参数值//3,4 }) return `${val1},${val2},${ moreVal }` } console.log(getValue('1','2','3','4')) //1,2,3,4 4. 函数作用域 理解： 每个变量都有一个起作用的范围，这个范围就是变量的作用域。在TypeScript语言中变量作用域划分是以函数为标准的。 全局变量和局部变量： 局部变量：函数体内定义的变量就是局部变量。 全局变量: 函数体外 定义的变量就是全局变量。 var a:number=2 //全局变量 const testFun=()=&gt;{ var b:number=1//局部变量 return b } console.log(testFun()) //1 变量提升： 当局部变量与全局变量重名时，局部变量会生效；在没有声明变量之前使用变量会出现变量提升 const testFun=()=&gt;{ console.log(b) //undefined var b:number=1 return b } 变量提升后的代码： const testFun=()=&gt;{ var b:number; console.log(b) //undefined b=1 return b } 在局部作用域中使用let关键字 let关键字不存在变量提升，在没有声明变量之前使用变量会报错。 const testFun=()=&gt;{ let b:number=1 return b } 5. 引用类型 ts中的引用类型：Array（数组）、String（字符串）、Date（日期对象）、RegExp（正则表达式） 1. 数组 1. 定义数组 声明一个数组的两种方法： let arr1:number[ ] //声明一个数值类型的数组 let arr2:Array&lt;string&gt; //声明一个字符串类型的数组 变量赋值的两种方式 字面量赋值法： let arr:number[]=[1,2,3] //number类型数组 console.log(arr)//[1,2,3] let arr1:Array&lt;string&gt;=['1']//string类型数组 console.log(arr1)//['1'] 构造函数赋值 let arr2:Array&lt;string&gt;=new Array('1','2','3') console.log(arr2)//['1','2','3'] 2. 特殊的数组--元组：可以指定类型 let arr3:[number,string]=[2,'12'] console.log(arr3)//[2,'12'] 2. 引用类型字符串 ts中的两种字符串类型： 基本类型字符串：由单引号或者双引号括起来的一串字符串。 let ss1:string='12321'//基本类型字符串 console.log(ss1,ss1.length) //12321 5 引用类型字符串：用new 实例化的 String类型。 let ss2:String=new String(&quot;123213213&quot;) //使用new String console.log(ss2,ss1.length) //[String: '123213213'] 5 两者创建的字符串没什么区别 3. 日期对象 创建日期对象 let d:Date = new Date() 传递一个整数 let d:Date = new Date(1000) let da:Date = new Date(2000) console.log(d) //1970-01-01T00:00:01.000Z console.log(da) //1970-01-01T00:00:02.000Z 传递一个表示日期的字符串 字符串的格式常用:yyyy/MM/dd hh:mm:ss，yyyy-MM-dd hh:mm:ss，yyyy-MM-ddThh:mm:ss let d1:Date = new Date('2018/09/06 05:30:00') let d2:Date = new Date('2018-09-06 05:30:00') let d3:Date = new Date('2018-09-06T05:30:00') 传递表示年月日分秒的变量 let d:Date = new Date(year,month,day,hours,minutes,seconds,ms); 4. 正则类型 用于字段验证 字面量法 let reg1:RegExp = /test/ let reg2:RegExp = /test/gi 构造函数创建 let reg1:RegExp = new RegExp(&quot;test&quot;) let reg2:RegExp = new RegExp(&quot;test&quot;,&quot;gi&quot;)//参数1：字符串函数，参数2：修饰符 6. 面向对象编程-类 1. 理解类 类是对象具体事务的一个抽象，对象是类的具体表现。 类中有属性，构造函数，方法三个部分；构造函数用来给类中封装的属性赋值。 2. 定义一个类 假设对象是外国人‘Apple’，我要介绍他的中文名称和年龄，并且让他进行自我介绍 class Apple { //属性 chinaName: string; age: number; //构造函数 constructor(chinaName: string, age: number) { this.chinaName = chinaName this.age = age } //方法 getMyCity(){ console.log(`我来自非洲,今年${this.age}岁!`) } } const xa:Apple=new Apple('xiaoie',14)//实例化，构造对象 console.log(xa.getMyCity())//我来自非洲,今年14岁! console.log(xa)//Apple { chinaName: 'xiaoie', age: 14 } 7. 面向对象编程-修饰符 1.访问修饰符 private:私有修饰符，只可以在类内使用private修饰的属性和行为。es6中使用#声明私有修饰符 public:公有修饰符，可以在类内或者类外使用public修饰的属性或者行为，默认修饰符。 protected::受保护的修饰符，可以本类和子类中使用protected修饰的属性和行为。 class Student { public name: string; //公共成员属性 protected age: number; //当前类或者子类使用 private achievement: number; //私有成员属性 constructor(name: string, age: number, achievement: number) { this.name = name; this.age = age; this.achievement = achievement; } sayBey() { console.log(`beybey`); } seeAchievement() { console.log(`我的成绩是${this.achievement}`); } } let self: Student = new Student(&quot;小明&quot;, 18, 90); console.log(self.sayBey()); console.log(self.seeAchievement()); // console.log(self.achievement); //报错 // console.log(self.age); //报错 console.log(self.name);//小明 2.只读属性修饰符 readonly:只读，在class类中用来防止除构造函数之外的属性进行赋值 class Man { public readonly sex: string = &quot;男&quot;; //设置只读 } let p: Man = new Man(); console.log(p); //Man {sex: &quot;男&quot;, constructor: Object} // p.sex = &quot;324&quot;; //报错提示 3. 静态属性修饰符 使用static关键字声明静态属性。 凡是被static修饰的属性和方法都是静态方法和属性,只能被类名调用,不能被实例化对象调用.同时也不能被子类继承,换句话说它属于当前这个类的. 类中的this不能访问到static声明的静态属性 子类没有继承父类的静态属性。 export class Student { static msg: string = &quot;我是小学生&quot;; //静态属性 public name: string; //公共成员属性 protected age: number; //当前类或者子类使用 private achievement: number; //私有成员属性 constructor(name: string, age: number, achievement: number) { this.name = name; this.age = age; this.achievement = achievement; } } let self: Student = new Student(&quot;小明&quot;, 18, 90); // console.log(self.msg) //引用报错，静态属性不能被实例化对象调用 console.log(Student.msg); //我是小学生 只能通过类名访问 8.面向对象编程-继承和重写 继承 允许我们创建一个类（子类），从已有的类（父类）上继承所有的属性和方法，子类可以新建父类中没有的属性和方法。实用extends关键字。 export class Television { public width: number; public height: number; protected price: number; public fun: string; public msg: string = &quot;我是电视&quot;; constructor(width: number, height: number, fun: string) { this.width = width; this.height = height; this.fun = fun; } characteristic() { console.log(&quot;优惠实用&quot;); } } export class Mobile extends Television { //继承了Television的属性和方法 public msg: string = &quot;我是手机&quot;; } let bbb: Mobile = new Mobile(100, 50, &quot;看视频&quot;); console.log(bbb);//Mobile {msg: &quot;我是手机&quot;, width: 100, height: 50, fun: &quot;看视频&quot;, constructor: Object…} 重写 重写就是在子类中重写父类的方法。 使用super继承父类属性或者方法，然后添加功能 export class Television { public width: number; public height: number; protected price: number; public fun: string; public msg: string = &quot;我是电视&quot;; constructor(width: number, height: number, fun: string) { this.width = width; this.height = height; this.fun = fun; } characteristic() { console.log(&quot;优惠实用&quot;); } } export class Mobile extends Television { //继承了Television的属性和方法 public msg: string = &quot;我是手机&quot;; characteristic() { super.characteristic(); //继承父类 console.log(&quot;拍照清晰&quot;); //添加功能 } } let aaa: Television = new Television(100, 50, &quot;看视频&quot;); console.log(aaa.characteristic()); //优惠实用 let bbb: Mobile = new Mobile(100, 50, &quot;看视频&quot;); console.log(bbb.characteristic()); //优惠实用 拍照清晰 9. 接口 接口只定义对象的结构，而不考虑实际值 定义接口的关键字是interface。接口是用来定义一些规范，使用这些接口，就必须实现按照接口中的规范来走。 定义对象类型规范 interface Mobile { width: number; height: number; name: string; } //定义对象 let m: Mobile = { width: 120, height: 500, name: &quot;手机&quot; }; console.log(m); 定义函数类型规范 interface MobileType { (width: number, height: number, name: string): string; } let getMobile: MobileType = ( width: number, height: number, name: string ): string =&gt; { return `width:${width} height:${height} name:${name}`; }; 定义类的类型规范 类中要使用两个接口来规范类型，一个规范'构造函数属性'和'静态属性方法';一个规范类的‘方法’。 在类中使用implements关键字接收规范方法的接口 interface TypeConstructor { new (name: string, age: number); //检查构造函数 typename: string; //检查静态属性 logname(): string; //检查静态方法 } interface TypeInterface { loga(): string; } const Person1:TypeConstructor=class Person implements TypeInterface{ name:string; age:number; static typename:string=&quot;我的名字&quot; static logname(){ console.log(this.name) } constructor(name:string,age:number){ this.name=name this.age=age } loga(){ console.log(this.name,this.age) } } const p=new Person1('小明',20) 点击查看接口详细描述文章 10.命名空间 在命名空间中，有他自己的作用域，外部无法访问到，要想访问需使用export将访问的部分暴露出去 namespace moduleOne { export class Liu { name: string; age: number; constructor(name: string, age: number) { this.name = name; this.age = age; } } } namespace moduleTwo { export class Liu { name: string; age: number; constructor(name: string, age: number) { this.name = name; this.age = age; } } } let n1: moduleOne.Liu = new moduleOne.Liu(&quot;xm&quot;, 14); let n2: moduleTwo.Liu = new moduleOne.Liu(&quot;xh&quot;, 16); console.log(n2); console.log(n1.name, n1.age); //xm 14 console.log(n2.name, n2.age); //xm 16 11.泛型 泛型的语法是 &lt;&gt; 里写类型参数，一般可以用 T 来表示。主要解决输入输出类型要一致的问题。 //简单的泛型使用 function print&lt;T&gt;(arg: T): T { console.log(arg); return arg; } // print&lt;boolean&gt;(true);//定义要使用的类型 print(true); //TS 类型推断，自动推导出类型 学习参考链接 技术胖--https://jspang.com/article/38#top 掘金文章--2022年了，我才开始学 typescript ，晚吗？（7.5k字总结） https://juejin.cn/post/7124117404187099172#heading-1 https://juejin.cn/post/6844903799459414029#heading-0 --- 接口 https://juejin.cn/post/6903329234068963342#heading-0 --- static https://juejin.cn/post/7064351631072526350#heading-1 --- 泛型 文档 https://www.tslang.cn/docs/home.html ","tags":[{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"}],"title":"Typescript简述","feature":"","link":"https://qin_hu.gitee.io/blog/post/typescript/","stats":{"text":"15 min read","time":893000,"words":3332,"minutes":15},"date":"2023-12-22 17:01:14","dateFormat":"2023-12-22"},{"content":"使用Web3开发区块链管理工具，用于查看币走势。 web端接入metamask基本思路： 首先确定谷歌安装metamask插件 实现连接钱包，查询钱包详情，钱包签名转发币等功能。 metamask 密码：qq号 助记词：uniform elder barrel social wing level document south decide wait harbor cause web3 关于eip-712签名： 使用eip-712签名步骤： https://medium.com/metamask/eip712-is-coming-what-to-expect-and-how-to-use-it-bb92fd1a7a26 以太坊上的数字签名: https://learnblockchain.cn/article/1613#EIP%20712%EF%BC%9A%E5%9F%BA%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8C%96%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E5%93%88%E5%B8%8C%E5%92%8C%E7%AD%BE%E5%90%8D 常用方法： https://juejin.cn/post/7160922117591007263#heading-15 签名基本思路 i. 签名数据结构 let obj={ types: { //类型定义 EIP712Domain: [ // domain类型定义 { name: 'name', type: 'string' }, { name: 'version', type: 'string' }, { name: 'chainId', type: 'uint256' }, { name: 'verifyingContract', type: 'address' }, { name: 'salt', type: 'bytes32' } ], Transaction: [ // message类型定义 { name: 'to', type: 'address' }, { name: 'amount', type: 'uint256' }, { name: 'nonce', type: 'uint256' } ] }, domain: { //该应用的一些基本信息，称为域 name: 'MyCrypto', //DApp 或协议的名称,如“CryptoKitties” version: '1.0.0', //签名域”的当前版本。可以是你的 DApp 或平台的版本号。它阻止一个 DApp 版本的签名与其他 DApp 版本的签名一起工作。 chainId: 1,//链 id。防止一个网络(如测试网)的签名在另一个网络(如主网)上工作。通web3.version.network拿到 verifyingContract: '0x098D8b363933D742476DDd594c4A5a5F1a62326a', //将要验证签名的合约的以太坊地址。 salt: '0x76e22a8ee58573472b9d7b73c41ee29160bc2759195434c1bc1201ae4769afd7'//在合约和 DApp 中都硬编码的惟一的 32 字节值 }, primaryType: 'Transaction', //发送消息的类型定义，与types中的message类型属性对应 message: { to: '0x4bbeEB066eD09B7AEd07bF39EEe0460DFa261520', amount: 1000000, nonce: 0 } } ii. 变量 const data = JSON.stringify(obj); ii. 让eth_signTypedData_v3签名调用web3: web3.currentProvider.sendAsync( { method: &quot;eth_signTypedData_v3&quot;, params: [signer, data], from: signer }, function(err, result) { if (err) { return console.error(err); } const signature = result.result.substring(2); const r = &quot;0x&quot; + signature.substring(0, 64); const s = &quot;0x&quot; + signature.substring(64, 128); const v = parseInt(signature.substring(128, 130), 16); // The signature is now comprised of r, s, and v. } ); 官网示例签名步骤 html &lt;div&gt; &lt;h3&gt;Sign Typed Data V4&lt;/h3&gt; &lt;button type=&quot;button&quot; id=&quot;signTypedDataV4Button&quot;&gt;sign typed data v4&lt;/button&gt; &lt;/div&gt; js signTypedDataV4Button.addEventListener('click', async function (event) { event.preventDefault(); const msgParams = JSON.stringify({ domain: { // Defining the chain aka Rinkeby testnet or Ethereum Main Net chainId: 1, // Give a user friendly name to the specific contract you are signing for. name: 'Ether Mail', // If name isn't enough add verifying contract to make sure you are establishing contracts with the proper entity verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC', // Just let's you know the latest version. Definitely make sure the field name is correct. version: '1', }, // Defining the message signing data content. message: { /* - Anything you want. Just a JSON Blob that encodes the data you want to send - No required fields - This is DApp Specific - Be as explicit as possible when building out the message schema. */ contents: 'Hello, Bob!', attachedMoneyInEth: 4.2, from: { name: 'Cow', wallets: [ '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826', '0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF', ], }, to: [ { name: 'Bob', wallets: [ '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB', '0xB0BdaBea57B0BDABeA57b0bdABEA57b0BDabEa57', '0xB0B0b0b0b0b0B000000000000000000000000000', ], }, ], }, // Refers to the keys of the *types* object below. primaryType: 'Mail', types: { // TODO: Clarify if EIP712Domain refers to the domain the contract is hosted on EIP712Domain: [ { name: 'name', type: 'string' }, { name: 'version', type: 'string' }, { name: 'chainId', type: 'uint256' }, { name: 'verifyingContract', type: 'address' }, ], // Not an EIP712Domain definition Group: [ { name: 'name', type: 'string' }, { name: 'members', type: 'Person[]' }, ], // Refer to PrimaryType Mail: [ { name: 'from', type: 'Person' }, { name: 'to', type: 'Person[]' }, { name: 'contents', type: 'string' }, ], // Not an EIP712Domain definition Person: [ { name: 'name', type: 'string' }, { name: 'wallets', type: 'address[]' }, ], }, }); //钱包连接签名 // walletConnector // .signMessage(msgParams) // .then((result) =&gt; { // // Returns signature. // console.log(result) // }) // .catch(error =&gt; { // // Error returned when rejected // console.error(error); // }) var from = await web3.eth.getAccounts(); var params = [from[0], msgParams]; var method = 'eth_signTypedData_v4'; web3.currentProvider.sendAsync( { method, params, from: from[0], }, function (err, result) { if (err) return console.dir(err); if (result.error) { alert(result.error.message); } if (result.error) return console.error('ERROR', result); console.log('TYPED SIGNED:' + JSON.stringify(result.result)); const recovered = sigUtil.recoverTypedSignature_v4({ data: JSON.parse(msgParams), sig: result.result, }); if ( ethUtil.toChecksumAddress(recovered) === ethUtil.toChecksumAddress(from) ) { alert('Successfully recovered signer as ' + from); } else { alert( 'Failed to verify signer when comparing ' + result + ' to ' + from ); } } ); }); 使用web3model连接钱包 官网： https://docs.walletconnect.com/ html使用示例： https://github.com/WalletConnect/web3modal/blob/V2/examples/html/main.js 安装: npm install @web3modal/ethereum @web3modal/html @wagmi/core ethers npm install @walletconnect/types json-rpc-engine 可能有下方报错 文件查找失败：'json-rpc-engine/src/createScaffoldMiddleware' at node_modules\\eth-json-rpc-middleware\\scaffold.js:2 打开scaffold.js文件将json-rpc-engine/src/createScaffoldMiddleware修改为json-rpc-engine/dist/createScaffoldMiddleware html引用 &lt;script&gt; import { configureChains, createClient } from '@wagmi/core' import { goerli, mainnet } from '@wagmi/core/chains' import { EthereumClient, modalConnectors, walletConnectProvider } from '@web3modal/ethereum' import { Web3Modal } from '@web3modal/html' var web3Modal = null; export default { mounted() { this.initWeb3Modal() }, data() { return { title: 'Hello' } }, onLoad() { }, methods: { initWeb3Modal() { // 1. Define constants const projectId = '8e6b5ffdcbc9794bf9f4a1952578365b' const chains = [mainnet, goerli] // 2. Configure wagmi client const { provider } = configureChains(chains, [walletConnectProvider({ projectId })]) const wagmiClient = createClient({ autoConnect: true, connectors: modalConnectors({ appName: 'web3Modal', chains }), provider }) // 3. Create ethereum and modal clients const ethereumClient = new EthereumClient(wagmiClient, chains) web3Modal = new Web3Modal({ projectId }, ethereumClient) web3Modal.subscribeModal((newState) =&gt; //modal打开关闭回调 console.log(newState) ); web3Modal.subscribeSelectedChain((newState) =&gt; {//是否连接成功回调 console.log(&quot;连接成功&quot;,newState.address) }) }, openModal() { web3Modal.openModal() }, closeModal(){ web3modal.closeModal(); } } } &lt;/script&gt; 使用wagmi连接钱包 https://wagmi.sh/core/getting-started import { goerli, mainnet, optimism, polygon } from '@wagmi/core/chains' // test钱包连接 import { WalletConnectConnector } from '@wagmi/core/connectors/walletConnect' //使用wagmi连接钱包，版本连接钱包版本1 async testConnect() { const connector = new WalletConnectConnector({ // chains: [mainnet, optimism, polygon], options: { qrcode: true, version: '1', projectId: '8e6b5ffdcbc9794bf9f4a1952578365b', }, }) console.log('connector', connector) try { await connector.connect() console.log(res) } catch (e) { console.log(e) //TODO handle the exception } } 版本 旧版本 package.json { &quot;name&quot;: &quot;poject-demo2&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;@wagmi/core&quot;: &quot;^0.8.15&quot;, &quot;@walletconnect/types&quot;: &quot;^2.4.3&quot;, &quot;@web3modal/ethereum&quot;: &quot;^2.0.0&quot;, &quot;@web3modal/html&quot;: &quot;^2.0.0&quot;, &quot;ethers&quot;: &quot;^5.4.0&quot;, &quot;json-rpc-engine&quot;: &quot;^5.4.0&quot; } } 新版本 package.json { &quot;name&quot;: &quot;poject-demo2&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;@wagmi/core&quot;: &quot;^0.9.5&quot;, &quot;@walletconnect/types&quot;: &quot;^2.4.3&quot;, &quot;@web3modal/ethereum&quot;: &quot;^2.1.1&quot;, &quot;@web3modal/html&quot;: &quot;^2.1.1&quot;, &quot;eth-json-rpc-filters&quot;: &quot;^5.1.0&quot;, &quot;eth-json-rpc-middleware&quot;: &quot;^9.0.1&quot;, &quot;ethers&quot;: &quot;^5.7.2&quot; } } ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"},{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"}],"title":"Web3项目开发的一些经验","feature":"","link":"https://qin_hu.gitee.io/blog/post/web3-xiang-mu-kai-fa-de-yi-xie-jing-yan/","stats":{"text":"9 min read","time":489000,"words":1473,"minutes":9},"date":"2023-12-22 16:27:43","dateFormat":"2023-12-22"},{"content":"标准的时间流：先捕获再冒泡。触发dom事件之后，会先捕获到事件目标，捕获到事件源之后通过事件传播进行事件冒泡。 事件对象 当触发了一个事件，系统会给事件自动创建一个事件对象，即event。事件对象包含了事件一系列数据的集合。 event = event || windoe.event; 下面有三个重要的事件对象属性： e.target // 返回触发事件的对象 标准 e.preventDefaule() // 该方法阻止默认事件（默认行为）标准 ，比如不让链接跳转。当然也可以还有return false来直接阻止默认事件 e.stopPropagation() // 阻止冒泡，标准 事件委托（事件代理） 事件委托的原理是不给每个子节点单独设置事件监听器，而是设置在其父节点上，然后利用冒泡原理设置每个子节点。 使用场景：监听一个父级节点事件，触发事件后委派给子节点，通过子节点元素的类名判断做出响应的操作，此操作减少与dom的交互次数，提高了性能。 使用事件委托的案例 问题描述： markdown语法自动生成的a链接不会添加target属性，点击链接时不会从新窗口打开。 解决方案： 可以使用html标签的写法来定义markdown超链接 //原来 [访问](www.heerblog.top) //修改后 &lt;a href=&quot;www.heerblog.top&quot; target=&quot;_blank&quot;&gt;访问&lt;/a&gt; 这个方案书写比较麻烦。 使用事件委托代理 给body添加事件监听，点击时判断点击对象是否是a链接且host地址是否与自身地址相同，如果不相同使用window.open()方法打开新的窗口。 const eventDelegation = () =&gt; { document.body.addEventListener(&quot;click&quot;, function (event) { let target = event.target; if (target.nodeName.toLocaleLowerCase() !== &quot;a&quot;) { return; } if (event.target.host == window.location.host) { return; } event.preventDefault(); window.open(event.target.href); }); }; eventDelegation(); ","tags":[{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"}],"title":"事件流（事件捕获，事件冒泡，事件委托）","feature":"","link":"https://qin_hu.gitee.io/blog/post/shi-jian-liu-shi-jian-bu-huo-shi-jian-mou-pao-shi-jian-wei-tuo/","stats":{"text":"2 min read","time":112000,"words":494,"minutes":2},"date":"2023-12-21 17:02:34","dateFormat":"2023-12-21"},{"content":"思路 使用html2canvas插件，dom节点转Canvas再转化成Image。 实现 安装html2canvas 使用npm npm i html2Canvas // es6引入 import html2Canvas from 'html2canvas'; 使用Cdn &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/html2canvas/1.4.1/html2canvas.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/html2canvas/1.4.1/html2canvas.min.js&quot;&gt;&lt;/script&gt; // 使用 window.html2canvas 封装MyHtml2canvas工具类 MyHtml2canvas.ts class MyHtml2canvas { // 插件实例 html2canvas; constructor(html2canvas) { this.html2canvas = html2canvas } /** * @desc cavans转换为base64 */ generatePicture({ canvas, type = &quot;image/png&quot;, encoderOptions = 0.92 }) { return canvas.toDataURL(type, encoderOptions); } /** * @desc 获取Cavans */ getCanvas = (dom, backgroundColor = &quot;rgba(0,0,0,.1)&quot;) =&gt; { return this.html2canvas(dom, { scale: 2, allowTaint: false, //允许污染 useCORS: true, backgroundColor //'transparent' //背景色 }) } /** * @desc 获取图片文件 */ getPictureFile(dom, backgroundColor = &quot;rgba(0,0,0,.1)&quot;) { return new Promise(async (resolve, reject) =&gt; { try { let canvas = await this.getCanvas(dom) let maskImg = this.generatePicture({ canvas }) let file = this.base64ToFile(maskImg) resolve(file) } catch (error) { reject(error) } }) } /** * @desc 获取截图文件的地址 */ async getPictureUrl(dom) { let file = await this.getPictureFile(dom) let url = await this.fileToUrl(file) return url } /** * @desc base64转化为file文件 */ base64ToFile(base64Data) { const arr = base64Data.split(','); const mime = arr[0].match(/:(.*?);/)[1]; const bytes = atob(arr[1]); let n = bytes.length; const ia = new Uint8Array(n); while (n--) { ia[n] = bytes.charCodeAt(n); } return new File([ia], 'jpeg', { type: mime }); }; /** * @description file to url * @param file * @returns */ fileToUrl = async function (file) { let getBase64Res = await this.getBase64(file) let base64toBlobRes = this.base64toBlob(getBase64Res) let blobToUrlRes = this.blobToUrl(base64toBlobRes) return blobToUrlRes } /** * @description 1. file转base64 * @param file */ getBase64 = (file) =&gt; { return new Promise((resolve, reject) =&gt; { const reader = new FileReader() let fileResult = '' reader.readAsDataURL(file) // 开始转 reader.onload = () =&gt; { fileResult = reader.result } // 转 失败 reader.onerror = (error) =&gt; { reject(error) } // 转 结束 reader.onloadend = () =&gt; { // this.formJar.fileName = file.name resolve(fileResult) } }) } /** * @description base64转blob * @param base64Data * @param fileType * @returns */ base64toBlob = (base64Data, fileType = 'image/png') =&gt; { //console.log(base64Data);//data:image/png;base64, let data = base64Data.startsWith('data:') ? base64Data : `data:${fileType};base64,${base64Data}`; var byteString; if (data.split(',')[0].indexOf('base64') &gt;= 0) byteString = atob(data.split(',')[1]); //base64 解码 else { byteString = unescape(data.split(',')[1]); } var mimeString = data.split(',')[0].split(':')[1].split(';')[0]; //mime类型 -- image/png var ia = new Uint8Array(byteString.length); //创建视图 for (var i = 0; i &lt; byteString.length; i++) { ia[i] = byteString.charCodeAt(i); } var blob = new Blob([ia], { type: mimeString, }); return blob; }; /** * @desc blob转换为url * @param blob * @returns */ blobToUrl = (blob) =&gt; { return URL.createObjectURL(blob) } } 项目中使用 &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;script&gt; const myHtml2canvas = new MyHtml2canvas(html2canvas) const boxDom = document.querySelector('.box') let picFile = await myHtml2canvas.getPictureFile(boxDom) let url = await myHtml2canvas.getPictureUrl(boxDom) &lt;/script&gt; 也可以使用其他插件：domtoimage （将dom转svg再生成图片），使用webRtc实现截图功能。 以下是以webRtc实现截图的Demo。 webRtc实现截图 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=&quot;width: 100%; height: 100%; position: relative; top: 0; left: 0; z-index: 1; overflow-y: hidden;&quot;&gt; &lt;video id=&quot;video&quot; style=&quot;width: 1600; height: 900; position: absolute; top: 0; left: 0;&quot; autoplay&gt;&lt;/video&gt; &lt;/div&gt; &lt;div style=&quot;width: 100%; height: 100%; z-index: 2;&quot;&gt; &lt;button onclick=&quot;screenshoutBtnClick()&quot;&gt;截图&lt;/button&gt; &lt;img id=&quot;showScreenShout&quot; style=&quot;width:100%; height: 100%;&quot; /&gt; &lt;div id=&quot;needScreenShotArea&quot; style=&quot;width: 300px; height:150px;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; function init() { if (window.screen) { var video = document.getElementById('video'); video.style.width = window.screen.width + &quot;px&quot;; video.style.height = window.screen.height + &quot;px&quot;; } } init(); const displayMediaOptions = { video: { cursor: &quot;always&quot; }, audio: false }; let videoElem = document.getElementById(&quot;video&quot;); function screenshoutBtnClick() { var windowX = event.screenX - event.clientX; var windowY = event.screenY - event.clientY; navigator.mediaDevices.getDisplayMedia(displayMediaOptions).then(stream =&gt; { videoElem.srcObject = stream; setTimeout(() =&gt; { var canvas = document.createElement(&quot;canvas&quot;); canvas.width = videoElem.clientWidth; canvas.height = videoElem.clientHeight; var needScreenShotEl = document.getElementById('needScreenShotArea'); var pos = getPosition(needScreenShotEl); var toolBarHeight = window.outerHeight - window.innerHeight; canvas.getContext(&quot;2d&quot;).drawImage(videoElem, windowX + pos.left, windowY + (document.fullscreenElement ? pos.top : pos.top), needScreenShotEl.clientWidth, needScreenShotEl.clientHeight, 0, 0, canvas.width, canvas.height ); var dataURL = canvas.toDataURL(&quot;image/png&quot;); document.getElementById('showScreenShout').src = dataURL; let tracks = videoElem.srcObject.getTracks(); tracks.forEach(track =&gt; track.stop()); videoElem.srcObject = null; }, 200) }).finally(() =&gt; { }); } function getPosition(node) { //获取元素相对于其父元素的left值var left var left = node.offsetLeft; var top = node.offsetTop; // 取得元素的offsetParent current = node.offsetParent; // 一直循环直到根元素 while (current != null) { left += current.offsetLeft; top += current.offsetTop; current = current.offsetParent; } return { &quot;left&quot;: left, &quot;top&quot;: top }; } &lt;/script&gt; &lt;/html&gt; ","tags":[{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"}],"title":"截图功能","feature":"","link":"https://qin_hu.gitee.io/blog/post/jie-tu-gong-neng/","stats":{"text":"6 min read","time":323000,"words":937,"minutes":6},"date":"2023-12-21 15:43:33","dateFormat":"2023-12-21"},{"content":"什么是PWA应用 PWA使得一个web网页具备许多web应用程序的特点，PWA应用可以从平台的应用商店或者从浏览器安装，可以像应用程序一样安装且自定义安装过程。 一个基本的PWA应用必须注册Service worker，使PWA应用将请求的资源放在缓存中，在无网络时时PWA应用看起来更像一个应用程序。 还需要一个web应用程序清单，用来描述应用程序的信息，比如应用程序名称和图标。 创建一个基本的PWA应用 1. 配置sw.js /** * service worker */ var cacheName = ''; var apiCacheName = ''; var cacheFiles = [ '/', './index.html', ]; // 监听install事件 self.addEventListener('install', function (e) { // console.log('Service Worker 状态： install'); }); // 监听activate事件 self.addEventListener('activate', function (e) { // console.log('Service Worker 状态： activate'); }); self.addEventListener('fetch', function (e) { // 需要缓存的xhr请求 // console.log(&quot;fetch 事件&quot;) }); 2. web应用程序清单（manifest.webmanifest文件） 注意：icons文件大小必须一致,start_url为**/或者是指向index.html**目录 { &quot;background_color&quot;: &quot;#333&quot;, &quot;description&quot;: &quot;Zeroox&quot;, &quot;display&quot;: &quot;fullscreen&quot;, &quot;icons&quot;: [{ &quot;src&quot;: &quot;/static/icons/icon-192.png&quot;, &quot;sizes&quot;: &quot;192x192&quot;, &quot;type&quot;: &quot;image/png&quot; }, { &quot;src&quot;: &quot;/static/icons/icon-512.png&quot;, &quot;sizes&quot;: &quot;512x512&quot;, &quot;type&quot;: &quot;image/png&quot; } ], &quot;name&quot;: &quot;Zeroox&quot;, &quot;short_name&quot;: &quot;Zeroox&quot;, &quot;start_url&quot;: &quot;/&quot; //规定的app开始路径 } 3.在html文件中注册sw.js 3-1. 引入配置文件 &lt;link rel=stylesheet href=/static/index.b0707a6a.css&gt; &lt;link rel=manifest href=/static/json/manifest.webmanifest&gt; 3-2.注册sw.js 此处获取的dom是点击事件，通过事件达到添加主屏幕的效果 监听beforeinstallprompt事件，用于请求用户安装应用程序 &lt;script&gt; if (&quot;serviceWorker&quot; in navigator &amp;&amp; 'PushManager' in window) { window.addEventListener('load', () =&gt; { // 这个load 可以删除 如果你的浏览器没加载出来 可以添加一下这个 navigator.serviceWorker.register(&quot;sw.js&quot;, { scope: './' }).then(function (registration) { console.log('Service Worker Registered'); }); const showHomePopup = document.querySelector('.zeroox-home') if (showHomePopup !== null) { showHomePopup.style.display = 'none'; } window.addEventListener('beforeinstallprompt', (e) =&gt; { console.log(&quot;beforeinstallpromptdiaoyong&quot;) e.preventDefault(); deferredPrompt = e; showHomePopup.style.display = 'block'; const addHomeBtn = document.querySelector( '.zeroox-home .u-modal__button-group__wrapper--confirm') const cancelHomeBtn = document.querySelector( '.zeroox-home .u-modal__button-group__wrapper--cancel') addHomeBtn.addEventListener('click', () =&gt; { console.log('点击shengxiao') // Show the prompt deferredPrompt.prompt(); // Wait for the user to respond to the prompt deferredPrompt.userChoice.then((choiceResult) =&gt; { if (choiceResult.outcome === 'accepted') { showHomePopup.style.display = 'none'; console.log('User accepted the A2HS prompt'); //生效 } else { showHomePopup.style.display = 'none'; console.log('User dismissed the A2HS prompt'); //取消 } deferredPrompt = null; }); }); cancelHomeBtn.addEventListener('click', () =&gt; { showHomePopup.style.display = 'none'; }) }); }) } &lt;/script&gt; 4.通过浏览器添加到主屏幕的配置 &lt;!-- 安卓平台 chrome --&gt; &lt;meta name=&quot;mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; &lt;link rel=&quot;icon&quot; sizes=&quot;192x192&quot; href=&quot;/static/icons/icon.png&quot;&gt; &lt;!-- ios平台 safari --&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/static/icons/icon.png&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;Zeroox&quot;&gt; &lt;meta name=&quot;application-name&quot; content=&quot;Zeroox&quot;&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=yes&quot; /&gt; 打开浏览器控制台查看应用程序是否符合PWA应用规则。 ","tags":[],"title":"渐进式web应用（PWA）","feature":"","link":"https://qin_hu.gitee.io/blog/post/jian-jin-shi-web-ying-yong-pwa/","stats":{"text":"4 min read","time":239000,"words":792,"minutes":4},"date":"2023-12-21 14:57:50","dateFormat":"2023-12-21"},{"content":"web本地存储数据存储在浏览器的会话中，sessionStorage和localStorage都是以键值对的方式存储，且键值对都是以字符串的方式保存。sessionStorage在用户关闭浏览器时清除缓存,localStorage可以长期存储。使用indexedDB用于在客户端存储大量的结构化数据。 localStorage 基本使用 // 1.本地存储--保存 localStorage.setItem(name,v) function saveData() { //字符串 localStorage.setItem('msg', '你好') //数组 let a = [1, 2, 3, 4] localStorage.setItem('arr', a) //对象 JSON.stringify():对象转字符串 let b = { name: '小明', age: '20' } localStorage.setItem('msg2', JSON.stringify(b)) } // 2.本地存储---读取 localStorage.getItem('arr') function readData() { console.log(localStorage.getItem('arr')); console.log(localStorage.getItem('msg')); //读取对象 let result = localStorage.getItem('msg2') console.log(JSON.parse(result)); } //3.本地存储-- 删除 function removeData() { localStorage.removeItem('arr') } //4.本地存储-- 清空 function clearData() { localStorage.clear() } 扩展功能 创建过期的localStorage 思路 在添加Storage时保存当前时间戳并存储到缓存中 初始化时创建一个设置过期时间的变量和一个删除Storage的方法 方法中设置定时器计算&quot;当前时间戳&quot;与&quot;创建时间戳&quot;差值秒数，如果等于设置过期时间的秒数则删除Storage 初始化时调用方法 代码实现 //模拟添加Storage的方法 const addStorage = () =&gt; { localhost.setStorage(&quot;name&quot;, '小明') const nameTime = Date.now() localhost.setStorage(&quot;nameTime&quot;, nameTime) } addStorage() const initApp = () =&gt; { //方法 const checkSaeTimer = (st, t, key) =&gt; { //st 开始时间 // t 过期时间 //key ： Storage的key window.nameSaeTimer = setInterval( () =&gt; { if (Math.round((Date.now() - nameTime) / 1000) &gt; t) { localhost.removeStorage(key) clearStorage() } }, 1000) const clearStorage = () =&gt; { clearInterval(window.nameSaeTimer) window.nameSaeTimer = null } } //调用方法校验过期 let nameTime = localhost.getStorage(&quot;nameTime&quot;) let t = 1000000 //100秒 checkSaeTimer(nameTime, t, 'name') } sessionStorage // 1.会话存储--保存 sessionStorage.setItem(name,v) function saveData() { //字符串 sessionStorage.setItem('msg', '你好') //数组 let a = [1, 2, 3, 4] sessionStorage.setItem('arr', a) //对象 JSON.stringify():对象转字符串 let b = { name: '小明', age: '20' } sessionStorage.setItem('msg2', JSON.stringify(b)) } // 2.本地存储---读取 sessionStorage.getItem('arr') function readData() { console.log(sessionStorage.getItem('arr')); console.log(sessionStorage.getItem('msg')); //读取对象 let result = sessionStorage.getItem('msg2') console.log(JSON.parse(result)); } //3.本地存储-- 删除 function removeData() { sessionStorage.removeItem('arr') } //4.本地存储-- 清空 function clearData() { sessionStorage.clear() } indexedDB indexedDB通过key-value的方式存储，在 indexedDB 中，我们可以创建多个数据库，每个数据库有自己独立的空间。他是一个文件的即时存取数据库，indexedDB 内置了事务系统，所有读写操作都是在事务中完成。 使用的整体思路：在使用IndexedDB时，首先我们先尝试打开一个数据库（不存在则会自动创建），然后新建一个数据库表，并添加索引，通过这个索引对表数据进行操作。 下面我封装了一个IndexedDB使用的工具类，实现了IndexedDB从初始化到建表进行操作的基本功能。 class MyIndexedDB { // 数据库名称 dbName; // 数据库版本 version; // 数据库表集合 dbTableList; // 数据库实例 db; // 是否初始化时建表 isInitCreatTable; constructor({ dbName = 'MyIndexedDB', version = 1, dbTableList = [{ // 表名 name: 'db_table', // 主键 keyPath: 'id', // 是否自动生成主键 autoIncrement: false, // 新建索引key 新建索引时是否包含重复值 unique keyList: [{ key: 'id', unique: false }], }], isInitCreatTable = true }) { this.dbName = dbName this.version = version this.dbTableList = dbTableList this.isInitCreatTable = isInitCreatTable } /** * @desc 打开indexedDB数据库(新建数据库) */ initOpenIndexedDb() { return new Promise((res, rej) =&gt; { if (!this.checkIndexedDb()) { rej('您的浏览器不支持indexedDB数据库') return false } if (!this.db) { this.db = window.indexedDB.open(this.dbName, this.version); console.log(&quot;myIndexedDB init.&quot;) // db创建失败回调 this.db.addEventListener('error', (event) =&gt; { console.log('myIndexedDB error.') rej(false) }) // db创建成功回调 this.db.addEventListener('success', (event) =&gt; { // 获取新的db对象 this.db = event.target.result; console.log('myIndexedDB success.') }) // db版本更新回调 this.db.addEventListener('upgradeneeded', (event) =&gt; { // 获取新的db对象 this.db = event.target.result; // 初始化新建表 if (this.isInitCreatTable) { this.creatTable() } res(true) console.log('myIndexedDB upgradeneeded.') }) } }) } /** * @desc 新建表. * @param list 表描述 */ async creatTable(list = this.dbTableList) { // debugger for (let i = 0; i &lt; list.length; i++) { const element = list[i]; if (!this.db.objectStoreNames.contains(element.name)) { let objectStore = this.db.createObjectStore(element.name, { keyPath: element.keyPath, autoIncrement: element.autoIncrement }); // 新建索引 for await (const i of element.keyList) { objectStore.createIndex(i.key, i.key, { unique: i.unique }); } } } } /** * @desc 新增数据 * @param { dbTableList , mode,} 表格名称列表,指定操作模式 */ addTableData({ dbTableName = 'db_table', mode = 'readwrite', data }) { return new Promise((res, rej) =&gt; { let transaction = this.db.transaction([dbTableName], mode) let objectStore = transaction.objectStore(dbTableName) let request = objectStore.add(data) request.onsuccess = function (event) { console.log('数据写入成功'); res(true) }; request.onerror = function (event) { console.log('数据写入失败'); rej(false) } }) } /** * @desc 更新数据 */ updateTableData({ dbTableName = 'db_table', mode = 'readwrite', data }) { return new Promise((res, rej) =&gt; { let transaction = this.db.transaction([dbTableName], mode) let objectStore = transaction.objectStore(dbTableName) let request = objectStore.put(data) request.onsuccess = function (event) { console.log('数据更新成功'); res(true) }; request.onerror = function (event) { console.log('数据更新失败'); rej(false) } }) } /** * @desc 查询数据 */ queryTableData({ dbTableName = 'db_table', param }) { return new Promise((res, rej) =&gt; { let transaction = this.db.transaction([dbTableName], 'readonly') let objectStore = transaction.objectStore(dbTableName) let request = objectStore.get(param) request.onsuccess = function (event) { console.log('数据查询成功'); let obj = event.target.result res(obj) }; request.onerror = function (event) { console.log('数据查询失败'); rej(false) } }) } /** * @desc 删除数据 */ delTableData({ dbTableName = 'db_table', mode = 'readwrite', param }) { return new Promise((res, rej) =&gt; { let transaction = this.db.transaction([dbTableName], mode) let objectStore = transaction.objectStore(dbTableName) let request = objectStore.delete(param) request.onsuccess = function (event) { console.log('数据删除成功'); let obj = event.target.result res(obj) }; request.onerror = function (event) { console.log('数据删除失败'); rej(false) } }) } /** * @desc 遍历查询表格数据 */ queryTableAllData({ dbTableName = 'db_table', mode = 'readonly', }) { return new Promise((res, rej) =&gt; { // 创建一个事务 let transaction = this.db.transaction([dbTableName], mode) // 获取对象存储空间 let objectStore = transaction.objectStore(dbTableName) // 打开游标 let cursorRequest = objectStore.openCursor() // 游标遍历数据的回调函数 let data = [] cursorRequest.onsuccess = function (event) { var cursor = event.target.result; if (cursor) { var user = cursor.value; data.push(user) console.log('User:', user); cursor.continue(); } else { res(data) } }; cursorRequest.onerror = function (event) { console.log('数据查询失败'); rej(false) } }) } /** * @desc 检查浏览器是否支持IndexedDb */ checkIndexedDb() { return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB; } /** * @desc 关闭数据库 */ closeDb() { this.db.close() } } 在项目中使用 const myIndexedDB = new MyIndexedDB({ dbName: 'MyIndexedDB', version: 2, isInitCreatTable: false }) // 初始化数据库 await myIndexedDB.initOpenIndexedDb() // 建表 const dbList = [{ // 表名 name: 'db_table', // 主键 keyPath: 'id', // 是否自动生成主键 autoIncrement: false, // 新建索引key 新建索引时是否包含重复值 unique keyList: [{ key: 'id', unique: false }], }] await myIndexedDB.creatTable(dbList) 新建后我们可以在控制台查看数据库详情。 关于IndexedDB的使用可以参考这个链接: https://www.tangshuang.net/3735.html#title-1 应用的场景： 在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择： 标记用户与跟踪用户行为的情况，推荐使用cookie 适合长期保存在本地的数据（令牌），推荐使用localStorage 敏感账号一次性登录，推荐使用sessionStorage 存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB ","tags":[{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"}],"title":"本地存储","feature":"","link":"https://qin_hu.gitee.io/blog/post/ben-di-cun-chu/","stats":{"text":"8 min read","time":463000,"words":1666,"minutes":8},"date":"2023-12-20 16:22:47","dateFormat":"2023-12-20"},{"content":"Taro 是一个开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发 微信 / 京东 / 百度 / 支付宝 / 字节跳动 / QQ / 飞书 小程序 / H5 / RN 等应用。 安装和运行 // 安装脚手架 npm install -g @tarojs/cli // 创建项目 taro init myApp // 运行和打包H5 npm run dev:h5 npm run build:h5 参考官网链接 配置路径别名 找到项目根目录下的config/dev.ts文件，添加alias配置： import type { UserConfigExport } from &quot;@tarojs/cli&quot;; import path from 'path' export default { ... alias: { '@': path.resolve(__dirname, '..', 'src') }, ... } satisfies UserConfigExport 打包 npm run build 使用h5打包后，访问静态文件出现404的报错 config/dev.ts文件修改publicPath // H5 端专用配置 h5: { publicPath: './', staticDirectory: 'static', ... }, ","tags":[{"index":-1,"name":"uniapp&taro","slug":"aUWAN2tZz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/aUWAN2tZz/"}],"title":"Taro","feature":"","link":"https://qin_hu.gitee.io/blog/post/taro/","stats":{"text":"1 min read","time":47000,"words":181,"minutes":1},"date":"2023-12-19 10:57:07","dateFormat":"2023-12-19"},{"content":"api文档属性和事件列表： https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/2_2_u7ec4_u4ef6_u901a_u7528_u4fe1_u606f-0000001478341097-V2 一. 开发工具 1. IDE环境配置 学习的鸿蒙第一步就是下载华为DevEco Studio开发工具，点击下面的链接进入华为的官网下载。 IDE下载地址 下载好开发工具后打开，根据提示配置NodeJs和ohpm，安装Harmony Sdk。 2. 创建并运行项目 创建项目：打开开发者工具=&gt;创建一个项目 运行项目：previewer预览或者创建一个模拟器预览。 3. 工程目录 AppScope 存放应用全局所需要的资源文件。 entry 应用的主模块，存放HarmonyOS应用的代码、资源等。 oh_modules 工程的依赖包，存放工程依赖的源文件。 build-profile.json5 工程级配置信息，包括签名、产品配置等。 hvigorfile.ts 工程级编译构建任务脚本，hvigor是基于任务管理机制实现的一款全新的自动化构建工具，主要提供任务注册编排，工程模型管理、配置管理等核心能力。 oh-package.json5 工程级依赖配置文件，用于记录引入包的配置信息。 4. 官方文档 https://developer.huawei.com/consumer/cn/training/course/slightMooc/C101667303102887820?ha_linker=eyJ0cyI6MTcwMjkwNDYzNTQyNCwiaWQiOiIxM2E3Mjc4NjJmYjc2MjE1ZTVmYjc5MmMyYmE5ZDE3NiJ9 二. ArkTs入门 前置知识 ArkTS在TS的类型系统的基础上，做了进一步的扩展：定义了各种装饰器、自定义组件和UI描述机制。学习arkTs需要会js和ts。 查看typescript文档 https://developer.huawei.com/consumer/cn/training/course/slightMooc/C101667356568959645 1. 声明式UI描述 1-1. 组件表示 有参数组件 Text('这是文本内容') 无参数组件 Text() 1-2. 配置组件的属性 配置单个属性 Text('这是文本内容').fontSize(20) 配置多个属性 Image('test.jpg') .alt('error.jpg') .width(100) .height(100) 属性传递变量或者表达式 Text('hello') .fontSize(this.size) Image('test.jpg') .width(this.count % 2 === 0 ? 100 : 200) .height(this.offset + 100) 使用ArkUI提供的枚举 Text('hello') .fontSize(this.size) Image('test.jpg') .width(this.count % 2 === 0 ? 100 : 200) .height(this.offset + 100) 1-3. 给组件添加事件 使用箭头函数配置组件的事件方法。 Button('这是一个按钮') .onClick(()=&gt;{ console.log('点击了') }) 或者使用组件声明的箭头函数 clickHandle=()=&gt;{ console.log('点击了') } Button('这是一个按钮') .onClick(this.clickHandle) 使用匿名函数表达式配置组件的事件方法，要求使用bind，以确保函数体中的this指向当前组件。 Button('这是一个按钮') .onClick(function(){ console.log(this.message) }.bind(this)) 或者使用组件声明的函数 clickHandle(){ console.log(this.message) } Button('这是一个按钮') .onClick(this.clickHandle.bind(this)) 1-4. 组件嵌套，配置子组件 Column、Row、Stack、Grid、List等组件都是容器组件,均支持子组件配置 Column() { Row() { Image('test1.jpg') .width(100) .height(100) Button('click +1') .onClick(() =&gt; { console.info('+1 clicked!'); }) } } 常用装饰器 @Entry @Entry装饰的自定义组件将作为UI页面的入口。在单个UI页面中，最多可以使用@Entry装饰一个自定义组件。@Entry可以接受一个可选的LocalStorage的参数。 @Entry @Component struct MyComponent { } @Component @Component装饰器仅能装饰struct关键字声明的数据结构。struct被@Component装饰后具备组件化的能力，需要实现build方法描述UI，一个struct只能被一个@Component装饰。 @Component struct MyComponent{ } @Builder 通过自定义构建函数构建自定义组件。被@Builder装饰的函数是组件内私有成员函数，只能在组件的build方法中使用，不能在组件外部使用。在组件内通过this访问。 组件中使用 @Component struct MyComponent{ // 定义 @Builder MyBuilderFunction(){ Text('你好') } // 使用 this.MyBuilderFunction() } 全局中使用 // 全局创建自定义构建函数 @Builder function builderComponent(){ Button('这是一个全局按钮') } @Entry() @Component struct Index { build() { Row() { Column() { // 组件引用 builderComponent() } .width('100%') } .height('100%') } } 按引用地址传递 按引用传递参数时，传递的参数可为状态变量，且状态变量的改变会引起@Builder方法内的UI刷新。 ArkUI提供$$作为按引用传递参数的范式。 @Builder function builderComponent($$:{text:string}){ Button($$.text) } // 组件中传参 builderComponent({text:'这是自定义的构建函数组件'}) 按值传递参数 调用@Builder装饰的函数默认按值传递。当传递的参数为状态变量时，状态变量的改变不会引起@Builder方法内的UI刷新。 @Builder function builderComponent(text:string='自定义文本'){ Button(text) } // 组件中传参 builderComponent('这是自定义的构建函数组件') @BuilderParam @BuilderParam用来装饰指向@Builder方法的变量，开发者可在初始化自定义组件时对此属性进行赋值，为自定义组件增加特定的功能。该装饰器用于声明任意UI描述的一个元素，类似slot占位符。 现在我以创建一个自定义的Layou布局组件为示例，实现布局头部和底部通过组件传递，并且支持设置默认值 1. @BuilderParam 设置默认值 @Entry() @Component struct Index { build() { Column(){ MyComponent() } } } @Component struct MyComponent { build(){ Column(){ LayoutComponent() }.width('100%') .height('100%') .backgroundColor(Color.Blue) } } @Component struct LayoutComponent { // @BuilderParam 设置默认值 @Builder HeaderComponent(){ Text('header') } @Builder FooterComponent(){ Text('footer') } // 定义并设置默认值 @BuilderParam LayoutHeader:()=&gt;void=this.HeaderComponent; @BuilderParam LayoutFooter:()=&gt;void=this.FooterComponent; build(){ Column(){ this.LayoutHeader()// 定义占位 Text('主要内容') this.LayoutFooter()// 定义占位 }.width('100%') .height('100%') .backgroundColor(Color.White) } } 在上面代码中，我首先使用自定义构建函数@Builder装饰器创建了默认的元素，然后通过 @BuilderParam装饰器定义占位方法名称，并且设置了默认值；最后在自定义的组件中使用@BuilderParam装饰器创建的占位组件。 2. @BuilderParam 不设置默认值 不设置默认值的时候给组件默认赋值一个空，即void @Entry() @Component struct Index { build() { Column(){ MyComponent() } } } @Component struct MyComponent { build(){ Column(){ LayoutComponent() }.width('100%') .height('100%') .backgroundColor(Color.Blue) } } @Component struct LayoutComponent { // 定义 @BuilderParam LayoutHeader:()=&gt;void;; @BuilderParam LayoutFooter:()=&gt;void; build(){ Column(){ // 此时直接使用将会报错，我们必须保证有组件将构造组件传进来。 this.LayoutHeader() Text('主要内容') this.LayoutFooter() }.width('100%') .height('100%') .backgroundColor(Color.White) } } 注意，此时直接在组件中使用将会报错，我们必须保证有组件将构造组件传进来。 3. 在父组件（引入组件的地方）中传值 @Entry() @Component struct Index { build() { Column(){ MyComponent() } } } @Component struct MyComponent { //自定义的构造器组件函数 @Builder HeaderComponent(){ Text('header') } @Builder FooterComponent(){ Text('footer') } build(){ Column(){ // 引入组件时传构造器组件函数 LayoutComponent({ LayoutHeader:this.HeaderComponent, LayoutFooter:this.FooterComponent }) }.width('100%') .height('100%') .backgroundColor(Color.Blue) } } @BuilderParam官方文档 @Styles 定义组件重用样式。 注意点：1. @Styles不支持参数。 2. 可以在全局定义，需加上function关键字。局部定义则不需要加关键字。3. 在组件内定义的@Styles可以通过this访问组件的常量和状态常量。4. 组件内@Styles的优先级高于全局@Styles。 1. 组件内使用@Styles @Entry() @Component struct Index { build() { Column(){ MyComponent() } } } @Component struct MyComponent { //组件内 - 自定义组件样式 @Styles MyStyle(){ .width('100%') .height('100%') .backgroundColor(Color.Pink) } build(){ // 使用局部组件 Column(){ }.MyStyle() } } 2. 全局使用@Styles @Entry() @Component struct Index { build() { Column(){ MyComponent() } } } // 全局定义样式 @Styles function CommonStyle(){ .width('100%') .height('100%') .backgroundColor(Color.Pink) } @Component struct MyComponent { build(){ // 使用全局定义的样式 Column(){ }.CommonStyle() } } 3. 在组件内使用状态变量 @Entry() @Component struct Index { build() { Column(){ MyComponent() } } } @Component struct MyComponent { @State setWidth:string='100%'; @State setHeight:string='100%'; //组件内 - 自定义组件样式 @Styles MyStyle(){ // 使用自定义的状态变量 .width(this.setWidth) .height(this.setHeight) .backgroundColor(Color.Pink) } build(){ // 局部 Column(){ }.MyStyle() } } @Extend 扩展组件样式 注意点：1. @Extend仅支持定义在全局。2. @Extend支持封装指定的组件的私有属性和私有事件和预定义相同组件的@Extend的方法。3.@Extend装饰的方法支持参数。参数可以为状态变量。 @Extend仅支持定义在全局并且传参 @Entry() @Component struct Index { build() { Column(){ MyComponent() } } } // 全局定义继承内置组件的样式 @Extend(Text) function TextCustom(color:string){ .fontSize('33vp') .fontColor(color) } @Component struct MyComponent { build(){ Column(){ Text('自定义文字') .TextCustom('red') // 使用自定义的样式 } } } @Extend传递事件 @Entry() @Component struct Index { build() { Column(){ MyComponent() } } } // 全局定义继承内置组件的样式 @Extend(Text) function TextCustom(color:string,onClick:()=&gt;void){ .fontSize('33vp') .fontColor(color) .onClick(onClick) } // 事件 myClickHandle=()=&gt;{ console.log('点击了') } build(){ Column(){ // 传递一个事件 Text('自定义文字') .TextCustom('red',this.myClickHandle) } } } 多态样式 stateStyles stateStyles是属性方法，可以根据UI内部状态来设置样式，类似于css伪类，但语法不同。ArkUI提供以下四种状态： focused：获焦态。 normal：正常态。 pressed：按压态。 disabled：不可用态。 @Entry() @Component struct Index { build() { Column(){ MyComponent() } } } @Component struct MyComponent { build(){ Column(){ Button(&quot;这是一个按钮&quot;) .stateStyles({ // 默认样式 normal:{ .backgroundColor('#222') }, // 按压样式 pressed:{ .backgroundColor('#528d3a') }, // 禁用样式 disabled:{ .opacity(.5) } }) TextInput() .stateStyles({ normal:{ .backgroundColor('#ffffff') }, // 聚焦样式 focused:{ .backgroundColor('#90c2f3') } }) } } } 3. 组件 3-1. 了解组件 组件的特性：可组合，可重用，数据驱动UI更新。 组件的组成：基于struct实现。struct被@Component装饰后具备组件化的能力。build函数对组件声明式UI描述。@Entry装饰的自定义组件将作为UI页面的入口。 注意点： 自定义组件不支持静态成员变量，所有成员变量都是私有的。 build函数中ForEach禁止作为根节点。 build函数中不允许声明本地变量。例子：let a:number=1 X build函数中中不能直接使用console.info build函数中不允许创建本地作用域。{ } X build函数中不能调用没有用@Builder装饰的方法。允许系统组件的参数是TS方法的返回值。 例子： @Component struct ParentComponent { doSomeCalculations() { } calcTextValue(): string { return 'Hello World'; } @Builder doSomeRender() { Text(`Hello World`) } build() { Column() { // 反例：不能调用没有用@Builder装饰的方法 this.doSomeCalculations(); // 正例：可以调用 this.doSomeRender(); // 正例：参数可以为调用TS方法的返回值 Text(this.calcTextValue()) } } } build函数中不允许switch语法 build函数中不允许使用表达式 例子： build() { Column() { // 反例：不允许使用表达式 (this.aVar &gt; 10) ? Text('...') : Image('...') } } 自定义组件通过“.”链式调用的形式设置通用样式。 3-2. 创建一个组件 使用@Entry()装饰的组件是入口组件。使用@Component装饰的是自定义组件。 // 入口组件 @Entry() @Component struct Index { build() { Column(){ MyComponentOne() MyComponentTwo() } } } // 自定义组件 @Component struct MyComponentOne { build(){ Text('这是自定义组件1') } } @Component struct MyComponentTwo { build(){ Text(&quot;这是自定义组件2&quot;) } } 或者使用 @Builder创建UI描述类型的组件 // 入口组件 @Entry() @Component struct Index { build() { Column(){ MyComponentThree() } } } // 自定义描述组件 @Builder function MyComponentThree (){ Text('这是自定义组件3') } 3-3. 组件传参 父传子 使用@Prop @Entry @Component struct Index { @State count:number=1; build() { Column(){ Button('点击+1') .onClick(()=&gt;{ this.count=this.count+1 }) MyComponentTest({count:this.count}) } } } @Component struct MyComponentTest { @Prop count:number; build(){ Text(`${this.count}`) } } 子传父 @Entry @Component struct Par { // 接收子组件值 checkFun(data){ console.info(JSON.stringify(data)) } build() { Column() { // 传回调方法 Child({checkFun:(data)=&gt;this.checkFun(data)} } } @Component struct Child { checkFun:(res)=&gt;void; build(){ Row(){ Button(&quot;传值设置&quot;) .onClick(()=&gt;{ // 给父组件传递值 this.checkFun({ uuid:1, isOn:false}) }) } } 兄弟传递 祖孙传递 3-4. 生命周期 页面生命周期。被@Enter装饰的组件。 onPageShow：页面每次显示时触发。 onPageHide：页面每次隐藏时触发一次。 onBackPress：当用户点击返回按钮时触发。 组件生命周期。@Component装饰的自定义组件 aboutToAppear：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其build()函数之前执行。 aboutToDisappear：在自定义组件即将析构销毁时执行。 由上图可知，页面组件首先执行aboutToAppear方法，再执行build方法，然后才执行onPageShow方法。所以父组件执行完aboutToAppear方法后，将会直接执行子组件的aboutToAppear方法生命周期函数。 @Entry @Component struct Index { @State count:number=1; onPageShow(){ console.info('页面显示') } onPageHide(){ console.info('页面隐藏') } onBackPress(){ console.info('页面返回') } aboutToAppear(){ console.info('组件初始化') } aboutToDisappear(){ console.info('组件销毁') } build() { Column(){ Child() } } } @Component struct Child { aboutToAppear(){ console.info('子组件初始化') } aboutToDisappear(){ console.info('子组件销毁') } build(){ } } 4. 状态管理 状态变量的改变会引起UI的渲染刷新。 1. 管理组件中的状态 @State装饰器：创建组件内的状态 自定义创建基本类型状态 boolean,string,number @Entry @Component struct Index { @State count:number=1; build() { Column(){ Text(`数量：${this.count}`) } } } 自定义创建复杂数据类型变量 class ， object @Entry @Component struct Index { @State data:{ name:string, age:number, count:number }={ name:&quot;小明&quot;, age:12, count:1 } build() { Column(){ Text(`姓名：${this.data.name}`) Text(`年龄：${this.data.age}`) Text(`数量：他有${this.data.count}个苹果`) Button(&quot;再多给他1个苹果&quot;) .onClick(()=&gt;{ this.data.count=this.data.count+1 }) } } } 当装饰的对象是array时，可以观察到数组本身的赋值和添加、删除、更新数组的变化。 @Entry @Component struct Index { @State list:Array&lt;number&gt;=[1,2] build() { Column(){ Text(`${this.list}`) Button(&quot;新增&quot;) .onClick(()=&gt;{ this.list.push(Math.random()) }) Button(&quot;删除&quot;) .onClick(()=&gt;{ this.list.pop() }) } } } @Prop装饰器：父子单向同步 @Entry @Component struct Index { @State count:number=1; build() { Column(){ Button('点击+1') .onClick(()=&gt;{ this.count=this.count+1 }) MyComponentTest({count:this.count}) } } } @Component struct MyComponentTest { @Prop count:number; build(){ Text(`${this.count}`) } } @Link：父子双向同步 在子组件使用@Link装饰器声明属性。父组件使用$传递state状态变量。 @Entry @Component struct Index { @State keyword:string='' build() { Column(){ Text(&quot;这是父组件：&quot;) Text(`${this.keyword}`) Button('父组件修改输入框的值') .onClick(()=&gt;{ this.keyword=Math.random().toString() }) Text(&quot;这是子组件：&quot;) Child({keyword:$keyword}) } } } @Component struct Child { @Link keyword:string; build(){ Column(){ TextInput({ text:this.keyword }) .onChange((value)=&gt;{ this.keyword=value }) Text(`${this.keyword}`) } } } @Provide装饰器和@Consume装饰器：与后代组件双向同步 @Provide装饰的变量是在祖先节点中，可以理解为被“提供”给后代的状态变量。@Consume装饰的变量是在后代组件中，去“消费（绑定）”祖先节点提供的变量。 例子：父组件，子组件，祖孙组件状态同步。 @Entry @Component struct Index { @Provide keyword:string='' build() { Column(){ Text(&quot;这是顶级组件：&quot;) Text(`${this.keyword}`) Button('顶级组件修改祖孙输入框的值') .onClick(()=&gt;{ this.keyword=Math.random().toString() }) ChildOne() } } } @Component struct ChildOne { @Consume keyword:string; build(){ Column(){ Text(`这是子组件:`) Text(`${this.keyword}`) Button('子组件修改祖孙输入框的值') .onClick(()=&gt;{ this.keyword=Math.random().toString() }) ChildTwo() } } } @Component struct ChildTwo { @Consume keyword:string; build(){ Column(){ Text(&quot;这是祖孙组件：&quot;) TextInput({ text:this.keyword }) .onChange((value)=&gt;{ this.keyword=value }) Text(`${this.keyword}`) } } } @Observed装饰器和@ObjectLink装饰器：嵌套类对象属性变化 @Observed装饰的类，如果其属性为非简单类型，比如class、Object或者数组，也需要被@Observed装饰，否则将观察不到其属性的变化。 框架行为 初始渲染： @Observed装饰的class的实例会被不透明的代理对象包装，代理了class上的属性的setter和getter方法 子组件中@ObjectLink装饰的从父组件初始化，接收被@Observed装饰的class的实例，@ObjectLink的包装类会将自己注册给@Observed class。 属性更新：当@Observed装饰的class属性改变时，会走到代理的setter和getter，然后遍历依赖它的@ObjectLink包装类，通知数据更新。 @Entry @Component struct Index { private initData= { name:'', age:undefined, count:undefined } build() { Column(){ Text(&quot;这是顶级组件：&quot;) // 初始化状态变量 Child({ customState:new CustomState(this.initData) }) } } } // 定义状态变量 @Observed class CustomState { public name:string=''; public age:string=''; public count:string=''; constructor(data:{ name:string, age:string, count:string }) { this.name=data.name this.age=data.age this.count=data.count } } @Component struct Child { // 声明关联状态 @ObjectLink customState:CustomState; build(){ Column(){ TextInput({ text:this.customState.name, placeholder:&quot;请输入姓名&quot; }) TextInput({ text:this.customState.age, placeholder:&quot;请输入年龄&quot; }) TextInput({ text:this.customState.count, placeholder:&quot;请输入数量&quot; }) } } } 2. 管理应用的状态 LocalStorage：页面级UI状态存储 应用逻辑使用LocalStorage @Entry() @Component struct Index{ createLocalStorage(){ // 创建一个新的应用状态管理 let store=new LocalStorage({ user:'admin', account:123456 }) // 获取数据 console.log(store.get('user')) console.log(store.get('account')) // 修改值 只能设置定义的属性 store.set('user','admin1') console.log(store.get('user')) //admin1 // 获取key集合 store.keys() // 获取集合长度 store.size() console.log(store.size().toString()) //2 // 是否存在key console.log(store.has('user').toString()) //true console.log(store.has('userInfo').toString()) //false // 将属性值定义为单向状态变量 let propState=store.prop('user') // 将属性值定义为双向状态变量 let linkState=store.link('user') // 其他：delete，clear。 } onPageShow(){ this.createLocalStorage() } build(){ Column(){ Text(&quot;根组件&quot;) } } } 或者定义在全局 @Entry() @Component struct Index{ onPageShow(){ createLocalStorage() } build(){ Column(){ Text(&quot;根组件&quot;) } } } function createLocalStorage(){ // 创建一个新的应用状态管理 let store=new LocalStorage({ user:'admin', account:123456 }) // 获取数据 console.log(store.get('user')) console.log(store.get('account')) // 修改值 只能设置定义的属性 store.set('user','admin1') console.log(store.get('user')) //admin1 // 获取key集合 store.keys() // 获取集合长度 store.size() console.log(store.size().toString()) //2 // 是否存在key console.log(store.has('user').toString()) //true console.log(store.has('userInfo').toString()) //false // 将属性值定义为单向状态变量 let propState=store.prop('user') // 将属性值定义为双向状态变量 let linkState=store.link('user') // 其他：delete，clear。 } 从UI内部使用LocalStorage @LocalStorageProp - 单向更新 @LocalStorageProp定义的变量不会同步更新到storage（仅在组件内更新）。 通过下面的例子可见，点击按钮组件中的状态更新并不会修改 LocalStorage变量更新。 // 自定义的storage let storage = new LocalStorage({ account:1, username:'admin' }) // 入口组件中使用@LocalStorageProp需要传递storage @Entry(storage) @Component struct Index{ @LocalStorageProp('account') account:number=0; // 赋值则设置默认值 @LocalStorageProp('username') username:string=''; build(){ Column(){ Button(`点我+1 = ${this.account}`) .onClick(()=&gt;{ this.account= this.account+1 }) MyComponent() } } } // 自定义组件中使用 @LocalStorageProp @Component struct MyComponent { @LocalStorageProp('account') account:number=undefined; build(){ Column(){ Text(`${this.account}`) } } } @LocalStorageLink - 双向更新 @LocalStorageProp定义的变量会同步更新到storage。 通过下面的例子可见，点击按钮组件中的状态更新会使 LocalStorage变量更新。 let storage = new LocalStorage({ account:1, username:'admin' }) @Entry(storage) @Component struct Index{ @LocalStorageLink('account') account:number=0; // 赋值则设置默认值 @LocalStorageLink('username') username:string=''; build(){ Column(){ Button(`点我+1 = ${this.account}`) .onClick(()=&gt;{ this.account= this.account+1 }) MyComponent() } } } @Component struct MyComponent { @LocalStorageProp('account') account:number=undefined; build(){ Column(){ Text(`${this.account}`) } } } 使用场景：@LocalStorageLink用来兄弟组件状态变量共享再好不过了。 AppStorage：应用全局UI状态存储 AppStorage创建的状态变量在App全局都可以访问到 从应用逻辑使用AppStorage @Entry() @Component struct Index{ onPageShow(){ createAppStorage() } build(){ Column(){ } } } AppStorage.SetOrCreate('theme','dark') function createAppStorage(){ // 使用Get获取全局key let theme:string=AppStorage.Get('theme') console.info(theme) // dark // 设置全局key // 1. 使用set AppStorage.Set('theme','light') theme=AppStorage.Get('theme') console.info(theme) // light // 2. 使用SetOrCreate AppStorage.SetOrCreate('theme','red') theme=AppStorage.Get('theme') console.info(theme) // red // 3. 设置带状态的应用变量 // 单向的状态变量 AppStorage.SetAndProp('theme','dark') // 双向的状态变量 AppStorage.SetAndLink('theme','light') } 从UI逻辑使用AppStorage @StorageLink 应用内双向更新 @StorageLink中的变量变化会使整个应用中对应的状态变量变化。 写一个例子：给整个应用设置一个主题变量，主题变量的改变会使整个应用的主题颜色修改。 Index.ets import router from '@ohos.router' // 定义应用全局状态变量 AppStorage.SetAndLink('theme','black') @Entry() @Component struct Index{ // 引入应用全局变量 @StorageLink('theme') theme:string =undefined onPageShow(){ console.info(&quot;2222,&quot;,this.theme) } build(){ Column(){ // 定义一个按钮修改他的主题色 Button(`修改主题:${this.theme=='white'?'黑夜':'白天'}`) .onClick(()=&gt;{ this.theme=this.theme=='white'?'black':'white' }) Button(&quot;关于页面&quot;) .onClick(()=&gt;{ router.pushUrl({ url:'pages/About' }) }) } .width('100%') .height('100%') .backgroundColor(this.theme) } } About.ets 由此可见，About的页面状态也更新了。 @Entry @Component struct About { @StorageLink('theme') theme:string='' onPageShow(){ console.info(this.theme) } build() { Column(){ Text(&quot;关于页面&quot;) .fontColor('red') } .width('100%') .height('100%') .backgroundColor(this.theme) } } @StorageProp 应用内单向更新 使用场景：只想某个页面存储状态，不想应用到全局。 Index.ets import router from '@ohos.router' AppStorage.SetAndProp('theme','black') @Entry() @Component struct Index{ @StorageProp('theme') theme:string =undefined onPageShow(){ console.info(&quot;2222,&quot;,this.theme) } build(){ Column(){ Button(`修改主题:${this.theme=='white'?'黑夜':'白天'}`) .onClick(()=&gt;{ this.theme=this.theme=='white'?'black':'white' }) Button(&quot;关于页面&quot;) .onClick(()=&gt;{ router.pushUrl({ url:'pages/About' }) }) } .width('100%') .height('100%') .backgroundColor(this.theme) } } about.ets @Entry @Component struct About { @StorageProp('theme') theme:string='' onPageShow(){ // 此时theme的状态还是初始化的全局应用状态 console.info(this.theme) // dark } build() { Column(){ Text(&quot;关于页面&quot;) .fontColor('red') } .width('100%') .height('100%') .backgroundColor(this.theme) } } PersistentStorage：持久化存储UI状态 LocalStorage和AppStorage都是运行时的内存,应用退出后将失效。在应用退出再次启动后，依然能保存选定的结果，这就需要用到PersistentStorage。 PersistentStorage将选定的AppStorage属性保留在设备磁盘上。应用程序通过API，以决定哪些AppStorage属性应借助PersistentStorage持久化。 持久数据变量会自动转义为string，注意在使用状态变量时转义变量类型。 // 初始化持久化存储状态变量 PersistentStorage.PersistProp('count',1) @Entry() @Component struct Index{ // 使用持久化存储状态变量,向AppStorage用法一样使用 @StorageLink('count') count:number=undefined; build(){ Column(){ Text(`${this.count}`); Button('点击+1') .onClick(()=&gt;{ this.count=Number(this.count)+1 }) } } } 将应用打开后，修改count的值，这时退出应用重新打开应用，应用的count状态还是修改之前的状态。 Environment：设备环境查询 设备环境到Component的更新链：Environment --&gt; AppStorage --&gt;Component。 // 定义设备环境变量 Environment.EnvProp('langCode','cn') @Entry @Component struct Index { // 使用设备环境变量 @StorageProp('langCode') langCode:string=undefined onPageShow(){ console.info(this.langCode) // cn } build() { Column(){ Text(this.langCode) } } } 3. 其他状态管理 @watch @Watch绑定一个方法来监听定义的状态变量。 @Entry @Component struct Index { @State count:number = 0 build() { Column(){ Button('点我+1') .onClick(()=&gt;{ this.count=Number(this.count)+1 }) MyComponent({count:this.count}) } } } @Component struct MyComponent { @Prop @Watch('onUpdateCount') count:number; // 监听属性变化 onUpdateCount(propName:string){ console.info(propName) console.info(`${this.count}`) } build(){ Column(){ Text(`${this.count}`) } } } $$ 当前$$支持基础类型变量，以及@State、@Link和@Prop装饰的变量。 当前$$仅支持bindPopup属性方法的show参数，Radio组件的checked属性，Refresh组件的refreshing参数。 $$绑定的变量变化时，会触发UI的同步刷新。 渲染控制 if/else 条件渲染 @Entry @Component struct Index { @State count:number = 0 build() { Column(){ Button('点我+1') .onClick(()=&gt;{ this.count=Number(this.count)+1 }) if(this.count % 2 === 1){ Text(&quot;奇数&quot;+this.count) }else{ Text(&quot;偶数&quot;+this.count) } } } } ForEach：循环渲染 ForEach必须在容器组件内使用。 生成的子组件应当是允许包含在ForEach父容器组件中的子组件。 允许子组件生成器函数中包含if/else条件渲染，同时也允许ForEach包含在if/else条件渲染语句中。 itemGenerator函数的调用顺序不一定和数组中的数据项相同，在开发过程中不要假设 itemGenerator和keyGenerator函数是否执行及其执行顺序。 @Entry @Component struct Index { @State count:number = 0 @State ArrayCount:number[]=[1,2,3,4,5] build() { Column(){ ForEach(this.ArrayCount,(item,index)=&gt;{ Text(`${item},${index}`) }) } } } LazyForEach：数据懒加载 ","tags":[{"index":-1,"name":"HarmonyOS","slug":"sjEwf3qeE","used":true,"link":"https://qin_hu.gitee.io/blog/tag/sjEwf3qeE/"}],"title":"项目开发工具与ArkTs入门","feature":"","link":"https://qin_hu.gitee.io/blog/post/jian-dan-ru-men/","stats":{"text":"25 min read","time":1465000,"words":5640,"minutes":25},"date":"2023-12-18 22:13:05","dateFormat":"2023-12-18"},{"content":"理解 less和scss都属于css的预处理器（css扩展语言），css本身不具备编程能力，使用预处理器增加了css的扩展性，他们都会编译成css语言。 基本使用 less 变量 @cus-width:10px; // 使用 width:@cus-width; 混合 将一组属性规则继承到另外一组属性中 .box-1{ width:100px; height:120px; background:skyblue; } // 继承box-1类名的样式。 .box-2{ .box-1(); } 嵌套 是对多级dom节点访问属性的简介。 .clearfix { display: block; zoom: 1; // &amp;表示当前节点的父级 &amp;:after { content: &quot; &quot;; display: block; } } 运算 使用 + , - , * , / 对css单位运算 @width:120px + 10px; @height:@width / 2; .box-1{ width:@width * 2; height:@height; height:120px; background:skyblue; } 映射 将混合（mixins）和规则集（rulesets）作为一组值的映射（map）使用。 #color(){ primary:red; info:skyblue; } .box-2{ background:#color[primary]; color:#color[info]; } 导入 @import &quot;library&quot;; // library.less @import &quot;typo.css&quot;; 循环 .for-css(@n, @i: 1) when (@i =&lt; @n) { .fs-@{i} { font-size: 0px + @i; } .for-css(@n, (@i+1)); } // 使用 .for-css(100); less参考官网 scss 变量 $nav-color: #F90; nav { $width: 100px; width: $width; color: $nav-color; } 循环 // （1）i定义变量 （2）.from..through.. 开始至结束 （3）#{i} 引用变量 @for $i from 1 through 5 { .active-#{$i}{ .box-#{$i}{ font-size:20px; } } } scss参考官网 相关问题 Css有哪些预处理器？为什么要使用预处理器? Css预处理器常见的有less，scss，PostCss。预处理器给css带来了可编程的特性，通过变量，嵌套，运算，函数等特性，通过工程化的手段让css更好维护，提高开发效率 关键词： less scss PostCss 工程化 提升效率 ","tags":[{"index":-1,"name":"Html&Css","slug":"18jtBTPqK","used":true,"link":"https://qin_hu.gitee.io/blog/tag/18jtBTPqK/"}],"title":"css预处理器-less和scss","feature":"","link":"https://qin_hu.gitee.io/blog/post/less-he-scss/","stats":{"text":"2 min read","time":106000,"words":399,"minutes":2},"date":"2023-12-18 16:03:49","dateFormat":"2023-12-18"},{"content":"水平居中 &lt;div class=&quot;box-one mg-t-30&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .box-one { display: flex; justify-content: center; width: 100%; } .box-one&gt;.box { width: 100px; height: 30px; background-color: skyblue; } &lt;/style&gt; 垂直居中 &lt;div class=&quot;box-two mg-t-30&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .box-two { display: flex; align-items: center; width: 100%; height: 80px; background-color: greenyellow; } .box-two&gt;.box { width: 100px; height: 30px; background-color: pink; } &lt;/style&gt; 水平垂直居中 &lt;div class=&quot;box-three mg-t-30&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .box-three { display: flex; align-items: center; justify-content: center; width: 100%; height: 80px; background-color: rgb(47, 255, 182); } .box-three&gt;.box { width: 100px; height: 30px; background-color: pink; } &lt;/style&gt; 两列布局 一列定宽,一列自适应 &lt;div class=&quot;box-four mg-t-30&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .box-four { width: 100%; background-color: rgb(0, 0, 0); height: 30px; display: flex; } .box-four&gt;.left { width: 120px; height: inherit; background-color: pink; } .box-four&gt;.right { flex: 1; background-color: skyblue; height: inherit; } &lt;/style&gt; 三列布局 两列固定,中间自适应 &lt;div class=&quot;box-five mg-t-30&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .box-five { width: 100%; height: 30px; display: flex; } .box-five&gt;.left, .box-five&gt;.right { width: 150px; height: inherit; background-color: skyblue; } .box-five&gt;.center { height: inherit; flex: 1; background-color: pink; } &lt;/style&gt; 等分布局 根据列数等分 &lt;div class=&quot;box-six mg-t-30&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .box-six { width: 100%; height: 30px; display: flex; } .box-six&gt;div:nth-child(2n) { background-color: pink; } .box-six&gt;div:nth-child(2n-1) { background-color: skyblue; } .box-six&gt;div { height: inherit; /* 核心代码 */ flex: 1; } &lt;/style&gt; sticky footer布局 &lt;div class=&quot;box-seven mg-t-30&quot;&gt; &lt;div class=&quot;main&quot;&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;底部&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .box-seven { width: 100%; min-height: 100vh; background-color: pink; display: flex; flex-direction: column; } .box-seven&gt;.main { width: 100%; flex: 1; background-color: rebeccapurple; } .box-seven&gt;.footer { height: 30px; width: 100%; background: yellow; } &lt;/style&gt; 全屏布局 顶部和底部固定 中间侧边栏左固定右自适应 &lt;div class=&quot;box-eight mg-t-30&quot;&gt; &lt;div class=&quot;top&quot;&gt;顶部&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;div class=&quot;left&quot;&gt; 侧边栏 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 内容 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;底部&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .box-eight { width: 100%; height: 100vh; background-color: #222; display: flex; flex-direction: column; justify-content: space-between; } .box-eight&gt;.center { flex: 1; background-color: rgb(229, 138, 18); display: flex; } .box-eight&gt;.center&gt;.left { width: 150px; height: inherit; background-color: pink; } .box-eight&gt;.center&gt;.right { flex: 1; height: inherit; background-color: skyblue; } .box-eight&gt;.top { height: 50px; width: 100%; background-color: #368873; } .box-eight&gt;.footer { height: 30px; width: 100%; background-color: blue; } &lt;/style&gt; ","tags":[{"index":-1,"name":"Html&Css","slug":"18jtBTPqK","used":true,"link":"https://qin_hu.gitee.io/blog/tag/18jtBTPqK/"}],"title":"flex布局实现前端布局","feature":"","link":"https://qin_hu.gitee.io/blog/post/flex-bu-ju-shi-xian-qian-duan-bu-ju/","stats":{"text":"5 min read","time":256000,"words":725,"minutes":5},"date":"2023-12-14 17:11:27","dateFormat":"2023-12-14"},{"content":"常用命令 登录 npm login 登录失败如果网络问题尝试换网络（用手机热点） 查看登录信息 npm profile get 开发效率 nrm - 镜像管理工具 查看所有镜像源 nrm ls 使用镜像源 nrm use taobao 测试速度 nrm test taobao ","tags":[{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"npm工具库","feature":"","link":"https://qin_hu.gitee.io/blog/post/npm-gong-ju-ku/","stats":{"text":"1 min read","time":16000,"words":72,"minutes":1},"date":"2023-12-13 16:21:54","dateFormat":"2023-12-13"},{"content":"初始化 git init 将文件更改添加到暂存区 git add . 将暂存区内容添加到本地仓库 git commit -m '提交描述' 将本地分支版本上传到远程分支并且合并 git push origin master:master 本地分支和远程分支一样可以忽略':'冒号。 git push origin master 将远程分支拉取到本地 git pull origin master 查看当前已配置的远程仓库 git remote -v 本地关联远程仓库 git remote add origin http://xxx.git 重命名远程仓库 git remote rename http://xxx.git 删除远程仓库 git remote remove http://xxx.git 创建分支 git branch branchname 切换分支 git checkout branchname 创建新分支并切换到当前分支 git checkout -b branchname 创建新分支并切换到指定版本分支 git checkout -b branchname 6179b55839f403cf079b89f4c64b6f37fd821350 根据tag创建分支 git branch 1215-tag-1.0.1 1.0.1 git branch 分支名称 tag名称 从远程获取代码库 git fetch 合并分支 git merge branchname 查看历史提交 git log 克隆远程代码 git clone http://xxx.git 创建一个带注解的标签 git tag -a v1.0 查看所有标签 git tag 查看当前配置用户 git config user.name 查看当前配置邮箱 git config user.email 配置当前用户 全局配置 git config --global user.name &quot;Your name&quot; 当前项目配置 git config user.name &quot;Your name&quot; 配置当前邮箱 全局配置 git config --global user.email &quot;Your eamil&quot; 当前项目配置 git config user.email &quot;Your name&quot; 统计项目中的文件行数 find . &quot;(&quot; -name &quot;*.html&quot; -or -name &quot;*.js&quot; -or -name &quot;*.css&quot; -or -name &quot;*.vue&quot; &quot;)&quot; -print | xargs wc -l ","tags":[{"index":-1,"name":"git","slug":"EkPmoJq_R","used":true,"link":"https://qin_hu.gitee.io/blog/tag/EkPmoJq_R/"}],"title":"git常用命令","feature":"","link":"https://qin_hu.gitee.io/blog/post/git-chang-yong-ming-ling/","stats":{"text":"2 min read","time":111000,"words":415,"minutes":2},"date":"2023-12-13 13:12:47","dateFormat":"2023-12-13"},{"content":"1. 什么是响应式布局？ 响应式布局设计是指页面可以根据用户使用的设备环境(系统平台，屏幕尺寸，屏幕定向)做出相应的响应和调整。 在管理系统，门户企业网站，个人博客网站中非常适合使用响应式网站设计。 2. 实现 1. 使用 viewport meta 控制视口的大小和形状。 页面在移动端设备较小尺寸的屏幕上渲染会被截断，这时我们还需要滑动屏幕才能看到一个完整的网页（体验糟糕），虚拟视口则是一种使非移动设备优化页面在窄屏设备上看起来更好的一个方法。 将视口宽度设置为100%，缩放比例等比例缩放。 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; mdn文档 - viewport meta 2. 使用媒体查询 根据布局的尺寸大小对页面样式做出相应的调整，来实现响应式的效果。 通常我会在项目中创建一个layout.css文件，来专门针对设备处理css样式。 /* 更大设备 */ @media screen and (min-width: 1281px) {} /* 笔记本或PC */ @media screen and (min-width: 1024px) and (max-width: 1280px) {} /* ##平板电脑/Ipad竖屏 */ @media screen and (min-width: 768px) and (max-width: 1023px) {} /* 多数竖屏的智能手机 */ @media screen and (min-width: 320px) and (max-width: 767px) {} /* 公共 */ @media screen and (min-width: 320px) and (max-width: 1023px) {} 如果只使用媒体查询，会造成pc端和移动端有两套css相似度极高的代码，针对两端写相同的代码这种方案肯定是不可行的，使用删格布局就可以解决这种问题。 3. 栅格系统 栅格布局在一些UI库中被称为layout布局，栅格布局将页面分为24等分列（elementUI，Vant）或者12等分列，在页面设计时我们根据设备尺寸(PC,移动端)将组件划分到指定的列中实现响应式。 1. 自己实现一个栅格系统 实现原理：根据媒体查询设置不同的百分比宽度（通过clac动态计算） &lt;div class=&quot;app&quot;&gt; &lt;!-- 固定的布局 --&gt; &lt;!-- &lt;div class=&quot;row&quot; style=&quot;height: 50px;&quot;&gt; &lt;div class=&quot;col-4&quot; style=&quot;background-color: saddlebrown;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-6&quot; style=&quot;background-color: blue;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-2&quot; style=&quot;background-color: pink;&quot;&gt;&lt;/div&gt; &lt;/div&gt; --&gt; &lt;!-- 响应式的布局 --&gt; &lt;div class=&quot;row&quot; style=&quot;height: 50px;&quot;&gt; &lt;div class=&quot;lg-3 sm-6 xs-12&quot; style=&quot;background-color: saddlebrown;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;lg-3 sm-6 xs-12&quot; style=&quot;background-color: blue;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;lg-3 sm-6 xs-12&quot; style=&quot;background-color: pink;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;lg-3 sm-6 xs-12&quot; style=&quot;background-color: red;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;style&gt; /* 模拟分成12等分 */ .row { width: 100%; display: flex; flex-wrap: wrap; } .col-1 { width: calc(100% / 12 * 1); } .col-2 { width: calc(100% / 12 * 2); } .col-3 { width: calc(100% / 12 * 3); } .col-4 { width: calc(100% / 12 * 4); } .col-5 { width: calc(100% / 12 * 5); } .col-6 { width: calc(100% / 12 * 6); } .col-7 { width: calc(100% / 12 * 7); } .col-8 { width: calc(100% / 12 * 8); } .col-9 { width: calc(100% / 12 * 9); } .col-10 { width: calc(100% / 12 * 10); } .col-11 { width: calc(100% / 12 * 11); } .col-12 { width: calc(100% / 12 * 12); } /* gutter */ .gutter-5 { padding: 5px; } .gutter-10 { padding: 10px; } .gutter-15 { padding: 15px; } .gutter-20 { padding: 20px; } .gutter-25 { padding: 25px; } .gutter-30 { padding: 30px; } /* lg */ @media screen and (min-width: 1025px) { .lg-1 { width: calc(100% / 12 * 1); } .lg-2 { width: calc(100% / 12 * 2); } .lg-3 { width: calc(100% / 12 * 3); } .lg-4 { width: calc(100% / 12 * 4); } .lg-5 { width: calc(100% / 12 * 5); } .lg-6 { width: calc(100% / 12 * 6); } .lg-7 { width: calc(100% / 12 * 7); } .lg-8 { width: calc(100% / 12 * 8); } .lg-9 { width: calc(100% / 12 * 9); } .lg-10 { width: calc(100% / 12 * 10); } .lg-11 { width: calc(100% / 12 * 11); } .lg-12 { width: calc(100% / 12 * 12); } } /* sm */ @media screen and (min-width: 768px) and (max-width: 1024px) { .sm-1 { width: calc(100% / 12 * 1); } .sm-2 { width: calc(100% / 12 * 2); } .sm-3 { width: calc(100% / 12 * 3); } .sm-4 { width: calc(100% / 12 * 4); } .sm-5 { width: calc(100% / 12 * 5); } .sm-6 { width: calc(100% / 12 * 6); } .sm-7 { width: calc(100% / 12 * 7); } .sm-8 { width: calc(100% / 12 * 8); } .sm-9 { width: calc(100% / 12 * 9); } .sm-10 { width: calc(100% / 12 * 10); } .sm-11 { width: calc(100% / 12 * 11); } .sm-12 { width: calc(100% / 12 * 12); } } /* xs */ @media screen and (max-width: 767px) { .xs-1 { width: calc(100% / 12 * 1); } .xs-2 { width: calc(100% / 12 * 2); } .xs-3 { width: calc(100% / 12 * 3); } .xs-4 { width: calc(100% / 12 * 4); } .xs-5 { width: calc(100% / 12 * 5); } .xs-6 { width: calc(100% / 12 * 6); } .xs-7 { width: calc(100% / 12 * 7); } .xs-8 { width: calc(100% / 12 * 8); } .xs-9 { width: calc(100% / 12 * 9); } .xs-10 { width: calc(100% / 12 * 10); } .xs-11 { width: calc(100% / 12 * 11); } .xs-12 { width: calc(100% / 12 * 12); } } &lt;/style&gt; 上面代码我在大屏幕尺寸下设置了30%比例平均等分，ipad设置50%平均比例等分，移动手机全比例等分。 大尺寸 ipad 移动端 2. 使用UI库组件 例如在ementUI中我们可以这样实现： &lt;el-row&gt; &lt;el-col :lg=&quot;8&quot; :sm=&quot;12&quot; :xs=&quot;24&quot;&gt;&lt;/el-col&gt; &lt;el-col :lg=&quot;8&quot; :sm=&quot;12&quot; :xs=&quot;24&quot;&gt;&lt;/el-col&gt; &lt;el-col :lg=&quot;8&quot; :sm=&quot;12&quot; :xs=&quot;24&quot;&gt;&lt;/el-col&gt; &lt;/el-row&gt; 3. 使用flex布局（弹性盒子） 父盒子属性 //前提： display：flex //排列方向: flex-direction //如何换行: flex-wrap //flex-direction属性和flex-wrap属性的简写形式: flex-flow //项目在主轴上的对齐方式: justify-content //在交叉轴上如何对齐: align-items //定义了多根轴线的对齐方式: align-content 子盒子属性 order，flex，align-self 4. 使用相对单位的字体 em,rem,%,vw 上面四种方法基本可以使我们实现一个完美的响应式布局网站，但是只使用以上一种实现响应式网页是不够的，通常在开发中需要搭配使用，flex布局和栅格系统搭配，栅格系统和媒体查询搭配效果会更佳。 5. 技巧 给父盒子添加text-aligin：center属性，当屏幕缩小时，自动居中。 给图片添加max-width：100%，实现图片自动适应的效果 利用媒体查询是div在不同试图屏幕下描写不同样式 container默认有版心，去掉后占满屏幕 调整md内边距来达到定位的效果(md里面的设定一个div块级标签设置宽高，背景值) 给div清理浮动防止文本流漂浮 ","tags":[{"index":-1,"name":"Html&Css","slug":"18jtBTPqK","used":true,"link":"https://qin_hu.gitee.io/blog/tag/18jtBTPqK/"}],"title":"搭建响应式的网站","feature":"https://ouch-cdn2.icons8.com/LP80mQVZ_T5kY_VFd4DWK9D3YFegIu2nodyeiorxBWE/rs:fit:368:368/czM6Ly9pY29uczgu/b3VjaC1wcm9kLmFz/c2V0cy9wbmcvMjAx/L2QyZmIyMTkyLWQ1/ZDctNDI4YS04MzEw/LTc2YjUyZWVmMTli/Zi5wbmc.png","link":"https://qin_hu.gitee.io/blog/post/da-jian-xiang-ying-shi-de-wang-zhan/","stats":{"text":"8 min read","time":455000,"words":1590,"minutes":8},"date":"2023-12-13 09:26:58","dateFormat":"2023-12-13"},{"content":"缘起 项目中常常会写vue组件和react组件，有时候会有出现反复造轮子的情况，原因在于没有模块化管理自定义的组件。把封装好的组件发布到npm上，引用到react和vue项目中大大提高了开发效率。 组件 基于vue3项目示例 1. 使用vite创建vue项目 npm create vite 2. 创建自定义组件 src/components/HaButton.vue &lt;script setup lang=&quot;ts&quot;&gt; defineProps&lt;{ msg: string }&gt;() defineOptions({ name:&quot;HaButton&quot; }) &lt;/script&gt; &lt;template&gt; &lt;h1&gt;{{ msg }}&lt;/h1&gt; &lt;/template&gt; &lt;style scoped&gt; &lt;/style&gt; 3. 创建导出模块文件 src/plugin/index.ts //导入组件 import HaButton from '@/components/HaButton.vue' //保存所有组件 const components = [HaButton] // 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册 const install = function (app) { components.map((component) =&gt; { app.component(component.name, component) //此处的使用的组件vue文件中的name属性 }) } export default { // 导出的对象必须具有 install，才能被 Vue.use() 方法安装 install // 以下是具体的组件列表 } 4. 在vue项目入口文件中测试 src/main.ts import { createApp } from 'vue' import App from './App.vue' &lt;!-- 引入组件导出模块文件 --&gt; import HeerUi from '@/plugin/index' createApp(App).use(HeerUi).mount('#app') 5. 在项目中引入使用 src/App.vue &lt;script setup lang=&quot;ts&quot;&gt; &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;HelloWorld msg=&quot;Vite + Vue&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt; &lt;/style&gt; 配置 配置包信息 package.json { &quot;name&quot;: &quot;heer&quot;, //名称 &quot;private&quot;: false, &quot;version&quot;: &quot;0.0.1&quot;, // 版本 &quot;type&quot;: &quot;module&quot;, &quot;author&quot;: { // 作者信息 &quot;name&quot;: &quot;禾耳&quot; }, &quot;scripts&quot;: { &quot;dev&quot;: &quot;vite&quot;, &quot;build&quot;: &quot;vue-tsc &amp;&amp; vite build&quot;, &quot;preview&quot;: &quot;vite preview&quot; }, &quot;dependencies&quot;: { &quot;vue&quot;: &quot;^3.3.8&quot; }, &quot;exports&quot;: { // 设置导出信息 &quot;.&quot;: { &quot;import&quot;: &quot;./dist/heer.es.js&quot;, &quot;require&quot;: &quot;./dist/heer.umd.js&quot; } }, &quot;devDependencies&quot;: { &quot;@types/node&quot;: &quot;^20.10.4&quot;, &quot;@vitejs/plugin-vue&quot;: &quot;^4.5.0&quot;, &quot;typescript&quot;: &quot;^5.2.2&quot;, &quot;vite&quot;: &quot;^5.0.0&quot;, &quot;vue-tsc&quot;: &quot;^1.8.22&quot; }, // &quot;files&quot;: [&quot;dist&quot;], &quot;main&quot;: &quot;dist/heer.umd.js&quot;, &quot;module&quot;: &quot;dist/heer.mjs&quot; } vite配置信息 vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import path from 'path' export default defineConfig({ plugins: [vue()], // 配置打包信息 build: { lib: { entry: path.resolve(__dirname, './src/plugin/index.ts'), name: 'heer', fileName: (format) =&gt; `heer.${format}.js` }, rollupOptions: { // 确保外部化处理那些你不想打包进库的依赖 external: ['vue'], output: { // 在 UMD 构建模式下为这些外部化的依赖提供一个全局变量 globals: { vue: 'Vue' } } } } }) 配置npm发布忽略文件 在项目文件夹下创建.npmignore文件 # 只有编译后的 dist 目录、package.json、README.md是需要被发布的 # 忽略目录 .DS_Store .vscode/ node_modules packages/ public/ src/ # 忽略指定文件 .eslintrc.cjs .gitignore .npmignore .npmrc .prettierrc.json components.d.ts env.d.ts index.html pnpm-lock.yaml stats.html tsconfig.config.json tsconfig.json vite.config.ts 发布 流程：打包=&gt;登录npm=&gt;发布 先运行npm run build进行打包，打包后运行发布命令npm publish 问题 1. npm login卡住 npm config set registry http://registry.npmjs.org/注意不是下面的https地址，是http地址。 2. 426 Upgrade Required npm install -g https://tls-test.npmjs.com/tls-test-1.0.0.tgz npm config set registry https://registry.npmjs.org 实现vue组件按需导入 之前的写法在发布后只能通过全局引入的方式使用， import haUi from 'hua-ui-vue' 现在想实现import {haButton} from 'hua-ui-vue'的方式引入组件。 1. 在src/plugin下新建componenets文件夹，管理要引入的自定义组件 新建plugin/componenets/haButton/index.ts文件，haButton是我自定义的组件， // 引入自定义组件 import HaButton from '@/components/HaButton.vue' // 添加注册组件的方法 HaButton.install = function(Vue) { Vue.component(HaButton.name, HaButton) } export default HaButton 2. 在组件导出模块入口文件中引入 plugin/index.ts //导入组件 // import HaButton from '@/components/HaButton.vue' import HaButton from &quot;./components/HaButton&quot; //存在所有组件 const components = [HaButton] // 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册 const install = function (app) { components.map((component) =&gt; { app.component(component.name, component) //此处的使用的组件vue文件中的name属性 }) } export default { // 导出的对象必须具有 install，才能被 Vue.use() 方法安装 install, } // 按需导出 export { HaButton } 3. 测试组件是否可以使用 main.ts import { createApp } from 'vue' import './style.css' import App from './App.vue' // import HeerUi from '@/plugin/index' import { HaButton } from '@/plugin/index' createApp(App).use(HaButton).mount('#app') App.vue &lt;ha-button&gt;&lt;/ha-button&gt; 将自定义的Css和组件一起打包 1. 模块入口文件中引入css 在src文件夹下面创建了style文件夹单独管理样式文件，但是在执行打包后发现样式并没有一起打包。原因是自定义的css文件并没有在组件导出模块入口文件中引入。 自定义的样式文件： src/style/index.css :root{ --style-text-color:skyblue; } 在模块入口文件中引入： plugin/index.ts // 引入css import 'src/style/index.css'; 2. 配置libCss，将css打包引入js中 vite.config.ts import libCss from 'vite-plugin-libcss'; export default defineConfig({ plugins: [vue(),libCss()], }) ","tags":[{"index":-1,"name":"vue","slug":"hKztIRrYz","used":true,"link":"https://qin_hu.gitee.io/blog/tag/hKztIRrYz/"},{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"自定义组件库，使用npm管理","feature":"","link":"https://qin_hu.gitee.io/blog/post/zi-ding-yi-vue-zu-jian-shi-yong-npm-guan-li/","stats":{"text":"7 min read","time":370000,"words":1299,"minutes":7},"date":"2023-12-12 16:48:26","dateFormat":"2023-12-12"},{"content":"导航 综合类 快导航网 那些免费的砖 视频类 云朵导航 urlsdh 编程学习 freecodecamp 前端指南 剑指前端 tangshuang的书 hello-algo hello,算法 fe.ecool - 面试宝典 前端编程导航 印记中文 vue中文论坛 medium vue组件库 pdf分享家 码农书籍 总结的书籍 搬书匠 在线看 https://evanli.github.io/programming-book-2/ https://www.kancloud.cn/pillys/qianduan/2049475 https://juejin.cn/post/7082193820187623461 看云 书栈 bookresource 技术胖 在线编辑器 国内 inscode 国外 codesandbox jsfiddle expo stackblitz 插件库推荐 查询npm上的库： https://socket.dev/ 后台插件 - Vue pure-admin 后台插件 - React ant.design arco.design tradingview 中文文档1 https://zlq4863947.gitbook.io/tradingview/4-tu-biao-ding-zhi/widget-methods 中文文档2 https://adam23.gitbooks.io/trading-view-wiki/content/book/Widget-Constructor.html 学习链接 TradingView配置： https://blog.csdn.net/weixin_41852038/article/details/110949569 Markdowm 扩展语法 https://markdown.com.cn/cheat-sheet.html xyHtml5 很多供学习的编程教程 socket.io https://socket.io/zh-CN/ web3 官方文档 https://learnblockchain.cn/docs/web3.js/index.html 学习文档 http://cw.hubwiz.com/card/c/web3.js-1.0/ Metamask 官方文档： https://docs.metamask.io/guide/getting-started.html#basic-considerations Metamask的使用教程： https://mirror.xyz/0xA4Cc3fB0c8F0E1dbDFfFEcdf61103777bd219089/H3tFG-oNdjPQqXUFP5hh7kB2PXLHljoDVtNvfjPta0Y 以太坊浏览器： https://www.yitaifang.com/tokens/ emoji-mart-vue https://github.com/jm-david/emoji-mart-vue md-editor-v3 https://imzbf.github.io/md-editor-v3/docs nodemailer node发送邮箱插件 html2canvas WalletConnect web3连接钱包 方案1.@walletconnect/client 示例：https://ext.dcloud.net.cn/plugin?id=7354 &quot;@walletconnect/client&quot;: &quot;^1.7.0&quot;, &quot;@walletconnect/qrcode-modal&quot;: &quot;^1.7.0&quot;, &quot;web3&quot;: &quot;^1.8.1&quot; 方案2.web3modal-vue2 npm https://www.npmjs.com/package/web3modal-vue2 demo https://smallruraldog.github.io/web3modal-vue 方案2.web3modal-vue2 vue3-aplayer npm https://www.npmjs.com/package/vue3-aplayer 文档 https://github.com/SevenOutman/vue-aplayer/blob/develop/docs/README.zh-CN.md https://aplayer.netlify.app/docs/guide/events.html#%E5%8E%9F%E7%94%9F-media-%E4%BA%8B%E4%BB%B6 vconsole 手机端调试工具 &lt;script src=&quot;https://unpkg.com/vconsole@latest/dist/vconsole.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // VConsole will be exported to `window.VConsole` by default. var vConsole = new window.VConsole(); &lt;/script&gt; nestJs文档 https://www.itying.com/nestjs/ runebook插件汇总 https://runebook.dev/ ahooks react的hook库 https://ahooks.js.org/zh-CN 在线部署 Render 在线部署Node项目 学习网站 udemy : 学习种类丰富。 xyhtml5 ：很多供学习的编程教程 梯子 节点 https://jgjs-connect.com/api/v1/client/subscribe?token=3e507c8410fc55e89356dfc04a8e65e1 https://9.234456.xyz/abc.html?t=567 https://v2rayshare.com/ svg图标和插画 manypixels illustrations delesign opendoodles illustrations 壁纸图片 wallroom pixabay vivianmineker作家的插画集 文档转换处理工具 CleverPDF lightpdf bejson json转换工具 免费Favicon.ico图标在线生成器 图片压缩网址tinypng 文档压缩合并docsmall工具 在线word 在线PS 扒站工具 前端cdn链接 jsdelivr unpkg baomitu bootcdn cdnJs Mp3音乐外链 https://www.joy127.com/link.html https://thewind.xyz/ 字体 https://www.zitijia.com/ chatGpt https://study.zwjjiaozhu.top/posts/chatgpt-mirror-sites.html#gpt3 https://poe.com/Sage https://chatgpt.qdymys.cn/#/chat/1002 https://chat.extkj.cn/#/chat/1002 https://www.ooopn.com/tool/chatgpt/ 找资料网盘 https://www.xuebapan.com/ 文件存储 https://www.docdroid.net/ html模板 tuohang mobanwang 免费api themoviedb - 影视 themoviedb （QcQcqqq） 食谱 菜谱大全 3D模型 Free3D https://www.cgtrader.com/3dsky https://3docean.net/ 隧道 cpolar Github csxiaoyaojianxian -JavaScriptStudy 图表库 https://madeapie.com/#/ 浏览器插件 https://www.crxsoso.com/ https://www.youxiaohou.com/ ","tags":[{"index":-1,"name":"工具","slug":"tLqooY_hn","used":true,"link":"https://qin_hu.gitee.io/blog/tag/tLqooY_hn/"}],"title":"常用链接","feature":"","link":"https://qin_hu.gitee.io/blog/post/chang-yong-lian-jie/","stats":{"text":"5 min read","time":241000,"words":799,"minutes":5},"date":"2023-12-12 09:59:11","dateFormat":"2023-12-12"},{"content":"工具方法 1.随机获取数组元素 const randomIndex=(arr)=&gt;{ return arr[Math.floor((Math.random() * arr.length))] } //使用 let arr=[1,2,3,4,5] console.log(randomIndex(arr)) 2.获取Olson时区 function getTimeZone() { let time = new Date(); let timeZone = time.toLocaleTimeString('en-us', { timeZoneName: 'short' }); //'1:12:38 PM GMT+8' return Intl.DateTimeFormat().resolvedOptions().timeZone; //'Asia/Shanghai' } 3.获取未来日期详情 const getTimeList=(num)=&gt; { //num为未来的第几天 let time = new Date() let date = new Date(time.setDate(time.getDate() + num)).getDate() let month = time.getMonth() + 1 // 获取月份 let day = time.getDay() // 获取星期 switch (day) { // 格式化 case 0: day = &quot;星期日&quot; break case 1: day = &quot;星期一&quot; break case 2: day = &quot;星期二&quot; break case 3: day = &quot;星期三&quot; break case 4: day = &quot;星期四&quot; break case 5: day = &quot;星期五&quot; break case 6: day = &quot;星期六&quot; break } let obj = { date, day, month } return obj } for(let i=0;i&lt;7;i++){ //获取往后的7天 console.log(getTimeList(i)) } 4.根据时间戳获取24进制的时分 const timeConversion=(getTime)=&gt; { //接收一个时间戳 const date = new Date() let t = new Date(getTime) let res =`${t.getHours()&lt;10?'0'+t.getHours():t.getHours()}:${t.getMinutes()&lt;10?'0'+t.getMinutes():t.getMinutes()}` return res } console.log(timeConversion(1658932196000)) 5.比较两个时间大小 const compareTime=(date1, date2)=&gt; { var oDate1 = new Date(date1); var oDate2 = new Date(date2); if (oDate1.getTime() &gt; oDate2.getTime()) { return 1; //第一个大 } else if (oDate1.getTime() &lt; oDate2.getTime()) { return 2; //第二个大 } else if (oDate1.getTime() == oDate2.getTime()) { return 3; //相等 } } console.log(compareTime('2015-1-1', '2015-1-11')) console.log(compareTime('2015-10-12 00:00:00', '2015-09-11 11:23:12')) 6.根据富文本拿到img的src标签内容 function getExecStrs1(content){ let data = []; content.replace(/&lt;img [^&gt;]*src=['&quot;]([^'&quot;]+)[^&gt;]*&gt;/g, function (match, capture) { let index = capture.lastIndexOf(&quot;/&quot;); capture = capture.substring(index + 1); data.push(capture); }); return data; } console.log(getExecStrs1(&quot;&lt;img src='fsadfsdfsdfsdfsdfsd.jpg'&gt;&quot;)) // 方法2 function getExecStrs2(content){ let imgReg = /&lt;img.*?(?:&gt;|\\/&gt;)/gi; //匹配图片中的img标签 let srcReg = /src=[\\'\\&quot;]?([^\\'\\&quot;]*)[\\'\\&quot;]?/i; // 匹配图片中的src let arr = content.match(imgReg); //筛选出所有的img let srcArr = []; for (let i = 0; i &lt; arr?.length; i++) { let src = arr[i].match(srcReg); // 获取图片地址 srcArr.push(src[1]); } return srcArr; } 7.根据年月日获取时间戳 function getTimeStamp({ //接受 month: 1-12 ； day :1-31 ; year: 1000-9999 monthVal, dayVal, yearVal }) { let sm = monthVal.length == 1 ? `0${monthVal}` : monthVal let sd = dayVal.length == 1 ? `0${dayVal}` : dayVal let sT = `${yearVal}/${sm}/${sd}` return Date.parse(sT) } console.log(getTimeStamp({monthVal:11,dayVal:23,yearVal:2022})) 8.将html代码转换未纯文本 const toText = (html) =&gt; { //将html代码转换未纯文本 return html .replace(/&lt;(style|script|iframe)[^&gt;]*?&gt;[\\s\\S]+?&lt;\\/\\1\\s*&gt;/gi, &quot;&quot;) .replace(/&lt;[^&gt;]+?&gt;/g, &quot;&quot;) .replace(/\\s+/g, &quot; &quot;) .replace(/ /g, &quot; &quot;) .replace(/&gt;/g, &quot; &quot;); }; console.log(toText('&lt;h1&gt;fsdfsdfsdf&lt;/h1&gt;')) 9.计算两个时间相差的天数、小时 const timediff=(begin_time, end_time) =&gt;{//计算时间差（分/秒）穿时间戳 //年月日时分秒转换为时间戳 let beginTime = (new Date(begin_time).getTime()) / 1000; let endTime = (new Date(end_time).getTime()) / 1000; var starttime = '' var endtime = '' if (beginTime &lt; endTime) { starttime = beginTime; endtime = endTime; } else { starttime = endTime; endtime = beginTime; } //计算天数 var timediff = endtime - starttime; var days = parseInt(timediff / 86400); //计算小时数 var remain = timediff % 86400; var hours = parseInt(remain / 3600); //计算分钟数 var remain = remain % 3600; var mins = parseInt(remain / 60); var res = days + '天' + hours + '小时' + mins + '分'; // &quot;相差&quot; + day + &quot;天&quot; + hour + &quot;小时&quot; + minute + &quot;分&quot;; return res } 10.根据天数,得到日期描述格式 const getDateFormatText = (num) =&gt; { //根据天数,得到日期描述格式 if (num &gt;= 365) { if (Math.floor(num / 365) == 1) { return `${(num/365).toFixed(0)} year` } else { return `${(num/365).toFixed(0)} years` } } if (num &gt; 90 &amp;&amp; num &lt; 365) { if (Math.floor(num / 30) == 1) { return `${(num/30).toFixed(0)} month` } else { return `${(num/30).toFixed(0)} months` } } if (num &lt;= 90) { if (num == 1) { return `${num} day` } else { return `${num} days` } } } console.log(getDateFormatText(1)) /* // 数字为 1 时，用单数 // day/month/year //  数字大于 1 时，用复数 // days/months/years //  相差多少天（90 天以内): 用 // 天数 day(s) //  相差几个月（超过 90 天): // 用月数 month(s) //  相差几年（超过 11 个月): // 用年数 year(s) */ 11.获取随机id const generateId = () =&gt; { //获取随机id const s = []; const hexDigits = '0123456789abcdef'; for (let i = 0; i &lt; 36; i++) { s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1); } // bits 12-15 of the time_hi_and_version field to 0010 s[14] = '4'; // bits 6-7 of the clock_seq_hi_and_reserved to 01 s[19] = hexDigits.substr((s[19] &amp; 0x3) | 0x8, 1); s[8] = s[13] = s[18] = s[23] = '-'; const uuid = s.join(''); return uuid; } 12.获取时间选择list（年月日） // 获取前后年数列表 const getYearsToNow = (sNum, eNum) =&gt; { //设置年份的选择 let myDate = new Date(); let startYear = myDate.getFullYear() - sNum; //起始年份 let endYear = myDate.getFullYear() + eNum; //结束年份 let yearList = [] for (let i = startYear; i &lt;= endYear; i++) { yearList.push(i) } return yearList } const getMonthList = () =&gt; { let monthList = [] for (let i = 1; i &lt;= 12; i++) { monthList.push(i) } return monthList } const getDayList = (year, month) =&gt; { let myDate = new Date() if (year == undefined || year == null || year=='') { year = myDate.getFullYear() } if (month == undefined || month == null || month=='') { month = 1 } let time = new Date(year, month, 0) let dayList = [] for (let i = 1; i &lt;= time.getDate(); i++) { dayList.push(i) } return dayList } 13.判断一个数组中元素是否在另一个数组中都存在 const compareArr=(arr1,arr2)=&gt;{ //@ arr2中是否有arr1的元素 //@ 接收数组或者数组变量 if(arr1.length&lt;=arr2.length){ let i=null; i=arr1; arr1=arr2; arr2=i; } let isVal=null; let idx=arr2.length let a=0 arr2.forEach(item=&gt;{ if(Object.prototype.toString.call(item) === '[object Object]'){ arr1.forEach(val=&gt;{ if(Object.keys(val)[0]==Object.keys(item)[0]&amp;&amp;Object.values(val)[0]==Object.values(item)[0]){ a++ } }) }else{ if(arr1.includes(item)){ a++ } } }) if(idx!==a){ return 0 }else{ return 1 } } console.log(compareArr([{a:2},{a:1}],[{a:2},{a:1},{a:3}])) //1 console.log(compareArr([4,23],[2,3,4])) //0 14.深度拷贝和浅拷贝 /*@1.实现浅拷贝 浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝 如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址 引用类型，拷贝的就是内存地址会修改原始对象的值 Object.assign */ const shallowClone=(obj)=&gt;{ return Object.assign({},obj) } /* @2.深度拷贝 深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性 */ const deepClone=(obj, hash = new WeakMap())=&gt; { if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作 if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); // 可能是对象或者普通的值 如果是函数的话是不需要深拷贝 if (typeof obj !== &quot;object&quot;) return obj; // 是对象的话就要进行深拷贝 if (hash.get(obj)) return hash.get(obj); let cloneObj = new obj.constructor(); // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身 hash.set(obj, cloneObj); for (let key in obj) { if (obj.hasOwnProperty(key)) { // 实现一个递归拷贝 cloneObj[key] = deepClone(obj[key], hash); } } return cloneObj; } let obj={ a:1, b:[1,2,3] } let shallowObj=shallowClone(obj) //浅拷贝 let deepObj=deepClone(obj) //深度拷贝 V console.log(shallowObj) console.log(deepObj) 15.判断数据类型 function getType(obj){ let type = typeof obj; if (type !== &quot;object&quot;) { // 先进行typeof判断，如果是基础数据类型，直接返回 return type; } // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果 return Object.prototype.toString.call(obj).replace(/^\\[object (\\S+)\\]$/, '$1'); } console.log(getType(null)) //&quot;Null&quot; console.log(getType(1)) //&quot;number&quot; console.log(getType(&quot;as&quot;)) //&quot;string&quot; console.log(getType(true)) //&quot;boolean&quot; console.log(getType([])) //&quot;Array&quot; console.log(getType({})) //&quot;Object&quot; console.log(getType(undefined)) //&quot;undefined&quot; console.log(getType(NaN))//&quot;number&quot; 16.删除字符串末尾逗号 const checkEnd=(msg)=&gt; {//接收格式: '1,1,1' return parseFloat(msg).toString() } console.log(checkEnd('1,1'))//&quot;1&quot; console.log(checkEnd('1.1,,,,,'))//&quot;1.1&quot; 17.数组对象排序 const bubbleSort=(array, val,type='asc') =&gt;{ //asc升序 desc降序 if(type == &quot;asc&quot;){ // 升序 for (var i = 0; i &lt; array.length - 1; i++) { //每一轮比较要比多少次 for (var j = 0; j &lt; array.length - 1 - i; j++) { //如果第一个比第二个大，就交换他们两个位置 if (array[j][val] &gt; array[j + 1][val]) { // 临时存储比较大的那一位数 var temp = array[j] array[j] = array[j + 1] array[j + 1] = temp } } } }else{ // 降序 for (var i = 0; i &lt; array.length - 1; i++) { //每一轮比较要比多少次 for (var j = 0; j &lt; array.length - 1 - i; j++) { //如果第一个比第二个大，就交换他们两个位置 if (array[j][val] &lt; array[j + 1][val]) { // 临时存储比较大的那一位数 var temp = array[j] array[j] = array[j + 1] array[j + 1] = temp } } } } return array; } let arr=[{id:4,name:'aa'},{id:3,name:'bb'},{id:1,name:'cc'},{id:2,name:'dd'}] console.log(bubbleSort(arr,'id','asc')) 18.获取范围内的随机数 function random(min, max) { return Math.floor(Math.random() * (max - min)) + min; } console.log(random(1, 8)) 19.常用正则 export const myRegExp = { // 检查字符串是否为合法QQ号码 isQQ: function (str) { // 1 首位不能是0 ^[1-9] // 2 必须是 [5, 11] 位的数字 \\d{4, 9} var reg = /^[1-9][0-9]{4,9}$/gim; if (reg.test(str)) { console.log(&quot;QQ号码格式输入正确&quot;); return true; } else { console.log(&quot;请输入正确格式的QQ号码&quot;); return false; } }, // 检查字符串是否为合法手机号码 isPhone: function (str) { var reg = /^(0|86|17951)?(13[0-9]|15[012356789]|18[0-9]|14[57]|17[678])[0-9]{8}$/; if (reg.test(str)) { console.log(&quot;手机号码格式输入正确&quot;); return true; } else { console.log(&quot;请输入正确格式的手机号码&quot;); return false; } }, // 检查字符串是否为合法Email地址 isEmail: function (str) { var reg = /^\\w+((-\\w+)|(\\.\\w+))*\\@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z0-9]+$/; // var reg = /\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*/; if (reg.test(str)) { console.log(&quot;Email格式输入正确&quot;); return true; } else { console.log(&quot;请输入正确格式的Email&quot;); return false; } }, // 检查字符串是否是数字 isNumber: function (str) { var reg = /^\\d+$/; if (reg.test(str)) { console.log(str + &quot;是数字&quot;); return true; } else { console.log(str + &quot;不是数字&quot;); return false; } }, // 去掉前后空格 trim: function (str) { var reg = /^\\s+|\\s+$/g; return str.replace(reg, &quot;&quot;); }, // 检查字符串是否存在中文 isChinese: function (str) { var reg = /[\\u4e00-\\u9fa5]/gm; if (reg.test(str)) { console.log(str + &quot; 中存在中文&quot;); return true; } else { console.log(str + &quot; 中不存在中文&quot;); return false; } }, // 检查字符串是否为合法邮政编码 isPostcode: function (str) { // 起始数字不能为0，然后是5个数字 [1-9]\\d{5} var reg = /^[1-9]\\d{5}$/g; // var reg = /^[1-9]\\d{5}(?!\\d)$/; if (reg.test(str)) { console.log(str + &quot; 是合法的邮编格式&quot;); return true; } else { console.log(str + &quot; 是不合法的邮编格式&quot;); return false; } }, // 检查字符串是否为合法身份证号码 isIDcard: function (str) { var reg = /^(^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$)|(^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])((\\d{4})|\\d{3}[Xx])$)$/; if (reg.test(str)) { console.log(str + &quot; 是合法的身份证号码&quot;); return true; } else { console.log(str + &quot; 是不合法的身份证号码&quot;); return false; } }, // 检查字符串是否为合法URL isURL: function (str) { var reg = /^https?:\\/\\/(([a-zA-Z0-9_-])+(\\.)?)*(:\\d+)?(\\/((\\.)?(\\?)?=?&amp;?[a-zA-Z0-9_-](\\?)?)*)*$/i; if (reg.test(str)) { console.log(str + &quot; 是合法的URL&quot;); return true; } else { console.log(str + &quot; 是不合法的URL&quot;); return false; } }, // 检查字符串是否为合法日期格式 yyyy-mm-dd isDate: function (str) { var reg = /^[1-2][0-9][0-9][0-9]-[0-1]{0,1}[0-9]-[0-3]{0,1}[0-9]$/; if (reg.test(str)) { console.log(str + &quot; 是合法的日期格式&quot;); return true; } else { console.log(str + &quot; 是不合法的日期格式，yyyy-mm-dd&quot;); return false; } }, // 检查字符串是否为合法IP地址 isIP: function (str) { // 1.1.1.1 四段 [0 , 255] // 第一段不能为0 // 每个段不能以0开头 // // 本机IP: 58.50.120.18 湖北省荆州市 电信 var reg = /^([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3}$/gi; if (reg.test(str)) { console.log(str + &quot; 是合法的IP地址&quot;); return true; } else { console.log(str + &quot; 是不合法的IP地址&quot;); return false; } }, }; 20.根据时间列表得到总时间 async function getRequestTime(list) { //获取所需时间 // list = ['12h14min', '23h55min'] if (list.length) { let getS = 0 list.forEach(el =&gt; { // 转换为秒 let hour = parseInt(el.replace('min', '').replace('h', '-').slice(0, 2)) let min = parseInt(el.replace('min', '').replace('h', '-').slice(-2)) let se = hour * 60 * 60 + min * 60 getS += se }) return { h: Math.floor(getS / 3600), min: Math.floor((getS % 3600) / 60) } } 21.数组对象去重 let arrRemoval = (list) =&gt; { const set = new Set(list.map(JSON.stringify)); const uniqueArr = Array.from(set).map(JSON.parse); return uniqueArr } 22. 自动触发点击事件 setTimeout(function() { //自动点击 // IE浏览器 if (document.all) { document.querySelector('.tosign .btns-confirm').click(); } // 其它浏览器 else { var e = document.createEvent(&quot;MouseEvents&quot;); e.initEvent(&quot;click&quot;, true, true); document.querySelector('.tosign .btns-confirm').dispatchEvent( e); } // let btnsDom= document.querySelector('.tosign .btns-confirm') // console.log(btnsDom) }, 3000); 23. 最多保留n位小数,动态正则 let maxDecimal = (number,n) =&gt; { return parseFloat(String(number).replace(new RegExp(`^(\\\\-)*(\\\\d+)\\\\.(\\\\d{${n}}).*$`), '$1$2.$3')) } 24. 判断元素是否在可视区 function isContain(dom) { // 获取可视窗口的盖度。 const screenHeight = window.innerHeight || document.documentElement.clientHeight || document.body .clientHeight; // 获取滚动条滚动的高度 const scrollTop = document.documentElement.scrollTop; // 获取元素偏移的高度。就是距离可视窗口的偏移量。 const offsetTop = dom.offsetTop; return offsetTop - scrollTop &lt;= screenHeight; } 25. js统计数组中重复和不重复值的数量 基本数组 const arr = [1, 2, 3, 2, 1, 1]; const count = arr.reduce((obj, val) =&gt; { obj[val] = (obj[val] || 0) + 1; return obj; }, {}); console.log(count); // {1: 3, 2: 2, 3: 1} 26. 判断元素是否在可视区 function isInViewPortOfOne (el) { // viewPortHeight 兼容所有浏览器写法 const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight const offsetTop = el.offsetTop const scrollTop = document.documentElement.scrollTop const top = offsetTop - scrollTop return top &lt;= viewPortHeight } 27. js将时间戳转化为YYYY-MM-DD hh:mm:ss function formatDate(date) { var date = new Date(date); var YY = date.getFullYear() + '-'; var MM = (date.getMonth() + 1 &lt; 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '-'; var DD = (date.getDate() &lt; 10 ? '0' + (date.getDate()) : date.getDate()); var hh = (date.getHours() &lt; 10 ? '0' + date.getHours() : date.getHours()) + ':'; var mm = (date.getMinutes() &lt; 10 ? '0' + date.getMinutes() : date.getMinutes()) + ':'; var ss = (date.getSeconds() &lt; 10 ? '0' + date.getSeconds() : date.getSeconds()); return YY + MM + DD +&quot; &quot;+hh + mm + ss; } 28. 条件删除数组对象中值 list.splice(list.findIndex(item =&gt; item.id === resp.id), 1) 29. replace方法代替replaceAll repalceAll的浏览器兼容性不好 fuction replacGm(l,m,n){//参数：替换的字符串,替换选择内容,替换对象 return l.replace(new RegExp(m,'gm'),n) } replacGm(&quot;aaa_b_&quot;,&quot;_b_&quot;,&quot;ccc&quot;) //aaaccc 30.数字转化为千位表示格式 function log(t) { console.log(t); } export default function toThousands(num, reservedBit = 0, isDeZero = true) { //传数，保留位数,是否去掉末尾的0 num = parseFloat(num); let m = null; m = num.toFixed(reservedBit); if (isDeZero) { m = String( Math.round(num * Math.pow(10, reservedBit)) / Math.pow(10, reservedBit) ); let str = &quot;&quot;; if (m.includes(&quot;.&quot;)) { for (let i of m.split(&quot;.&quot;)[1]) { if (i !== &quot;0&quot;) { str += i; } } } m = m.includes(&quot;.&quot;) ? `${m.split(&quot;.&quot;)[0]}.${str}` : m; } return m.toString().replace(/\\d+/, function (n) { return n.replace(/(\\d)(?=(?:\\d{3})+$)/g, &quot;$1,&quot;); }); } log(toThousands(&quot;123123.120&quot;, 4, false)); 31.隐藏中间文字 export const centerEllipsis = (text, num = 3) =&gt; { //参数：文字，指定前后留几个单词 let t = text.substring(num, text.length - num); return text.replace(new RegExp(t, &quot;gm&quot;), `${&quot;.&quot;.repeat(num)}`); }; 32. 精准四舍五入保留两位小数 function roundToTwo(num) { return +(Math.round(num + &quot;e+2&quot;) + &quot;e-2&quot;); } roundToTwo(123.1234) 33. 实现F11全屏 const fullScreen=()=&gt;{ if(document.documentElement.RequestFullScreen){ document.documentElement.RequestFullScreen(); } //兼容火狐 console.log(document.documentElement.mozRequestFullScreen) if(document.documentElement.mozRequestFullScreen){ document.documentElement.mozRequestFullScreen(); } //兼容谷歌等可以webkitRequestFullScreen也可以webkitRequestFullscreen if(document.documentElement.webkitRequestFullScreen){ document.documentElement.webkitRequestFullScreen(); } //兼容IE,只能写msRequestFullscreen if(document.documentElement.msRequestFullscreen){ document.documentElement.msRequestFullscreen(); } } document.getElementById(&quot;noFullScreen&quot;).onclick=function(){ if(document.exitFullScreen){ document.exitFullscreen() } //兼容火狐 console.log(document.mozExitFullScreen) if(document.mozCancelFullScreen){ document.mozCancelFullScreen() } //兼容谷歌等 if(document.webkitExitFullscreen){ document.webkitExitFullscreen() } //兼容IE if(document.msExitFullscreen){ document.msExitFullscreen() } } 34. es6动态导入模块 const dynamicImport = async (moduleUrl: string) =&gt; { const module = await import(moduleUrl); return module.default; } 学习网址 https://juejin.cn/post/6844903873048477709##heading-64 https://juejin.cn/post/6844903650586787848##heading-8 Dom节点操作 1. 读取shadow-root里面的内容 //先获取宿主dom节点，再获取shadow-root里面的内容 document.querySelector('w3m-modal-backcard').shadowRoot.querySelector('.w3maction') 2. 获取video时长 // 秒转换分钟00:00:00格式 function timeToMinute(times) { console.log('zyc11122'); console.log('zyc111'); var t; if (times &gt; -1) { var hour = Math.floor(times / 3600); var min = Math.floor(times / 60) % 60; var sec = times % 60; if (hour &lt; 10) { t = '0' + hour + &quot;:&quot;; } else { t = hour + &quot;:&quot;; } if (min &lt; 10) { t += &quot;0&quot;; } t += min + &quot;:&quot;; if (sec &lt; 10) { t += &quot;0&quot;; } t += sec.toFixed(2); } t = t.substring(0, t.length - 3); return t; } 使用 let video: { [key: string]: any } = document.querySelector(&quot;#video&quot;) video.oncanplay = () =&gt; { console.log(timeToMinute(video.duration)) } 3. 获取页面路径参数 例如：www.baidu.com?a=1 调用getQueryVariable('a')可以拿到值。 function getQueryVariable(variable:string) { var query = window.location.href; var rooms = query.split('?'); for (var i = 0; i &lt; rooms.length; i++) { var pair = rooms[i].split('='); if (pair[0] == variable) { return (pair[1].split('&amp;'))[0] } } //或者拼接&amp;后面的值 var vars = query.split('&amp;') for (var i = 0; i &lt; vars.length; i++) { var pair = vars[i].split('=') if (pair[0] == variable) { return pair[1] } } } 4. 实现复制 function copy(data){ const inputDom=document.createElement('input') input.value=data document.body.appendChild(inputDom); inputDom.select() document.execCommand('Copy') document.body.removeChild(inputDom) } ","tags":[{"index":-1,"name":"es6","slug":"YEr5SsLJh","used":true,"link":"https://qin_hu.gitee.io/blog/tag/YEr5SsLJh/"}],"title":"常用工具方法，Dom节点操作","feature":"https://cdn.pixabay.com/photo/2014/08/15/11/29/beach-418742_1280.jpg","link":"https://qin_hu.gitee.io/blog/post/chang-yong-de-fang-fa-zheng-li/","stats":{"text":"22 min read","time":1270000,"words":4086,"minutes":22},"date":"2023-12-11 16:31:44","dateFormat":"2023-12-11"},{"content":"1. 介绍 SM2是国密即国家密码局认定的国产密码算法。 SM2性能更优更安全：密码复杂度高、处理速度快、机器性能消耗更小。 缘起：公司的项目不断的有黑客进行攻击，我们使用的接口md5校验加密，思路是将接口路径拼接时间戳，再加上前后端约束的密钥来生成md5密钥，放在请求头(前端加密，后端解密。)该加密方案非双向加密，复杂度不够高，于是决定在原有的加密方案上再加一层加密，SM2非对称加密复杂度高，性能方面也不错，所以选择使用SM2加密。 2. 思路 后端将响应加密，前端对响应解密。前端将请求加密，后端对请求解密。前端在请求前加签名，后端接收时解签。当三个都通过时即验证通过。 有两对密钥。签名公钥和私钥，加密公钥和私钥。 签名是使用私钥签名公钥解签。加密是使用公钥加密，私钥解密。 3. 依赖 前端使用的依赖： sm-crypto,js-base64,buffer,is-base64,gm-crypto 4. 方法 import { sm2 } from 'sm-crypto' import { Base64 } from 'js-base64' import { Buffer } from &quot;buffer&quot;; import isBase64 from 'is-base64' import { SM2 } from 'gm-crypto'; /** * 工作环境中公钥和私钥后端获取给前端使用更加保险。 * 注意点: * 1. 确定好加密模式.是C1C2C3还是C1C3C2 * 2. java加密会自动加2个字节,前端解密前需要对加密删除两个字节. */ export default class Gm2Utils { static publicKey; static privateKey; // 类型 private cipherMode = 1 // 1 - C1C3C2，0 - C1C2C3，默认为1 constructor() { Gm2Utils.generateKeyPair() } /** * @desc 获取公钥和私钥 */ static generateKeyPair() { const { publicKey, privateKey } = SM2.generateKeyPair() Gm2Utils.privateKey = privateKey; Gm2Utils.publicKey = publicKey; return { publicKey, privateKey } } /** * @desc 加密，使用公钥加密 * @param encryptData 需要加密的数据 */ toEncrypt({ encryptData, type = 1 }) { if (type == 1) { let result = sm2.doEncrypt(encryptData, Gm2Utils.publicKey, this.cipherMode) console.log(result) return result } if (type == 2) { const encryptedData = SM2.encrypt(JSON.stringify(encryptData), Gm2Utils.publicKey, { inputEncoding: 'utf8', outputEncoding: 'base64', mode: SM2.constants.C1C3C2 }) // 尝试解密 // const b = Buffer.from(encryptedData, 'base64') // const bufString = b.toString('hex'); // bufString.substr(2) // const decryptedData = SM2.decrypt(bufString, Gm2Utils.privateKey, { // inputEncoding: 'hex', // outputEncoding: 'utf8' // }) // console.log('解密结果', decryptedData) // end return encryptedData } } /** * @desc 解密 * @param encryptData 解密数据,使用私钥解密 * @param type 1=使用sm-crypto加密 2=使用gm-crypto * Buffer(base64)=&gt;16进制=&gt;截取2个字节(根据后端的实际情况) */ async toDecrypt({ encryptData, type = 1 }) { const base64Data = Buffer.from(encryptData, 'base64') let hexData = base64Data.toString('hex'); // 如果是java或者C返回的加密，需要手动去除两个字节 // hexData = hexData.substr(2) if (type == 1) { let result = sm2.doDecrypt(hexData, Gm2Utils.privateKey, this.cipherMode) console.log(result) if (result?.length) { return JSON.parse(result) } } if (type == 2) { let result = SM2.decrypt(hexData, Gm2Utils.privateKey, { inputEncoding: 'hex', outputEncoding: 'utf8', mode: SM2.constants.C1C3C2 }) if (result?.length) { return JSON.parse(result) } } } /** * @desc 加签名，使用私钥签名 * @param signData 签名数据 */ toSignature(signData) { let sigValueHex = sm2.doSignature(signData, Gm2Utils.privateKey) // 签名 return sigValueHex // let verifyResult = sm2.doVerifySignature(' 123', sigValueHex, publicKey) // 验签结果 // console.log(verifyResult) // console.log(&quot;publicKey&quot;, publicKey) // console.log(&quot;privateKey&quot;, privateKey) // console.log(sigValueHex) // console.log(&quot;decryptPrivateKey&quot;, this.decryptPrivateKey?.length) // console.log(&quot;decryptPublicKey&quot;, this.decryptPublicKey?.length) // test end // console.log('signData', signData) // let sigValue = sm2.doSignature(signData, this.decryptPrivateKey) // 签名 // console.log('sigValue', sigValue) // // let data: Buffer | string = Buffer.from(sigValue) // // console.log(data) // let data = Base64.encode(sigValue); // console.log(&quot;签名&quot;, data) // let publicKey1 = sm2.getPublicKeyFromPrivateKey(this.decryptPrivateKey) // console.log(publicKey1) // let resultD = sm2.doVerifySignature(signData, sigValue, publicKey1) // console.log(resultD) // debugger // this.verifySignature({ // signData: signData, // sigValueHex: sigValue // }) } /** * @desc 验证签名 */ toVerifySignature(signData) { let verifyResult = sm2.doVerifySignature(signData, signData, Gm2Utils.publicKey) // 验签结果 return verifyResult } /** * @desc 16进制转ArrayBuffer * @param */ hexToArrayBuffer(hexadecimal) { // 16toArrayBuffer const arrayBuffer = new Uint8Array(hexadecimal.match(/[\\da-f]{2}/gi).map(function (h) { return parseInt(h, 16) })).buffer return arrayBuffer } //#region 工具方法 // 字符串转16进制字符串 string2Hex(str) { let val = &quot;&quot; for (let i = 0; i &lt; str.length; i++) { if (val == &quot;&quot;) val = str.charCodeAt(i).toString(16) else val += str.charCodeAt(i).toString(16) } return val } // 字符串转ArrayBuffer string2ArrayBuffer(str) { // 首先将字符串转为16进制 let val = &quot;&quot; for (let i = 0; i &lt; str.length; i++) { if (val === '') { val = str.charCodeAt(i).toString(16) } else { val += ',' + str.charCodeAt(i).toString(16) } } // 将16进制转化为ArrayBuffer return new Uint8Array(val.match(/[\\da-f]{2}/gi).map(function (h) { return parseInt(h, 16) })).buffer } // Buffer转Base64 arrayBufferToBase64(buffer) { let binary = ''; let bytes = new Uint8Array(buffer); let len = bytes.byteLength; for (var i = 0; i &lt; len; i++) { binary += String.fromCharCode(bytes[i]); } console.log(window.btoa(binary)) return window.btoa(binary); } // base64toBuffer base64ToBuffter(base64String) { const base64 = atob(base64String); // 将 Base64 字符串解码为二进制数据 const bytes = new Uint8Array(base64.length); for (let i = 0; i &lt; base64.length; i++) { bytes[i] = base64.charCodeAt(i); } const buffer = bytes.buffer; // 将 Uint8Array 转换为 ArrayBuffer return buffer } // base64 to string getDecode(base64) { // 对base64转编码 var decode = atob(base64); // 编码转字符串 var str = decodeURI(decode); return str; } decode64(str) { return decodeURIComponent(str.split('').map(function (c) { return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2); }).join('')); } base64ToStr = (base64Str: string): string =&gt; { if (isBase64(base64Str)) { return Base64.decode(base64Str); } return base64Str; }; arrayBuffer2Hex(buffer) { const hexArr = Array.prototype.map.call( new Uint8Array(buffer), function (bit) { return ('00' + bit.toString(16)).slice(-2) } ) return hexArr.join('') } arrayBufferToString(buffer, encoding = 'utf-8') { const decoder = new TextDecoder(encoding); return decoder.decode(buffer); } // #endregion } 使用 import {Gm2Utils} from './Gm2Utils' const gm2Utils=new Gm2Utils() ","tags":[],"title":"接口请求和响应使用SM2加密","feature":"","link":"https://qin_hu.gitee.io/blog/post/jie-kou-qing-qiu-he-xiang-ying-shi-yong-sm2-jia-mi/","stats":{"text":"6 min read","time":352000,"words":1190,"minutes":6},"date":"2023-12-10 16:43:53","dateFormat":"2023-12-10"},{"content":"初衷 使用electron对文件操作时，调用node自带api感觉有些麻烦，想封装一个传参直接保存文件的hook方法，故封装了这个hrary类。hrary名字比较吉利，意为幸运。 代码 import fs from 'fs' import path from 'path'; import { app } from 'electron' import { is } from '@electron-toolkit/utils' export function parse(str: string) { let value try { value = JSON.parse(str) } catch { value = null } return value } export function stringify(data: any) { let value try { value = JSON.stringify(data) } catch { value = null } return value } export default class Hrary { savePath: string; /** * 缓存的数据 */ data?: object | undefined; constructor(data?: object) { this.data = data this.savePath = is.dev &amp;&amp; process.env['ELECTRON_RENDERER_URL'] ? this.getPath(`${app.getAppPath()}\\\\hrary.json`) : this.getPath(`${path.dirname(app.getPath('userData'))}\\\\hrary.json`) } /** * 初始化文件 */ init() { return new Promise(async (res, rej) =&gt; { const isInitHandle: boolean | unknown = await this.isInit() if (Boolean(isInitHandle)) { res(false) return } fs.writeFile(this.savePath, stringify({ }), (err) =&gt; { if (err) { console.error('temporary save error') rej(err) } res(true) console.log('temporary init success') }) }) } /** * 是否初始化 */ isInit() { return new Promise((res) =&gt; { console.log(&quot;this.savePath:&quot;, this.savePath) fs.readFile(this.savePath, 'utf-8', (err, data) =&gt; { console.log('data', data) if (err) { res(false) } res(Boolean(data)) }) }) } /** * 添加文件缓存 * @param key * @param value */ set(key, value) { return new Promise(async (res, rej) =&gt; { let allData: any = await this.getAll() allData = parse(allData) allData[key] = value fs.writeFile(this.savePath, stringify(allData), (err) =&gt; { if (err) { rej(err) } res(true) }) }) } /** * 获取缓存 */ get(key) { return new Promise(async (res) =&gt; { try { let allData: any = await this.getAll() allData = parse(allData) if (allData[key]) { res(allData[key]) } else { res(false) } } catch (error) { res(false) } }) } /** * 删除缓存 */ delete(key) { return new Promise(async (res) =&gt; { try { let allData: any = await this.getAll() allData = parse(allData) delete allData[key] fs.writeFile(this.savePath, stringify(allData), (err) =&gt; { if (err) { res(false) } res(true) }) } catch (error) { res(false) } }) } /** * 获取所有缓存对象 */ getAll() { return new Promise((res, rej) =&gt; { fs.readFile(this.savePath, 'utf-8', (err, data) =&gt; { if (err) { rej(err) } // console.log(JSON.parse(stringify(data))) res(parse(stringify(data))) }) }) } /** * 是否存在缓存key */ has(key) { return new Promise(async (res) =&gt; { let allData: any = await this.getAll() allData = parse(allData) res(allData.hasOwnProperty(key)) }) } /** * 清除所有缓存 */ clear() { return new Promise(async (res) =&gt; { fs.writeFile(this.savePath, stringify({}), (err) =&gt; { if (err) { res(false) } res(true) }) }) } /** * 工具函数 */ /** * path路径转化斜杠 * @param path 路径 * @returns */ getPath(path) { return path.replaceAll('\\\\', '/') } } 使用 import Hrary from './hrary' const hrary = new Hrary() hrary.init() 初始化后，会在项目文件夹中生成一个hrary.json的文件,存储json数据。 加强版 当我们想存储更多json文件场景时，以上方案无法实现。现在改成通过文件夹管理json文件： import fs from 'fs' import path from 'path'; import { app } from 'electron' import { is } from '@electron-toolkit/utils' export default class Hrary { savePath: string; /** * * @param mdrname 缓存根文件夹名称 */ mdrname = 'liuji'; constructor(mdrname) { this.mdrname = mdrname this.savePath = is.dev &amp;&amp; process.env['ELECTRON_RENDERER_URL'] ? this.getPath(`${app.getAppPath()}\\\\${this.mdrname}`) : this.getPath(`${path.dirname(app.getPath('userData'))}\\\\${this.mdrname}`) } /** * 初始化文件 */ init() { return new Promise(async (res) =&gt; { const isInitHandle: boolean | unknown = await this.isInit() if (Boolean(isInitHandle)) { console.log('已初始化~') res(false) return } await this.createCatalogue(this.savePath) res(true) }) } /** * 是否初始化 */ async isInit() { return this.hasFile(this.savePath) } /** * 添加文件缓存 * @param key * @param value * @param path = 根路径下的文件路径 */ set({ key, value, path }) { return new Promise(async (res, rej) =&gt; { let allData: any = await this.getAll(path) allData = this.parse(allData) allData[key] = value fs.writeFile(path, this.stringify(allData), (err) =&gt; { if (err) { rej(err) } res(true) }) }) } /** * @desc 获取缓存 * @params path 路径 */ get({ key, path }) { return new Promise(async (res) =&gt; { try { let allData: any = await this.getAll(path) allData = this.parse(allData) if (allData[key]) { res(allData[key]) } else { res(false) } } catch (error) { res(false) } }) } /** * 删除缓存 */ delete({ key, path }) { return new Promise(async (res) =&gt; { try { let allData: any = await this.getAll(path) allData = this.parse(allData) delete allData[key] fs.writeFile(path, this.stringify(allData), (err) =&gt; { if (err) { res(false) } res(true) }) } catch (error) { res(false) } }) } /** * 获取所有缓存对象 * @param path 根路径下的文件 */ getAll(path) { return new Promise((res, rej) =&gt; { fs.readFile(path, 'utf-8', (err, data) =&gt; { if (err) { rej(err) } // console.log(JSON.parse(stringify(data))) res(this.parse(this.stringify(data))) }) }) } /** * 是否存在缓存key */ has({ key, path }) { return new Promise(async (res) =&gt; { let allData: any = await this.getAll(path) allData = this.parse(allData) res(allData.hasOwnProperty(key)) }) } /** * 清除所有缓存 */ clear(path) { return new Promise(async (res) =&gt; { fs.writeFile(path, this.stringify({}), (err) =&gt; { if (err) { res(false) } res(true) }) }) } /** * 新建目录 */ createCatalogue(path) { return new Promise((res, rej) =&gt; { if (this.hasFile(path)) { console.log(path + '目录已存在') res(true) return } fs.mkdir(path, (err) =&gt; { if (err) { rej(err) throw err }; // 如果出现错误就抛出错误信息 console.log('文件夹创建成功'); res(true) }) }) } /** * @dsc 新建文件 * @param path 根目录下的路径 */ createFile(path) { if (this.hasFile(path)) { console.log(path + '文件已存在') return } return new Promise((res, rej) =&gt; { fs.writeFile(path, this.stringify({ }), (err) =&gt; { if (err) { console.error('文件创建失败') rej(err) } res(true) console.log('文件创建成功') }) }) } /** * @dsc 删除文件 * @param path */ deleteFile(path) { if (!this.hasFile(path)) { console.log(path + '文件不存在') return } return new Promise((res, rej) =&gt; { fs.unlink(path, (err) =&gt; { if (err) { rej(false) throw err } res(true) }); }) } /** * @description 获取目录下的文件名 * @param path = 目录下路径 */ getCataAllFile(path) { return new Promise((res, rej) =&gt; { if (!this.hasFile(path)) { res([]) } fs.readdir(path, (err, data) =&gt; { if (err) { rej(err) return } res(data) }) }) } /** * 判断目录或者文件是否已存在 */ hasFile(path) { console.log(fs.existsSync(path)) return fs.existsSync(path) } /** * @desc 获取文件夹下的所有key * @param path 目录路径 */ async getAllKeyGroup(path) { let filenameList: any = await this.getCataAllFile(path) console.log('filenameList', filenameList) let list: any = [] for (let index = 0; index &lt; filenameList.length; index++) { let p = filenameList[index] let key: any = await this.getAll(path + p) let keyList: string[] = Object.keys(JSON.parse(key)) let folderKeyList = keyList.map(item =&gt; { return { key: item, folder: p.replaceAll('.json', '') } }) list = list.concat(folderKeyList) } console.log(list) return list } /** * @desc 文件名重命名 */ renameFile({ newPath, oldPath }) { return new Promise((res, rej) =&gt; { fs.rename(oldPath, newPath, (err) =&gt; { if (err) { rej(err) } res(true) }) }) } /** * 工具函数 */ /** * path路径转化斜杠 * @param path 路径 * @returns */ getPath(path) { return path.replaceAll('\\\\', '/') } /** * @desc 路径转换JSON对象 */ parse(str: string) { let value try { value = JSON.parse(str) } catch { value = null } return value } /** * @desc 路径转换JSON字符串 */ stringify(data: any) { let value try { value = JSON.stringify(data) } catch { value = null } return value } } 初始化使用 import hrary from './class/hrary' const myHarray = new hrary('liuji') await myHarray.init() // 创建一个mind和list文件夹 await myHarray.createCatalogue(myHarray.savePath + '/mind') await myHarray.createFile(myHarray.savePath + '/mind/默认文件夹.json') ","tags":[{"index":-1,"name":"Electron","slug":"6V806ttsC","used":true,"link":"https://qin_hu.gitee.io/blog/tag/6V806ttsC/"},{"index":-1,"name":"nodeJs","slug":"E7wJE8AQv","used":true,"link":"https://qin_hu.gitee.io/blog/tag/E7wJE8AQv/"}],"title":"文件处理插件 - hrary","feature":"","link":"https://qin_hu.gitee.io/blog/post/wen-jian-chu-li-cha-jian-hrary/","stats":{"text":"8 min read","time":449000,"words":1389,"minutes":8},"date":"2023-12-05 14:09:56","dateFormat":"2023-12-05"},{"content":"Api说明： https://www.baidu.com/s 百度搜索命令中的参数 必备参数： wd——查询的关键词(Keyword) pn——显示结果的页数(Page Number) cl——搜索类型(Class)，cl=3为网页搜索 可选参数： rn——搜索结果显示条数(Record Number)，取值范围在10--100条之间，缺省设置rn=10 ie——查询输入文字的编码(Input Encoding)，缺省设置ie=gb2312，即为简体中文 tn——提交搜索请求的来源站点 #思路 使用form表单的action属性接受地址，method方法设置请求方法，此处使用get请求； 使用input的name属性设置请求参数。例：设置cl请求参数,value属性设置cl参数值。 &lt;input type=&quot;hidden&quot; name=&quot;cl&quot; id=&quot;&quot; value=&quot;3&quot; /&gt; 设置submit来提交表单数据 #代码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;!-- 使用form表单实现百度搜索 --&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;form action=&quot;https://www.baidu.com/s&quot; method=&quot;get&quot;&gt;&lt;!--metoad:设置地址；method设置方法get/post--&gt; &lt;input type=&quot;hidden&quot; name=&quot;cl&quot; id=&quot;&quot; value=&quot;3&quot; /&gt;&lt;!--设置拼接参数cl，name属性写api的参数名，value写参数值--&gt; &lt;input type=&quot;hidden&quot; name=&quot;pn&quot; id=&quot;&quot; value=&quot;3&quot; /&gt;&lt;!--设置拼接参数pn--&gt; &lt;input type=&quot;text&quot; name=&quot;wd&quot; id=&quot;&quot; value=&quot;&quot; placeholder=&quot;请输入关键字&quot; /&gt; &lt;input type=&quot;submit&quot; id=&quot;&quot; name=&quot;&quot; /&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ","tags":[{"index":-1,"name":"Html&Css","slug":"18jtBTPqK","used":true,"link":"https://qin_hu.gitee.io/blog/tag/18jtBTPqK/"}],"title":"使用form表单实现百度搜索","feature":"","link":"https://qin_hu.gitee.io/blog/post/shi-yong-form-biao-dan-shi-xian-bai-du-sou-suo/","stats":{"text":"2 min read","time":116000,"words":404,"minutes":2},"date":"2022-08-27 16:19:07","dateFormat":"2022-08-27"},{"content":"一.文字缩进 文章首段落的空格 text-indent: 2em; 二.隐藏方法 1.transform: rotateY(90deg); 2.opcity：0; 3.display:none 4.z-index:-1 5.visibility: hidden; 6.html5新标签hidden 直接添加在标签上 例: &lt;p hidden&gt; &lt;/p&gt; 三.vertical-align设置元素的垂直对齐方式。 把元素的顶端与行中最高元素的顶端对齐: vertical-align:top 四.重叠 1.子绝父相（父盒子设置相对定位（可选），子盒子设置绝对定位（必须）） 2.z-index值越大排序越靠前 五.元素等比例缩放 1.图片父盒子设置弹性布局垂直居中，设置宽100%，高；图片设置max-width:100%; 父盒子 img_f{ display: flex; justify-content: center; align-items: center; } 图片 img{ max-width:100%; } 2.scole缩放 transform: scale(); 六.p标签超出显示省略号 1.单行显示 p{ overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } 2.多行显示 *-webkit-line-clamp: 3;表示超出三行显示省略号 p { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; //当p标签中有数字使多行显示失效时： word-wrap: break-word; word-break: break-all; } 七.disblok ：table disblok:table实现基于子元素在父盒子上显示 前提：给distable父元素添加绝对定位 且都为零 祖先元素相对定位 上代码 1.html &lt;div class=&quot;text&quot;&gt; &lt;div class=&quot;distable&quot;&gt; &lt;div class=&quot;discell&quot;&gt; &lt;h4&gt;单芯线&lt;/h4&gt; &lt;p&gt;（80℃,100℃,105℃,120℃, 125℃,150℃,180℃,200℃）&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; 2.css .text{ positive:absolute; left:0; bottom:0; top:0; right:0; height: 100%; } .distable{ display: table; margin:auto; } .discell{ display: table-cell; vertical-align: middle; text-align: center; } 八.阴影 1.文本阴影（text-shadow） 语法: text-shadow：h-shadow v-shadow blur color； 例子： p{ color:white; text-shadow:2px 2px 4px #000; } 2.边框阴影（box-shadow） 语法: box-shadow: h-shadow v-shadow blur spread color inset; 例子： box-shadow:4px 4px 5px 3px #999; box-shadow:0 0 9px 3px #999; 九.vh与vw 1.介绍：vw和vh是前端开发中的一个动态单位，是一个相对于网页视口的单位 2.理解：系统会将视口的宽度和高度分为100份，1vw占用视口宽度的百分之一，1vh占用视口高度的百分之一。 3.结论：vw、vh是一个动态的单位，会随着视口的变化而变化（相对单位）。 4.使用场景：保证移动开发中屏幕旋转之后尺寸不变。 十.常用颜色统计 1.透明色 //文字会透明 background: #000; opacity: 0.4; //文字不会透明 //偏白 background: rgba(255, 255, 255, 0.3); //偏黑 background:rgb(10 10 10 / 15%) !important; //浅灰适合边框 border: 1px solid #efefef; border: 1px solid #eee; 十一.css3图片模糊 .blur{ filter: url(blur.svg#blur);/* FireFox, Chrome, Opera */ filter: blur(5px);/* Chrome, Opera */ filter: progid:DXImageTransform.Microsoft.Blur(PixelRadius=10, MakeShadow=false); /* IE6~IE9 */ } /*设置模糊玻璃效果*/ backdrop-filter: blur(5px); 十二.a链接悬浮显示小手： //默认： style=&quot;cursor:default&quot; //小手： style=&quot;cursor:pointer &quot; //加载条： style=&quot;cursor:progress&quot; 十三.cellspacing与cellpadding //规定单元格之间的空间。 cellspacing=&quot;10&quot; //表格单元边界与单元内容之间的间距 cellpadding=&quot;20&quot; 十四.超链接点击不起作用 position: relative; z-index: 99; 十五.html页面右侧空白去除 html { width: 100%; overflow-x: hidden; } 十六.居中 水平居中 margin:0 auto; 文字的水平居中方法 p{ /*垂直居中关键*/ line-height: 200px; text-align:center; height: 200px; } padding填充 .children { width: 100px; height: 100px; padding: 50px; background-color: black; background-clip:content-box;/*居中的关键*/ translate(-50%,-50%) #content{ left:50%; top:50%; transform:translate(-50%,-50%); -webkit-transform:translate(-50%,-50%); background-color:gray; color:white; position:absolute; } 垂直居中 绝对定位居中 前提是父容器元素： position: relative #content{ width: 50%; height: 50%; overflow: auto; margin: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0; } 注意：高度必须定义，建议加 overflow: auto，防止内容溢出。 absolute定位 .children { position:absolute; left:50%; top:50%; margin:-25px 0 0 -25px ; height:50px; width:50px; background-color: black; } flex居中 .parent { display:flex; align-items: center;/*垂直居中*/ justify-content: center;/*水平居中*/ width:100%; height:100%; background-color:red; } 十七.text-decoration //定义文本上的一条线。 text-decoretion：overline //定义穿过文本下的一条线。 text-decoretion：line-through //定义文本下的一条线。 text-decoretion：underline 十八.对ie浏览器的兼容 &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt; 十九.动画无过渡效果 animation: turn 5s infinite cubic-bezier(0.37, 0.34, 0.74, 0.73); 二十.元素点击时去除蓝色背景 //1.移动/ipad端设置 cursor: none; //2.设置user-select: none -moz-user-select: none; /* 火狐 */ -webkit-user-select: none; /*webkit浏览器*/ -ms-user-select: none; /*IE10*/ -khtml-user-select: none; /*早期浏览器*/ user-select: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); 二十一.input，button变成圆角后,鼠标点击任有矩形边框解决 //设置轮廓 outline: none; 二十二.多媒体音频视频自动播放 autoplay=&quot;autoplay&quot; 二十三.设置input输入框中placeholder字体颜色 input::-webkit-input-placeholder{ color:#fff; } 二十四.背景渐变 background-image: linear-gradient( 角度 , 颜色); 例子： 蓝色渐变：background-image: linear-gradient(to right , #7A88FF, #7AFFAF); 二十五.设置文本输入框中字体的颜色 input::-webkit-input-placeholder{ color: #fff; } 二十六.背景图片铺满屏幕 body { margin: 0px; padding: 0px; } div.bg { background: url(./img/img3.jpg) repeat center; background-size: cover; position: fixed; inset: 0; z-index: -1; } 二十七.inset inset=0; //相等于 position:fiexd; left:0; bottom:0; top:0; right:0; 二十八.防止审查时页面抖动 html, body {height:100%;overflow:auto;margin: 0;} html{overflow-y:scroll;} 二十九.手机端点击标签有背景 .el-checkbox{ -webkit-tap-highlight-color:rgba(0,0,0,0); } 二十九.取消a链接点击背景有背景色 -webkit-tap-highlight-color:rgba(0,0,0,0); 三十.字体渐变 //从上到下 .style1{ background: linear-gradient(to bottom,#f0610e, #e8771a, #fff34a); -webkit-background-clip: text; color: transparent; } //从左到右 .style2{ background: linear-gradient(to right,#f0610e, #e8771a, #fff34a); -webkit-background-clip: text; color: transparent; } 三十一.移动端禁止双手缩放 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;&quot;/&gt; 三十三. 图片变颜色 filter: sepia(1) saturate(100); ","tags":[{"index":-1,"name":"Html&Css","slug":"18jtBTPqK","used":true,"link":"https://qin_hu.gitee.io/blog/tag/18jtBTPqK/"}],"title":"html常用技巧","feature":"https://images.squarespace-cdn.com/content/v1/5a9d2a6675f9eef8f485ce41/1684567986654-E7OEGD0H4HVJ1KFN1GY7/image-asset.jpeg?format=500w","link":"https://qin_hu.gitee.io/blog/post/html-chang-yong-ji-qiao/","stats":{"text":"7 min read","time":419000,"words":1494,"minutes":7},"date":"2022-08-21 11:55:55","dateFormat":"2022-08-21"}]}